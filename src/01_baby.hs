-- プロジェクトルートで `stack ghci` として `:l src/100_baby.hs とすれば以下で定義した関数たちを利用できる。（他の実行のしかたもあると思うけど）`

------------------------
-- Baby First Function
------------------------

doubleMe x = x + x

doubleUs x y = doubleMe x + doubleMe y

-- 100 以下のときだけ数を 2 倍するような関数
{-
    Haskell の if 式（if 文ではなく、if 式であることに注目）では else 節が必須。
    命令型言語プログラムは本質的にはプログラム実行時にコンピュータが実行するステップの列。
    一方、Haskell プログラムは関数の集まり。関数はデータ値を結果の値に変換するのに使われ、
    すべての関数はなんらかの値を返す。そしてその値はまた別の関数によって使われる。
    これは、**すべての if は対応する else を持たなければならないということを意味する**。
    Haskell の if は必ず値を返す式であって、文ではないのである。
-}
doubleSmallNumber x = if x > 100
    then x
    else x * 2

{- 関数名の最後のアポストロフィ（'）に注目。
    アポストロフィは特別な意味を持たない、関数名の一部として有効な文字。
    慣習的に ' は、正格（遅延じゃない）版の関数を表したり、少し変更したバージョンの関数に対して似た名前をつけるために利用される。
-}
doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1

-- ' は関数名として有効な文字なので次のような関数wお書くことができる。
-- 関数名の先頭は大文字不可。
-- また、この関数は引数を何も受け取らない。このときこれを「定義」とか「名前」と呼ぶ。
conanO'Brien = "It's a-me, Conan O'Brien!"

-----------------------
-- リスト入門
-----------------------

{-
 Haskell のリストは一様なデータ構造。同じ型の要素を複数個格納できるが、異なる型を格納することはできない。
 リストは要素をカンマ区切りで並べて、角括弧で括ったもの（他の言語と同じ）（リストの記法が違うのって Numpy （スペース区切り）くらい？）。
-}

lostNumbers = [4, 8, 15, 16, 23, 42]

{- ⭐️　連結
  リスト操作として最も一般的なのは連結操作。Haskell では ++ 演算子を用いる。
-}

concated = [1, 2, 3, 4] ++ [5, 6, 7, 8] -- concated = [1, 2, 3, 4, 5, 6, 7, 8] // `+` だとエラーになる
greet = "hello" ++ " " ++ "world" -- greet = "hello world"
word = ['l', 'o'] ++ ['v', 'e'] -- word = "love"
word' = ['l', 'o', 'v'] ++ "e" -- word' = "love" // 'e' はリストの外に置けない（ ++ 'e' とするとエラー）。
string = ["l", "o"] ++ ["v", "e"] -- string = ["l", "o", "v", "e"] // 一文字からなる文字列のリスト

-- Haskell では文字列は文字のリストとして表されている。たとえば、文字列 "hello" は実際にはリスト ['h', 'e', 'l', 'l', 'o'] と同じ。

{-
  長い文字列に対して繰り返し ++ を使うときは注意が必要。
  2 つのリストを連結するとき、Haskell は 1 つ目のリスト（++の左側）を最後まで走査するので、長いリストの最後に何かを追加するときには時間がかかる。
  しかし、リストの先頭に何かを追加するのはほとんど一瞬で終わる軽い操作。
  これには : 演算子（cons 演算子）を使う。
-}

neko = 'A': " SMALL CAT"
pi_ = 3: [1, 4, 1, 5]

{-
　文字: 文字のリスト、数:数のリスト、というように、:演算子の第一引数は「追加しようとしているリストの要素の型と同じ型の単一の要素」。
  これに対して、** 演算子は上で見たとおり必ず 2 つのリストを引数として受け取る。[1, 2, 3, 4] ++ [5] といった具合で、 [1, 2, 3, 4] ++ 5 とは書けない。
  Haskell では [1, 2, 3] は 1:2:3:[] の構文糖衣。
-}

{- ⭐️　リストの要素へのアクセス
　　!!演算子を使う。zero-based index
-}

moji = "Steve Buscemi" !! 6 -- 'B'
suuji = [9.4, 33.2, 96.2, 11.2, 23.25] !! 1 -- 33.2

{-
 　⭐️　リストの中のリスト
 　リストはリストを要素として含むことができて、リストはリストを含むリストを含むことができて……。
 　リストの中のリストは、それぞれ違う長さでも構わないが、違う型は許されない（例えば、文字のリストと数のリストを要素として持つリストは作れない）。
-}

list = [[1, 2, 3, 4], [5, 3, 3, 3],[1, 2, 2, 3, 4], [1, 2, 3]]
list' = list ++ [[1, 1, 1, 1]]
list'' = [6, 6, 6] : list
list_in_list = list !! 2 -- [1, 2, 2, 3, 4]


{-
　⭐️　リストの比較
　中の要素が比較可能であればリストも比較可能。<、<=、>=、>を使って 2 つのリストを比較すると、辞書順で比較される。
　まず 2 つのリストの先頭の要素が比較され、それらが等しければ 2 番目の要素どうしが比較される。
  2 番目の要素も等しければ 3 番目の要素が比較され、違う要素が見つかるまでこれが繰り返される。
-}

compare1 = [3, 2, 1] > [2, 1, 0] -- True
compare2 = [3, 2, 1] > [2, 10, 100] -- True
compare3 = [3, 4, 2] < [3, 4, 3] -- True
compare4 = [3, 4, 2] > [2, 4] -- True
compare5 = [3, 4, 2] == [3, 4, 2] -- True
compare6 = [0] > [] -- True
    -- 💡空でないリストはつねに空リストよりも大きいとみなされる。
    -- これにより、一方のリストが他方の先頭部分に一致するようなケースを含めて、2 つのリストの順序がすべてについて定義される。

{-
　🍺さらなるリスト操作
-}

-- head 関数：先頭の要素を返す
a = head [5, 4, 3, 2, 1] -- 5

-- tail 関数: 先頭を取り除いた残りのリストを返す
a' = tail [5, 4, 3, 2, 1] -- [4, 3, 2, 1]

-- last 関数：リストの最後の要素を返す
a'' = last [5, 4, 3, 2, 1] -- 1

-- init 関数: リストを受け取り、最後の要素を除いた残りのリウsとを返す
a''' = init [5, 4, 3, 2, 1] -- [5, 4, 3, 2]

-- head, tail, last, init を使うときは空リストを渡さないように注意すること。
-- このエラーはコンパイル時には捉えられない。

-- length 関数：リストを受け取り、その長さを返す。
len = length [5, 4, 3, 2, 1] -- 5

-- null 関数：リストが空かどうか調べる。空なら True を、そうでなければ False を返す。
c = null [1, 2, 3] -- False
c' = null [] -- True
c'' = null [[]] -- False
c''' = null "" -- True

-- reverse 関数:　リストを逆順にする
r = reverse [5, 4, 3, 2, 1] -- [1, 2, 3, 4, 5]

-- take 関数: 数とリストを取り、先頭から指定された数の要素を取り出したリストを返す
t = take 3 [5, 4, 3, 2, 1] -- [5, 4, 3]
t' = take 1 [3, 9, 3] -- [3]
t'' = take 5 [1, 2] -- [1, 2]
t''' = take 0 [6, 6, 6] -- []
t'''' = take 3 "haskell" -- "has"

-- drop 関数: 指定された数の要素を先頭から削除したリストを返す。
d = drop 3 [8, 4, 2, 1, 5, 6] -- [1, 5, 6]
d' = drop 0 [1, 2, 3, 4] -- [1, 2, 3, 4]
d'' = drop 100 [1, 2, 3, 4] -- []

-- maximum 関数：なんらかの順序が定義された要素からなるリストを受け取り、その中で最大の要素を返す。
-- minimum 関数：同様（最小の要素を返す）

max_in_list = maximum [1, 9, 2, 3, 4] -- 9
min_in_list = minimum [8, 4, 2, 1, 5, 6] -- 1

-- sum 関数: 数のリストを受け取り、それらの和を返す。
-- product 関数: 数のリストを受け取り、それらの積を返す。
sum_ = sum [5, 2, 1, 6, 3, 2, 5, 7] -- 31
pro_ = product [6, 2, 1, 2] -- 24
pro_' = product [1, 2, 5, 6, 7, 9, 2, 0] -- 0

-- elem 関数: 要素とリストを受け取り、それがリストの要素に含まれているかどうかを返す。
--            中置関数として使うと読みやすい。

e = 4 `elem` [3, 4, 5, 6]
e' = elem 20 [0, 1, 10, 20] -- 前置関数として使う場合
e'' = 10 `elem` [3, 4, 5, 6]

-----------------------
-- range　の使い方
---- range（レンジ）は、列挙できる要素（整数やアルファベット）の組み合わせでリストを作るのに使われる。 
-----------------------

oneToTwenty = [1..20] -- [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
aToz = ['a'..'z'] -- "abcdefghijklmnopqrstuvwxyz"
cap_ktoz = ['K'..'Z'] -- "KLMNOPQRSTUVWXYZ"

{-
 レンジにはステップを指定することもできる。最初の要素と 2 つめの要素をカンマで区切って、上限を指定する。
-}

oneToTwentyEven = [2, 4..20] -- [2,4,6,8,10,12,14,16,18,20]
threeToTwenty = [3, 6..20] -- [3,6,9,12,15,18]
aToz' = ['a', 'd'..'z'] -- "adgjmpsvy"

-- 注：この構文ではステップサイズを 1 つしか指定できない。
-- また、たとえば 20 から 1 までの現象列を作るためには [20..1] ではなく [20, 19..1] と書く必要がある。

{-
  上限を指定しないことで、レンジを使って無限リストを生成できる。
-}

-- 13 の倍数の最初の 24 個からなるリストを作る方法
-- その1
aa = [13, 13*2..13*24]

-- その2: こっちのほうがよい方法（Haskell は遅延評価なので無限リスト全体をすぐには評価しない）
aa' = take 24 [13, 13*2..]

{- すごく長い、もしくは無限の長さのリストを生成するために使える関数がいくつかある。 -}

-- cycle: リストを受け取り、その要素を無限に繰り返し、無限リストを生成する。

foo = take 10 (cycle [1, 2, 3]) -- [1,2,3,1,2,3,1,2,3,1]
foo' = take 12 (cycle "LOL ") -- "LOL LOL LOL "

-- repeat: 1 つの要素を受け取り、その要素のみが無限に繰り返される無限リストを作る。長さ 1 のリストを cycle にかけるのと同じ。
foo'' = take 10 (repeat 5) -- [5,5,5,5,5,5,5,5,5,5]

-- replicate: 単一の値からなるリストを作る簡単な方法。リストの長さと、複製する要素を与える。
foo''' = replicate 3 10 -- [10,10,10]

-- | レンジに関する注意。
-- | 浮動小数点数を使うときは気を付けること。浮動少数は精度に限りがあるので、レンジで使うとおかしな振る舞いをすることがある。
double_ = [0.1, 0.3..1] -- [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]

-----------------------
-- 🌈リスト内包表記
-----------------------

{-

リスト内包表記はリストのフィルタリング、変換、組み合わせを行う方法。
これは数学における **集合の内包的記法** の概念に近いもの。
集合の内包的表記は、他の集合から別の集合を作るときによく用いられ、単純な例としては {2・x | x ∈ N, x ≦ 10} のようなものがある。
この例は、「10 以下のすべての自然数を取ってきて、それぞれ 2 倍して、その結果を新しい集合としなさい」と言っている。

同じことを Haskell でやりたい場合、`take 10 [2, 4..]` のようにリスト操作で書けるが、リスト内包表記を使って書くこともできる。

-}

doubledUnder10 = [x*2 | x <- [1..10]] -- Python だと [x*2 for x in range(1, 11)]
  -- x <- [1..10] は [1..10] から取り出した各要素の値を x が受け取るという意味。
  -- これは別の表現では [1..10] の各要素を x に **束縛** していると言える。
  -- 縦棒より前の部分は、リスト内包表記の出力を表す。この出力パートは、取り出した値を使ってどんなリストを作りたいかを指定する。

{-
🌀リスト内包表記への条件（述語）の追加🌀
述語はリスト内包表記の最後に置き、他のパートとはカンマで区切る。
-}

-- 2 倍した値が 12 以上のものからなるリスト
doubled_over12 = [x*2 | x <- [1..10], x*2 >= 12] -- [12,14,16,18,20] // Python だと [x*2 for x in range(1, 11) if x*2 >= 12]

-- 50 から 100 の数のうち、7 で割った余りが 3 であるすべての数
モ = [x | x <- [50..100], x `mod` 7 == 3] -- [52,59,66,73,80,87,94]

-- >> 述語を使ってリストを間引くことを _フィルタする_ という。

-- 10 以上のすべての奇数を "BANG!" に置き換え、10 より小さいすべての奇数を "BOOM!" に置き換える内包表記
--     数が奇数でなければリストから削除する。再利用のことを考えて、内包表記を関数の中に記述することにする。
boomBangs xs = [if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
    -- odd 関数は、奇数が与えられたら True を、そうでなければ False を返す。すべての述語が True に評価された要素だけがリストに含まれる。
    {- Python の場合は。。
    >>> def boom_bang(xs):
    ...     return ["BOOM!" if x < 10 else "BANG!" for x in xs if x % 2 == 1]
    -}

-- カンマで区切ることで、複数の述語を含めることができる。
listof_10から20の中で13_15_19でないすべての数 = [x | x <- [10..20], x /= 13, x /= 15, x /= 19] -- [10,11,12,14,16,17,18,20]

{-
🍖述語を複数書くだけでなく、複数のリストから値を取り出すこともできる。
-}

aaa = [x + y | x <- [1, 2, 3], y <- [10, 100, 1000]] -- [11,101,1001,12,102,1002,13,103,1003]

-- 2 つのリストの要素のすべての組み合わせの積　かつ　50より大きいものだけ
hoho = [x*y | x <- [2, 5, 10], y <- [8, 10, 11], x*y > 50] -- [55,80,100,110]

nouns = ["hobo", "frog", "pope"]
adjectives = ["lazy", "grouchy", "scheming"]
originalWords = [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns] -- ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog","grouchy pope","scheming hobo","scheming frog","scheming pope"]

-- リスト内包表記を使って length 関数を独自に定義することもできる。
length' xs = sum [1 | _ <- xs]
  -- リストのすべての要素を 1 に置換してから sum で足し合わせてリストの長さを得る
  -- この例ではリストから取り出した値を利用しないので、それを使い捨てるために変数名にアンダースコアを使っている。

{- 文字列もリストなので、文字列を処理して生成するのにもリスト内包表記が使える。-}

-- 文字列を受け取り、すべての小文字を取り除く（大文字だけを残す）関数
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]

{-
🐶リストを含むリストを操作する場合には、 _入れ子になったリスト内包表記_ が作れる。
数のリストからなるリストを受け取り、各要素はリストのままに、そこから奇数だけを取り除くという操作を考えよう。
-}

xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
-- ❌onlyEven = [x | x <- [xs | xs <- xxs], even x] ❌自分の間違った回答
onlyEven = [[x | x <- xs, even x] | xs <- xxs] -- 結果は [[2,2,4], [2,4,6,8], [2,4,2,6,2,6]] となる。つまり、出力がリストのリストになるから [[] | 述語] という形になることはわかるはず。

-----------------------
-- タプル入門
-----------------------

{-
タプルは、複数の違う型の要素を格納して、1 つの値にするために使う。

リストとタプルの根本的な違い：
 - 1 つ目の違いは、「タプルはヘテロである」ということ、つまり複数の違う型の要素が格納できるということ。
 - 2 つ目の違いは、タプルはサイズが固定（固定長）だということ。格納する要素がいくつなのか事前に知っている必要がある。

タプルは括弧で囲み、要素をカンマで区切る。
例: (1, 3), (3, 'a', "hello"), (50, 50.4, "hello", 'b')
-}

------ タプルを使う

{-
 例）2次元ヴェクタを表したいとき
 　リストを使うと：[[1,2], [8,11,5], [4,5]] というようなものが作れてしまう（このリストはベクトルのリストとしては意味をなさないが、型（数のリストのリスト）が同じであるため）
 　タプルを使うと：[(1, 2), (8, 11, 5), (4, 5)] とすると🛑エラー！
 　　　　　　　　　サイズ 2 のタプル（ペア）とサイズ 3 のタプル（トリプル）はそれぞれ違う型として扱われるため、ペアとトリプル両方を含むリストは作れない。
-}

{-
また、Haskell は長さが同じで違う型を含むタプルを区別できる。例えば、[(1, 2), ("One", 2)] のようなタプルのリストは作れない。
上述のとおりタプルは固定長だがつまりサイズも型の一部だということ。
リストと同様に、構成要素が比較可能であればそれを含むタプルも違いに比較できる。
しかしリストとは違い、サイズの違うタプルを比較することはできない。
-}

------ ペアを使う

-- fst: ペアを受け取り、1 つ目の要素を返す。
fa = fst (8, 11)
fa' = fst ("Wow", False)

-- snd: ペアを受け取り、2 つ目の要素を返す
se = snd (8, 11)
se' = snd ("Wow", False)

-- zip 関数：ペアのリストを作るスマートな方法。2 つのリストを受け取り、ジッパーのごとく 1 つのリストにする。
--          2 つのリストを同時に走査するときに便利。

zi = zip [1, 2, 3, 4, 5] [5, 5, 5, 5, 5] -- [(1,5),(2,5),(3,5),(4,5),(5,5)]
zi' = zip [1..5] ["one", "two", "three", "four", "five"]

-- リストの長さが違う場合は、長いほうのリストは必要なぶんだけ使われ、余りは無視される。
zi'' = zip [5, 3, 2, 6, 2, 7, 2, 5, 4, 6, 6] ["im", "a", "turtle"] -- [(5,"im"),(3,"a"),(2,"turtle")]

-- 遅延評価であるから、有限リストと無限リストを zip することもできる。
zi_ = zip [1..] ["apple", "orange", "cherry", "mango"] -- [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]

{-
　📐直角三角形を見つける
　　👉次のすべての条件を満たす直角三角形を見つけるプログラムを書く。
　　　✅　3 辺の長さはすべて整数
　　　✅　各辺の長さは 10 以下
　　　✅　周囲の長さは 24 に等しい
-}

-- 斜辺を c として、 a > b とする。
rightTriangles = [(a, b, c) | c <- [1..10], a <- [1..c], b <- [1..a], a+b+c==24, a^2+b^2==c^2]
    -- 手順としては、まず triples = [(a, b, c) | c <- [1..10], a <- [1..10], b <- [1..10]] という素朴なところからスタートして、
    -- 与えられた条件やピタゴラスの定理などからどんな述語を追加すればよいか考えていけば良い。
    -- 最初に解の候補となる集合を生成し、それから正しい解にたどり着くまで変換とフィルタリングを行うという手法は関数プログラミングでよく用いられるパターンである。