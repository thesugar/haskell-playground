{-# OPTIONS -Wall -Werror #-}

---_/_/_/_/_/_/_/_/_/_/_/_/---
--      　高階関数　　       --
---_/_/_/_/_/_/_/_/_/_/_/_/---

{-  Haskell の関数は、引数として関数を取ったり返り値として関数を返したりできる。
    このような関数は高階関数と呼ばれる。    -}

-------------------------------
-- カリー化関数（Curried functions）
-------------------------------

{-
　🍛　Haskell のすべての関数は、公式には引数を 1 つだけ取ることになっている。
    　しかし、これまでの章で複数の引数を取る関数を定義してきた。どうなっているのか？

　🍛　複数の引数を受け取れるかのように見えた関数は、すべて **カリー化** された関数だったのである。
    　カリー化関数は、複数の引数を取るかわりに、つねにちょうど 1 つの引数を取る関数。
    　カリー化関数が呼び出されると、その次の引数を受け取る関数を返す。この繰り返しである。
-}

--- 例. max 関数
{- 
    max 関数は、一見すると 2 つの引数をもらって大きい方を返す関数のように見える。
    例えば、 max 4 5 という式。これは関数 max を 2 つの引数 4 と 5 で呼び出している。
    最初に、max が値 4 に適用される。max が 4 に適用されると、その実際の返り値は、5 に適用するための別の関数である。
    この関数が 5 に適用されて最終的な数値が返る。
    
    結果として、次の 2 つの呼び出しは等価になる。

        max 4 5 // 5
        (max 4) 5 // 5

    max 関数の型をあらためて調べてみると以下のとおり。
        max :: Ord a => a -> a -> a
    
    これは次のようにも書ける。
        max :: Ord a => a -> (a -> a)

    矢印 -> を型シグネチャに含むものはすべて関数である。
    つまり、矢印の左にあるものを引数にとり、右側にあるものを型とする値を返す。
    a -> (a -> a) は、a 型の値を引数に取る関数であり、「a 型の値を引数に取り a 型の値を返す関数」を返すのだとわかる。
-}

{-
　💃　それで、なにがうれしいのか？
    👉 関数を本来より少ない火kしううで呼び出したときに、**部分適用** された（partially applied）関数が得られること。
    　　この「部分適用された関数」は、残りの変数を引数として取る関数。
    　　たとえば、max 4 としたとする。これは 1 引数の関数を返す。
    　　部分適用（関数を本来より少ない引数で呼び出すこと）を使うと、関数をその場で手軽に作り出して、それを他の関数に渡せる。
-}

--- 次の小さい単純な関数を見てみよう。
multThree :: Int -> Int -> Int -> Int
multThree x y z = x * y * z

{-
    multThree 3 5 9 あるいは (((multThree 3) 5) 9) を呼び出すと実際には何が起こるだろうか？
    最初に、multThree が 3 に適用される。これにより「引数を 1 つ取って関数を返す関数（ここで、これを関数 fa と呼ぶとする）」が返る。
    そうしたら、その関数 fa が 5 に適用される。これにより「引数を 1 つ取ってそれに 3 と 5 をかけた値を返す関数（これを fb とする）」が返る。
    その関数 fb が 9 に適応され、 135 が最終的な結果になる。

    関数は、なにか材料を受け取って何かを作り出す小さな向上だと考えることができる。
    この比喩を使うと、「multThree に数 3 を与えたら、数ではなくて、ちょっと小さくなった別の工場が出てきた」と言える。
    そのちょっと小さな工場は、数 5 を受け取り、また別の工場を作り出す。
    3 つ目の工場は数 9 を受け取り、最終結果である数 135 を作り出す。

    この関数の型は次のようにも書けることを思い出そう。
        multThree :: Int -> (Int -> (Int -> Int))
    -> の前にある型（あるいは型変数）は関数が受け取る値の型で、後ろにあるのは返り値の型。
    なので、この関数は Int 型の値を受け取り、(Int -> (Int -> Int)) という型を持つ関数（fa）を返す。
    同様に、この関数（fa）は Int 型の値を受け取り、 Int -> Int という型の関数（fb）を返す。
    最後に、この関数（fb）は Int 型の値を受け取り、Int 型の値を返す。
-}

-- 本来より少ない引数で関数を呼び出すことによって新しい関数を作る例を見ていこう。

multTwoWithNine :: Int -> Int -> Int
multTwoWithNine = multThree 9 -- ここ。multThree は本来 multThree 3 5 9 のように 3 引数で呼び出すもの。

result1 :: Int
result1 = multTwoWithNine 2 3

-- Int を引数に取って 100 と比較する関数を作りたいときはどうすればよいだろうか？

compareWithHundred :: Int -> Ordering
compareWithHundred x = compare 100 x
    -- 👉compare 100 は「数を引数に取り、100 と比較する関数」を返す。
-- つまり、次の定義は前の定義と等価。

compareWithHundred' :: Int -> Ordering -- 型宣言は同じまま。
compareWithHundred' = compare 100 -- compare :: Ord a => a -> (a -> Ordering) である。これを 100 に適用すると「数を引数に取り Ordering を返す関数」が得られる。


------------ セクション ----------------

{-
    中置関数に対しても、**セクション** という機能を使って部分適用することができる。
    まず、中置関数をセクションするには、片側だけに値を置いて括弧で囲むだけである。
    これで引数を 1 つ、値を置かなかった側に取る関数ができる。
-}

dividedByTen :: (Floating a) => a -> a
dividedByTen = (/ 10) -- `/` が中置関数であって、dividedByTen は普通の関数（dividedByTen 200 のように使用する）。

-- もうひとつの例。与えられた文字が大文字かどうかを調べる
isCap :: Char -> Bool
isCap = (`elem` ['A'..'Z'])

-- 💡セクションで気をつけないといけないこと。
{-
 ✋ - (負の数、マイナス）演算子と同時に使うとき。
    (-4) は、セクションの定義から考えると、数を受け取ってそれから 4 を引く関数になる。
    しかし (-4) は利便性のために、マイナス 4 を意味することになっている。
    なので、引数から 4 を引き算する関数を作りたいときには、 subtract 関数を (subtract 4) のように部分適用する。
-}

------------ 関数を表示する ----------------
{-
    今までのところ、部分適用した関数は何かしらの名前に束縛して、それから残りの引数を与えていた。
    しかし、関数そのものをターミナルに表示したことはない。
    名前をつけたり、別の関数に渡したりせずに、multiThree 4 3 を GHCi に打ち込むと何が起こるのだろうか？
        ghci > multThree 3 4
        <interactive>:62:1: error:
            • No instance for (Show (Int -> Int)) arising from a use of ‘print’
                (maybe you haven't applied a function to enough arguments?)
            • In a stmt of an interactive GHCi command: print it

    GHCi は、この式が Int -> Int の型の関数を生成したけど、それをどうやって画面に表示したらいいかわからないと言っている。
    関数は Show 型クラスのインスタンスではないので、いい感じに関数を表示する文字列が得られないのである。

    これは、たとえば 1 + 1 のような式を入力した場合とは異なる。
    この場合 GHCi は、式の結果として 2 を計算し、それから 2 に対して show を呼んで、数のテキスト表現（文字列 "2"）を得る。
-}

-------------------------------
-- 高階実演
-------------------------------

-- 関数を受け取り、それを 2 回適用する関数を書いてみよう

applyTwice :: (a -> a) -> a -> a 
applyTwice f x = f (f x)

{-
    📣 型宣言に気を付けること
    `->` は右結合なのでこれまでの例では関数の肩を宣言するときに括弧は必要なかったが、ここでの括弧は必須。
    これは、関数の最初の引数が「1 つ引数を取り、同じ型の値を返す関数（a -> a）」だということを示している。
    2 つ目の引数は何か a 型の値で、返り値も a 型である。
    a はなんの型でも（Int でも String でも他の型でも）いいが、すべての a は同じ型である必要があることに注意（`f f x` から、f の引数の型は f の返り値の型と一致する必要がある）
-}

{-
    🌀 applyTwice の使用例
        applyTwice (+3) 10 // 16
        applyTwice (++ " HAHA") "HEY" // "HEY HAHA HAHA"
        applyTwice ("HAHA " ++) "HEY" // "HAHA HAHA HEY"
        applyTwice (multThree 2 2) 9 // 144
        applyTwice (3:) [1] // [3,3,1]

    🌀　部分適用のすごさと実用性がわかる。1 引数の関数を渡す必要があるのなら、部分適用を使って 1 引数の関数を作り、それに渡せばいいのである。
        たとえば、+ は 2 つの引数を受け取るが、この例では、セクションを使った部分適用で 1 つだけ引数を与えている。
-}

---- ¶ zipWith を実装する

{-
    zipWith は関数と 2 つのリストを引数に取り、2 つのリストの各要素にその関数を適用することで、 2 つのリストを 1 つに結合するもの。
-}

{-  ❌　自分の回答。ダメ（zipWith' (+) [1, 2, 3] [10, 10, 10] とすると [11, 11, 11, 12, 12, 12, 13, 13, 13] となる（expected: [11, 12, 13]））
    zipWith' :: (a -> a -> b) -> [a] -> [a] -> [b]
    zipWith' f xs ys = [(f x y) | x <- xs, y <- ys]
-}

zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] -- 型宣言がよくわからなくなったら省略して書き、Haskell に推論してもらえばよい。
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

{-
    🍦zipWith' の使い道
    zipWith' (+) [4, 2, 5, 6] [2, 6, 2, 3] // [6,8,7.9]
    zipWith' max [6, 3, 2, 1] [7, 3, 1, 5] // [7,3,2,5]
    zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"] // ["foo fighters","bar hoppers","baz aldrin"]
    zipWith' (*) (replicate 5 2) [1..] // [2,4,6,8,10]
    zipWith' (zipWith' (*)) [[1, 2, 3], [3, 5, 6], [2, 3, 4]] [[3, 2, 2], [3, 4, 5], [5, 4, 3]] // [[3,4,6],[9,20,30],[10,12,12]]
                -- それぞれ対応する要素の積になる（[[1*3, 2*2, 3*2],[3*3, 5*4, 6*5], [2*5, 3*4, 4*3]
-}

---- ¶ flip を実装する

{-
    flip 関数は、関数を引数に取り、元の関数と似ているけれど最初の 2 つの引数が入れ替わった関数を返す。
-}
flip':: (a -> b -> c) -> b -> a -> c
flip' f x y = f y x

{-
    zip [1, 2, 3, 4, 5] "hello" // [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
    flip' zip [1, 2, 3, 4, 5] "hello" // [('h',1),('e',2),('l',3),('l',4),('o',5)]
    zipWith div [2, 2..] [10, 8, 6, 4, 2] // [0,0,0,0,1]
    zipWith (flip' div) [2,2..] [10, 8, 6, 4, 2] // [5,4,3,2,1]
-}

-------------------------------
-- 関数プログラマの道具箱
-------------------------------

---- ¶ map 関数
---- 関数とリストを受け取り、その関数をリストのすべての要素に適用して新しいリストを生成する。

map':: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = f x: map' f xs

{-
 🗾 使い方の例
    map (+3) [1, 5, 3, 1, 6] // [4,8,6,4,9]
    map (++ "!") ["BIFF", "BANG", "POW"] // ["BIFF!","BANG!","POW!"]
    map (replicate 3) [3..6] // [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
    map (map (^2)) [[1,2], [3,4,5,6], [7,8]] // [[1,4],[9,16,25,36],[49,64]]
    map fst [(1,2), (3,5), (6,3), (2,6), (2,5)] // [1,3,6,2,2]

    リスト内包表記を使っても同じことができるが、map 関数をつかうほうが読みやすくなる。
-}

---- ¶ filter 関数
----   述語とリストを受け取り、そのリストの要素のうち、述語を満たすもののみからなるリストを返す（述語とは、何が true で何が false かを言う関数、つまり真理値を返す関数）。

filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' s (x:xs)
    | s x = x : filter' s xs
    | otherwise = filter' s xs

{-
👀 filter の例 
    filter (>3) [1, 2, 3, 4, 5] // [4,5]
    filter (==3) [1, 2, 3, 4, 5] // [3]
    filter even [1..10] // [2,4,6,8,10]
    let notNull x = not (null x) in filter notNull [[1,2,3], [], [3,4,5], [2,2],[],[],[]] // [[1,2,3],[3,4,5],[2,2]]
    filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent" // "uagameasadifeent"
    filter (`elem` ['A'..'Z']) "i LAuGh at you bEcause u R all the same" // "LAGER"

    これもリスト内包表記と述語を使って同じことができる。
    どんなときにリスト内包表記を使って、どんなときに map や filter を使うかというルールはない。
    その時々で読みやすいほうを採用すること。
-}

{-
    リスト内包表記で複数の述語を指定するようなケースを filter で書くときは、filter を何度か適用するか、述語を論理関数 && でつないで指定する。
-}

result2 :: [Int]
result2 = filter (<15) (filter even [1..20]) -- [2,4,6,8,10,12,14]

-- リスト内包表記でも書ける
result2' :: [Int]
result2' = [x | x <- [1..20], x < 15, even x]

{-
    quicksort 関数
-}

-- 前の章では以下のように実装した
quicksort:: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerOrEqual = [a | a <- xs, a <= x]
        larger = [a | a <- xs, a > x]
    in quicksort smallerOrEqual ++ [x] ++ quicksort larger

-- これを filter 使えば以下のように書ける。
quicksort' :: (Ord a) => [a] -> [a]
quicksort' [] = []
quicksort' (x:xs)
    =   let smallerOrEqual = filter (<= x) xs
            larger = filter (> x) xs
        in  quicksort' smallerOrEqual ++ [x] ++ quicksort' larger

------- map と filter のさらなる例 --------

-- 👀　10 万以下の数のうち 3829 で割り切れる最大の数を探してみよう。
largestDivisible :: Int
largestDivisible = head (filter p [100000, 99999..])
    where p x = x `mod` 3829 == 0
        -- 答え：99554

{- 
    はじめに、100000 より小さいすべての数からなる降順のリストを作る。
    それから、それを述語でフィルタする。
    数のリストは呼応順にソートされているので、条件を満たす最大の数は、フィルタされたリストの先頭の要素として現れる。
    それゆえ、フィルtされたリストの head を取る。
    残りのリストが有限か無限かはどうでもいい話。
    Haskell は怠惰なので最初の条件に合う解が見つかれば評価は停止する。
-}

-- 👀 次の例. 10000　より小さいすべての奇数の平方数の和を求めよ。（「10000 より小さい奇数」の平方数の和ではなく、「10000 より小さい「奇数の平方数」」の和）
{-
    これには takeWhile という関数を使う。
    この関数は述語とリストを受け取り、リストの先頭から始めて述語の条件が満たされるかぎりリストの要素を返し続ける。
    条件に合わない要素が見つかったらリストを返すのをやめる。
    たとえば、文字列の最初の単語を以下のように取得できる。
        takeWhile (/= ' ') "elephants know how to party" // "elephants"
-}

sumOfOddSquare :: Int
sumOfOddSquare = sum (takeWhile (<10000) (filter odd (map (^ (2 :: Int)) [1..]))) -- //166650
                                                            -- ここは、{-# OPTIONS -Wall -Werror #-} のオプションつけてると単純に ^2 とするとエラーが出る。参考：https://teratail.com/questions/10377

--- 同じものをリスト内包で書くと。。
sumOfOddSquare' :: Int
sumOfOddSquare' = sum (takeWhile (<10000) [m | m <- [n^(2 :: Int) | n <- [1..]], odd m])

---- 上記のどちらの書き方でもそうだけど、takeWhile を使わずにたとえばフィルタリングするための条件（述語）として (二乗した値) < 10000 てな具合でやっちゃうと
---- n <- [1..10000] の二乗和をまずぜんぶとりあえず計算してからその全部に対して 10000 より小さいかの比較をしていくかたちになるので相当計算が重くなる


-- 👀 次の例.　コラッツ列

{-
    コラッツの数列は次のように定義される
        - 任意の自然数から開始する
        - 数が 1 ならば終了
        - 数が偶数なら、2 で割る
        - 数が奇数なら、3 倍して 1 を足す
        - 新しい値でこのアルゴリズムを繰り返す

    この定義に従うと、ある数の列ができる。この列は最初の数がなんであっても最終的には 1 に到達すると予想されている。
    たとえば 13 から始めると
        13, 40, 20, 10, 5, 16, 8, 4, 2, 1
    という列が得られる。13 から始めたコラッツ列の長さは 10 であるとわかる。

    解きたい問題はこれ：「1 から 100 までの数のうち、長さが 15 より大きいのコラッツ列の開始数になるものはいくつあるか？」
-}

-- 🌸最初のステップは数列を生成する関数を書くこと
chain :: Integer -> [Integer]
chain 1 = [1]
chain n
    | even n = n : chain (n `div` 2) -- (n / 2) だと型が Int(eger) にならないのでエラーになる
    | otherwise  = n : chain (n*3+1) -- | odd n = としてもいいけど、そうすると incomplete-patterns エラーが出てしまうので。

-- 🌸それでは実際に問題に答える関数を書こう
numLongChains :: Int
numLongChains = length (filter (> 15) (map length (map chain [1..100])))

{- 上記でOK。テキストの模範解答は以下。 -}
numLongChains' :: Int
numLongChains' = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs > 15

{-
　🍃 map 関数に複数の引数を与える
    いままで map するのに使っていた関数は、1 引数のみを取る関数だけだった。（map (*2) [0..] のような）。
    しかし、複数の引数を取る関数で map することも可能である。たとえば map (*) [1..] のようなことができる。
    この場合、関数 * は型 (Num a) => a -> a -> a を持ち、これがリストの各要素に適用される。

    すでに見たように、2 引数の関数に 1 引数だけを与えたら、1 引数を取る関数が返されるのだった。
    ゆえに、[0..] を * で map したら、1 引数関数のリストが得られる。
-}

-- 例.
listOfFuns :: (Num a, Enum a) => [a -> a]
listOfFuns = map (*) [0..]

-- たとえば、(listOfFuns !! 4) 5 とすると。。
-- 関数のリストの 4 番目（0-based）の要素を取り出すと、(4*) と等価な関数が得られる。これを 5 に適用すると (4*) 5、つまり 4*5 と等しいものになる。
-- 他にも、take 5 [f 10 | f <- listOfFuns] とすると [0, 10, 20, 30, 40] という結果になる。

-------------------------------
-- ラムダ式
-------------------------------

{-
    ラムダ式とは、1 回だけ必要な関数を作るときに使う無名関数のこと。
    通常、ラムダ式は高階関数にわたす　関数を作るためだけに使われる。
    ラムダ式を宣言するためには、バックスラッシュ（\）を書いて、それから関数の引数をスペース区切りで書く。
    続けて ->、最後に関数の本体を書く。
    バックスラッシュ（\）はギリシャ文字の λ に見えないこともないというので使われているようだ。
-}

-- numLongChains' では、filter に渡すだけの関数 isLong を定義するのに where 束縛を使っていたが、これをラムダ式を使って書き換えると以下のようになる。

numLongChains'' :: Int
numLongChains'' = length (filter (\xs -> length xs > 15) (map chain [1..100]))

{-
    ラムダ式は式なので、このように関数に直接渡すことができる。式 (\xs -> length xs > 15) は、受け取ったリストの長さが 15 よりも大きいかどうかを返す関数を返す。

    カリー化と部分適用の動作がよくわかっていないと、不必要にラムダ式を使ってしまいがち。たとえば次の式は等価。
-}

-- 以下の 2 式（foo, foo'）は等価。
foo:: [Int]
foo = map (+3) [1, 6, 3, 2] -- こちらの部分適用を使った書き方のほうが可読性が高い。 // [4,9,6,5]

foo':: [Int]
foo' = map (\x -> x + 3) [1, 6, 3, 2] -- // [4,9,6,5]

-- 普通の関数と同様に、ラムダ式も任意の数の引数を取ることができる。 --
bar :: [Double]
bar = zipWith (\a b -> (a * 30 + 3) / b) [5, 4, 3, 2, 1] [1, 2, 3, 4, 5] -- // [153.0,61.5,31.0,15.75,6.6]

-- 普通の関数と同様に、ラムダ式もパターンマッチができる。
-- 唯一異なるのは、1 つの引数に対して複数のパターンを定義できないところ（同じ引数に対して [] と [x:xs] のパターンを作って合致するほうを選択するといったもの）
baz :: [Int]
baz = map (\ (a, b) -> a + b) [(1, 2), (3, 5), (6, 3), (2, 6), (2, 5)] -- // [3,8,9,8,7]

{- もう 1 つ興味深い例を。 -}

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

addThree' :: Int -> Int -> Int -> Int
addThree' = (\x -> (\y -> (\z -> x + y + z))) -- addThree' \x -> \y -> \z -> x + y + z と書いても同じ（ラムダ式を括弧無しで書くと、-> の右側のすべてがラムダ式に属する）。

    -- 関数はデフォルトでカリー化されているので、これらの 2 つの関数は等価。
    -- しかし addThree のほうが圧倒的に読みやすい。2 爪の実装は、カリー化を説明するための小道具程度にしかならない。

{- カリー化の記法のほうが便利な場合もある -}

myflip :: (a -> b -> c) -> b -> a -> c
-- myflip f x y = f y x // ラムダ式を使わないとこの書き方
myflip f = \x y -> f y x
    -- ラムダ式を使うこの書き方のほうが、新しい関数を生成するという flip の典型的な使い方をよく表している。

{- flip で一番多い使い方は、引数として関数のみ、もしくは関数と引数を 1 つだけ渡し、生成された関数を map や zipWith に渡すという方法である。 -}
message :: [String]
message = zipWith (flip (++)) ["love you", "love me"] ["i ", "you "] -- ["i love you","you love me"]

calcResult :: [Int]
calcResult = map (flip subtract 20) [1, 2, 3, 4] -- [19,18,17,16]
            -- map (flip (subtract 20)) [1, 2, 3, 4] とするとエラーになる。subtract 20 は引数を 1 つ取（って 20 を引いた値を返却す）る関数だが flip は 2 引数を取る関数を引数に取るため。

{- 自分（flip）が関数を定義するときもうまくラムダ式を使えば、その関数は部分適用され引数として別の関数に渡されるものなのだ、という意図を明確にできる。-}

---------------------------------------------------------------------------------------------
-- 畳み込み、見込みあり！（英題：Only folds and horses（"Only Fools and Horses" というイギリスのコメディから）
---------------------------------------------------------------------------------------------

{-
    リストに対する再帰関数の多くは、ある共通のパターンに従っていた。
    それは「基底部は空リストとし、 x:xs パターンを使ってリストを先頭要素と残りの要素に分解する」というパターンであった。
    このパターンはとても頻繁に出てくるので、Haskell には畳み込み（fold）と呼ばれる便利な関数たちが用意されている。

    畳み込みを使うと、データ構造（例えばリスト）を単一の値にまとめることができる。

    畳み込みを使えば、リストを 1 要素ずつ一回だけ走査してそれに基づいた結果を返すような関数ならなんでも実装できる。

    畳み込み関数は、**2 引数関数**（2 つの引数を取る関数。+ や div など）と、畳み込みに用いる値（**アキュムレータ**と呼ばれることが多い）の初期値、それに畳み込むリストを受け取る。

    リストは右からでも左からでも畳み込める。
    畳み込み関数は、アキュムレータとリストの先頭（あるいは最後）の要素を引数として、与えられた 2 引数関数を呼び出す。
    その結果の値が新しいアキュムレータになる。
    それから畳み込み関数は、新しいアキュムレータと新しく先頭（あるいは最後）になった要素を引数として再び 2 引数関数を呼び出し、また新しいアキュムレータを作る。
    これを、リスト全体を走査しきって単一のアキュムレータの値になるまで繰り返す。
-}

-- ¶ foldl で左畳み込み
{-- 最初に、foldl 関数を見てみよう。foldl が「2 引数関数」「アキュムレータ」「畳み込み対象のリスト」の 3 つを引数に取ることを型が教えてくれる。
        foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
    
    これはリストを左側から順に畳み込んでいくので、左畳み込み（left fold）と呼ばれる。
    左畳み込みでは、最初のアキュムレータとリストの先頭要素に 2 引数関数が適用される。
    これが新しいアキュムレータを生成し、リストの次の要素と一緒に 2 引数関数が呼び出され、それが繰り返される。

    では、あからさまな再帰を使わずに、畳み込みを使って sum 関数を実装し直してみよう。 -}

sum' :: Num a => [a] -> a
sum' = foldl (+) 0
    -- 畳み込みの練習のために、やや冗長な書き方をすると以下のようになる。
        -- sum' xs = foldl (\acc x -> acc + x) 0 xs

-- ¶ foldr で右畳み込み
{-- 右畳み込み関数 foldr は、リストを右から順に処理する点を除いて（* リストは右からは走査できない！ foldr はあくまでリストを左から走査するが、結果だけみると右から折り畳んだように見えるということ。）左畳み込みに似ている。
    また、右畳み込みに使う 2 引数関数では引数の順番が逆になっている。
    1 つ目の引数にリストの値、2 つ目にアキュムレータを渡す（これは直感的には、リストを右から畳み込むのでアキュムレータが右に位置するイメージ）。

    2 つを比べてみよう。
        foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
        foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

    畳み込みのアキュムレータの値（もしくは結果の値）は任意の型でかまわない。数でも真理値でも、はたまた新しいリストでも。
-}

-- 例えば、右畳み込みで map 関数を実装してみよう。アキュムレータはリストである。（※ 再帰を使った map の実装は本ファイルの上部にある）
myMap :: Foldable t1 => (t2 -> a) -> t1 t2 -> [a] -- (a -> b) -> [a] -> [b] でもよい
myMap f xs = foldr (\x acc -> f x : acc) [] xs
    {-
        [1,2,3] の各要素に (+3) を適用するときには、リストを右から走査する。
        最後の要素である 3 を取り、それに関数を適用して 6 を得る。それをアキュムレータである [] の先頭に追加する。
        6: [] は [6] なので、これが次のアキュムレータになる。
        次に、2 に (+3) を適用して 5 が得られ、アキュムレータの先頭に追加（:）する。
        新しいアキュムレータの値は [5, 6] になる。
        それから 1 に (+3)　を適用してアキュムレータの先頭に追加し、最終的な結果として　[4, 5, 6] を得る。
    -}

-- 左畳み込みを使って以下のように実装することも可能。
myMap' :: (a -> b) -> [a] -> [b]
myMap' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
    ---- しかし、** ++ 関数は : よりもはるかに遅い** ので、リストから新しいリストを構築する際には普通は右畳み込みを使う。

{-
    右畳み込みと左畳み込みのもう 1 つの大きな違いは、右は無限リストに対しても動作するのに対し、左はダメだということ。
-}

-- 右畳み込みによる実装の他の例.
-- elem: 値がリストに含まれるかどうかを調べる関数

--myElem
myElem :: Eq a => a -> [a] -> Bool
myElem y ys = foldr (\x acc -> if x == y then True else acc) False ys
    -- この場合のアキュムレータは真理値（畳み込みにおけるアキュムレータの型は結果の型と同じであることを思い出そう）。
    -- 最初はリストに値がないものと考えるので、初期値は False になる。こうすれば空のリストに対しても正しい結果になる。
    -- 空のリストに対する畳み込みは単に初期値が返るからである。
    -- 次に、現在の値が欲しい値なのか調べる。もしそうなら、アキュムレータを True にセットする。
    -- そうでなければ、アキュムレータを変更せずにそのまま返す。
    -- アキュムレータが False だったら、現在の要素はッサガしているものではないからそのまま False にすべきだし、
    -- True だったなら、それまで走査した部分にあったということなのでそのまま True にすべきだからである。
    -- （True が一度見つかったらその時点で走査するのやめて True を返却すべきと思うが。。。）


-- ¶ foldl1 と foldr1 関数
{-
    foldl1 関数と foldr1 関数はそれぞれ foldl と foldr に似ているが、初期アキュムレータを明示的に与える必要がない。
    そのかわり、リストの先頭（あるいは末尾）要素を初期アキュムレータとして使い、そこから畳み込みを始める。
    これを使えば maximum 関数を次のように実装できる。
-}

maximum' :: Ord a => [a] -> a
-- maximum' = foldl1 (\x y -> if x > y then x else y) // 自分の回答。これでもいいけど、、
maximum' = foldl1 max -- これが簡潔

    {-
        初期アキュムレータは与えず、foldl1 がリストの最初の要素を初期アキュムレータとみなし、2 番目の要素から畳み込まれていく。
        そのため、foldl1 に必要なのは 2 引数関数と畳み込むリストだけ。
        要素がアキュムレータより大きければ、それを新しいアキュムレータにする。そうでなければ、古いアキュムレータをそのまま残す。
        そのために使っているのが、foldl1 への 2 引数関数として渡している max である。
    -}

    {-  ✋ - foldl1 や foldr1 で定義した関数は、引数のリストに少なくとも 1 つ要素が含まれていることを前提にしているので、
             空リストに対して呼び出すとランタイムエラーが発生する。
           - 一方、foldl や foldr は空リストに対しても正しく動く。
           - 畳み込みを作る際には空リストに対する動作について考えよう。空リストに対しては意味をなさない関数なら、foldl1 や foldr1 を使える可能性がある。ss
    -}

-- ¶ いくつかの畳み込みの例

--- 🌷 reverse
reverse' :: [a] -> [a]
reverse' = foldl (\acc x -> x: acc) [] --reverse' = foldr (\x acc -> acc ++ [x]) [] とも書けるが ++ は遅いため非推奨。
    -- 初期アキュムレータを空リストとし、元のリストを左から順にアキュムレータの先頭にくっつけていくことによって、リストを逆順にしている。

{-  関数 \acc x -> x : acc は、引数が逆になっていることを除けば単なる : 関数である。
    したがって、reverse は次のように実装することもできる。-}
reverse'' :: [a] -> [a]
reverse'' = foldl (flip (:)) []

--- 🌷 次は product を実装しよう。
product' :: Num a => [a] -> a
product' = foldl (*) 1  -- これは easy。

--- 🌷 filter はどうなる？
myFilter :: Foldable t => (a -> Bool) -> t a -> [a]
myFilter cond = foldr (\x acc -> if cond x == True then x:acc else acc) [] {- 徐々に慣れてきた。正解。if cond x == True は if cond x のみでOK。foldl か foldr は
                                                                             とりあえず慣れるまではいったん書いてみて結果を見て逆順になってたら直す、でいい気がする -}

--- 🌷 last は？
last' :: [a] -> a
last' = foldl1 (\_ x-> x) -- 💬わからなかった。。
    -- リストの最後の要素を取得するのに foldl1　を使っている。
    -- リストの最初の要素から始めて、つねに現在の値を新しいアキュムレータに置き換える 2 引数関数でリストを畳み込む。
    -- 最後まで到達したらアキュムレータを返す。これが最後の要素になっているはず。

--- ¶　別の視点から見た畳み込み
{-

右と左の畳み込みは、リストの要素に対する一連の関数適用と見ることもできる。
2 引数関数 f と初期アキュムレータ z による右畳み込みがあるとしよう。
この右畳み込みは、リスト [3, 4, 5, 6] に対して、本紙s津的には次のようなことを行う。

    f 3 (f 4 (f 5 (f 6 z)))

f はリストの最後の要素とアキュムレータに対して呼び出され、それから最後から 2 番目の要素と悪yムレータに対して呼び出され、それが繰り返される。

f として +、初期アキュムレータとして 0 が与えられたとすると、これは次のようになる。

    3 + (4 + (5 + (6 + 0)))

+ を前置関数として書けば以下のようになる。

    (+) 3 ((+) 4 ((+) 5 ((+) 6 0)))

同様に、2 引数関数 g とアキュムレータ z に対する左畳み込み（をリスト [3, 4, 5, 6] に施したもの）は次のように書ける。

    g (g (g (g z 3) 4) 5) 6

2 引数関数として flip (:)、初期アキュムレータとして [] （とリスト [3, 4, 5, 6]）が与えられたとすると、
これ（`foldl (flip (:)) [] [3, 4, 5, 6]`）はリストの反転であり、次と等価になる。

    flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6

そして実際に、これを実行すれば [6, 5, 4, 3] が得られる。

-}

--- ¶ 無限リストを畳み込む
{-

畳み込みを一連の関数適用として考えると、foldr が無限リストに対して完璧に正しく動作する理由が見えてくる。
and を foldr で実装し、前の節のように一連の関数適用として書き下してみよう。
遅延評価の Haskell で foldr が無限リストに対して動作する仕組みがわかるはず。

and 関数は Bool 値のリストを引数に取り、どれか 1 つが False ならば False を、そうでなければ True を返す関数である。
リストを右から走査し、True を初期アキュムレータとする。
2 引数関数としては、全部が True だったときにかぎり True が返ってほしいので　&& を使う。
&& 関数は、2 つの引数のどちらかが False だったときに False を返すので、False を含むリストを走査すればアキュムレータは False にセットされ、
残りの要素が True だったとしても最終的な結果は False になる。

-}

and' :: [Bool] -> Bool
and' = foldr (&&) True

{-

foldr の動作を知っていれば、and' [True, False, True] が次のように評価されるとわかる。

    True && False && (True && True)

最後の True は初期アキュムレータで、最初の 3 つの Bool の値はリスト [True, False, True] から得られるものである。
これを評価すれば False が得られる。

さて、無限リストではどうなるだろうか？
repeat False は無限個の False からなる無限リストである。

and' (repeat False) を書き下してみると以下のようになる。

    False && (False && (False && (False ../* イメージとしては最後に && True と初期アキュムレータ True が登場するが、無限リストなので永遠に初期アキュムレータにはたどりつかない */)))

Haskell は遅延評価ゆえ、本当に必要な部分だけを計算する。
そして && 関数は、両方の引数が True だった場合に限って True を返すので、最初の引数が False であれば 2 つ目の引数を無視する。

    (&&) :: Bool -> Bool -> Bool
    True && x = x
    False && _ = False

この場合だと、False の終わらないリストが 2 つ目のパターンに合致する。
そして、Haskell はその無限リストの残りの部分を評価することなく False を返すのである。

     and' (repeat False) // False

まとめ：foldr は、2 番目の引数をつねに評価するとは限らないような 2 引数関数（ここでいう &&）を与えられた場合、無限リストに対してもうまく動作する。
-}

--- ¶ スキャン
{-
scanl と scanr 関数は、foldl と foldr に似ているが、アキュムレータの中間状態すべてをリストとして返す。
scanl1 と scanr1 関数は fold1 と foldr1 のアナロジーである。
関数の実際の使用例を示す。

    scanl (+) 0 [3, 5, 2, 1] // [0, 3, 8, 10, 11]
    scanr (+) 0 [3, 5, 2, 1] // [11, 8, 3, 1, 0]
    scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1] // [3,3,3,3,3,3,2,1]
    scanl (flip (:)) [] [3,2,1] // [[],[3],[2,3],[1,2,3]]

scanl は結果の最終要素に最終結果が入る。scanr はリストの先頭に結果が入る。
畳み込みで実装できるような関数の途中経過をモニターしたいときにスキャンが使える。
-}

{-
スキャンを使った例として、次の問題に答えてみよう。
「自然数の平方根を小さいものから足していったとき、1000 を超えるのは何個目？」
すべての自然数の平方根を得るには、単純に `map (sqrt) [1..]` とするだけ。
和を求めるのに畳み込みを使うこともできるが、加算の途中経過が知りたいのでスキャンを使おう。
スキャンを使えばどこまでが 1000 より小さいか調べられる。
-}

sqrtSums :: Int
sqrtSums = length (takeWhile (< (1000 :: Double)) (scanl1 (+) (map (sqrt) [1..]))) + 1 -- // 131 // (1000 :: Double) は、そうしないとエラーになる。。
                                                    -- [√1, √2, √3, ...] を次々に足していくので scanl1 として、初期アキュムレータ=リストの先頭（=√1）となるようにする。

--- 上記計算の結果を確かめる（検算）ためには以下のようにする

sqrtSumTo130 :: Double
sqrtSumTo130 = sum (map sqrt [1..130]) -- 993.6486803921487
sqrtSumTo131 :: Double
sqrtSumTo131 = sum (map sqrt [1..131]) -- 1005.0942035344083

-------------------------------
-- $ を使った関数適用
-------------------------------
{-
    今度は $ 関数、又の名を 関数適用演算子 について見ていこう。まずは定義を見てみる。
    
        ($) :: (a -> b) -> a -> b
        f $ x = f x

    ふつうの関数適用（2 つのものの間に空白を置く）は非常に高い優先順位を持っているが、$ 関数は最も低い優先順位を持つ。
    スペースを用いた関数適用は左結合（f a b c は ((f a) b) c を意味する）だが、$ による関数適用は右結合である。

    それが何の役に立つのか？
    括弧の数を少なくしたいとき、たいていはこの関数が役立つ。

    例えば sum (map sqrt [1..130]) という式を考えてみる。
    $ は優先順位が低いため、sum $ map sqrt [1..130] と書き換えることができる。
    $ が出てきたら、その右側の式が左側の関数に引数として渡される。

        sqrt 3 + 4 + 9 は (√3) + 4 + 9 だが、sqrt $ 3 + 4 + 9 とすると √(3+4+9) の意味になる。

    もう 1 つ例を見てみよう。
    
        sum (filter (>10) (map (*2) [2..10])) // 80
    
    $ を使えば、これを以下のように書き換えることができる。

        sum $ filter (>10) $ map (*2) [2..10]
-}

{-
    括弧を削除する話とは別に、$ は関数適用それ自身を関数として扱えるようにするために使える。
    これにより、たとえば関数適用をリストに対して map するようなことができる。

        map ($ 3) [(4+), (10*), (^2), sqrt] // [7.0,30.0,9.0,1.7320508075688772]
        ※ ちなみに、[(4+), (10*), (^2), sqrt] の型は以下に示すとおり Floating a => [a -> a] である。

    この例は、関数 ($ 3) がリストに対して map される。($ 3) という関数は、関数を引数に取って、その関数を 3 に適用する関数だと考えられる。
    したがって、リスト中のすべての関数が 3 に適用され、上のような結果が得られる。
-}

funcls :: Floating a => [a -> a]
funcls = [(4+), (10*), (^(2::Integer)), sqrt]

-------------------------------
-- 関数合成
-------------------------------

{-
    数学における関数合成は (f∘g)(x) = f(g(x)) のように定義される。
    これは、2 つの関数を合成したmのは、まず 1 つの関数を呼び出し、それからもう 1 つの関数にその結果を渡して呼び出したものに等しい、という意味。

    Haskell の関数合成もこれとほぼ同じである。
    次のように定義される「.」関数を使って関数合成ができる。

        (.) :: (b -> c) -> (a -> b) -> a -> c
        f . g = \x -> f (g x)

    型宣言に注意すること。
    f は引数として、g の返り値の型と同じ型の値を受け取らなければなあらない。

    なので、合成された関数は、g が受け取る型と同じ型の引数を受け取り、f が出力する型と同じ型の結果を返す。
    たとえば式 negate . (*3) は、数を受け取り、それを 3 倍して、それから符号反転する関数を返す。

    関数合成の用途としては、他の関数に渡す関数をその場で作るというものがある。
    もちろんラムダ式を使っても良いが、たいていは関数合成のほうが明快で簡潔。

    たとえば、数のリストがあって、その全部を負の数にしたいとする。
    各要素の絶対値を取ってから符号反転するという方法が考えられる。
-}

-- ラムダ式を使う場合
negativeList :: [Int]
negativeList = map (\x -> negate (abs x)) [5, -3, -6, 7, -3, 2, -19, 24] -- // [-5,-3,-6,-7,-3,-2,-19,-24]

-- 関数合成を使う場合
negativeList' :: [Int]
negativeList' = map (negate . abs) [-5,-3,-6,-7,-3,-2,-19,-24]
            -- 関数合成を使わなければ map (negate) (map (abs) [5, -3, -6, 7, -3, 2, -19, 24]) このようになる。数学の分配法則みたいな感じだけど、記述としては冗長なイメージ。

{-
    関数合成は右結合なので、一度にたくさんの関数を合成できる。
    式 f (g (z x)) は (f . g . z) x と等価。

    これを踏まえて、次のコードをなんとかしてみよう。
-}

nyanswer :: [Int]
nyanswer = map (\xs -> negate (sum (tail xs))) [[1..5], [3..6], [1..7]] -- // [-14, -15, -27]

nyanswer' :: [Int]
nyanswer' = map (negate . sum . tail) [[1..5], [3..6], [1..7]]

--- ¶　多引数関数の関数合成

{-
    複数の引数を取る関数を合成するときはどうすればよいだろうか？
    普通は、残り 1 引数になるまで部分適用しないと関数合成できない。
-}

result3 :: Float
result3 = sum (replicate 5 (max 6.7 8.9))

-- 上記の式は、以下のように書き換えられる。

result3' :: Float
result3' = (sum . replicate 5) (max 6.7 8.9)

-- 以下のように書いても同じ。
result3'' :: Float
result3'' = sum . replicate 5 $ max 6.7 8.9

{-
    関数 replicate 5 が max 6.7 8.9 の結果に適用され、それからその結果に sum が適用される。
    replicate 関数を部分適用して 1 つだけ引数を取るようにしている点に注目（❗️それが、「残り 1 引数になるまで部分適用しないと関数合成できない」の意）。

    max 6.7 8.9 の結果が replicate 5 に渡され、数のリストが結果の値となり、さらにそれが sum に渡される。
-}

-- 以下の式はどう書き直せる？
pow :: [Int]
pow = replicate 2 (product (map (*3) (zipWith max [1, 2] [4, 5])))

pow' :: [Int]
pow' = replicate 2 $ product . map (*3) $ zipWith max [1,2] [4,5]
--      replicate 2 . product . map (*3) $ zipWith max [1, 2] [4, 5] でもよい（テキストではこちら）。

{-
🍖 関数合成のしかた
　　📜 まずは一番右側の関数とその引数を書き出すことから始めよう

    この例では、まず、右端にある関数とその引数を見つける。今回は zipWith max [1,2] [4,5] である。
    それから、zipWith max [1, 2] [4, 5] にどの関数が適用されているか調べる。

    それは map (*3) だとわかる。

    そこで、これと先ほどの式 zipWith 〜 の間に $ を書く。
        map (*3) $ zipWith max [1,2] [4,5]

    では、合成を開始しよう。どの関数が適用されるか調べる。
    すると product が適用されているので、map (*3) とこれを合成する。

        product . map (*3) $ zipWith [1,2] [4,5]

    それから最後に replicate 2 が適用されているので、それも合成する。

        replicate 2 . product . map (*3) $ zipWith [1,2] [4,5]
-}

--- ¶ ポイントフリースタイル

{-
    関数合成のもう 1 つの一般的な使い道は、ポイントフリースタイル（※）で関数を定義するというもの。
    （※）ポイントとは、fn x = f (g x) のような関数定義に登場する一時変数 x のこと。ポイントフリースタイルは、このポイントを使わないで関数を定義するスタイルのこと。

    例えば次のような関数を書いたとしよう。
-}

mySum :: (Num a) => [a] -> a
mySum xs = foldl (+) 0 xs

{-
    イコールの両側とも右端が xs である。関数はカリー化されているので、この両側の xs は省略できる。
    flodl (+) 0 を呼び出すとリストを受け取る関数が作り出されるからである。
    このようにして関数をポイントフリースタイルで書くことができる。
-}

mySum' :: (Num a) => [a] -> a
mySum' = foldl (+) 0

{-
    もう一つの例として、次の関数をポイントフリースタイルで書いてみよう。
-}
fn :: (RealFrac a, Integral b, Floating a) => a -> b
fn x = ceiling (negate (tan (cos (max 50 x))))

    -- 単純には両辺の x を取り除けない。
    -- cos (max 50) としてしまっっては、関数のコサインを取るという、意味をなさないコードになってしまう。
    -- ということで、 fn を関数合成で表現する。

fn' :: (RealFrac a, Integral b, Floating a) => a -> b
fn' = ceiling . negate . tan . cos . max 50

{-
    ⭐️  ポイントフリースタイルにすると、データよりも関数に目がいくようになり、どのようにデータが移り変わっていくかではなく
        どんな関数を合成して何になっているかを考えやすくなる。
    ⭐️  単純な関数から始め、関数合成を糊として使うことにより、より複雑な関数を作り出せばよいのである。

    🛑 とはいえ、関数が複雑になりすぎると、ポイントフリースタイルでは可読性が悪くなることもある。
        このため、関数合成のチェインはあまり長くしないようにしよう。
        let を使って途中の結果にラベルを与え、問題を小さな問題に分解すれば、読む人にとってわかりやすいコードになる。
-}

{-
    この翔の前半で、奇数の平方数で 10000 より小さいものの総和を求める問題を解いた。
    これを関数にすると次のようになる。
-}

oddSquareSum :: Int
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^ (2 :: Int)) [1..])))

--関数合成の知識を使うと次のようにも書ける。

oddSquareSum' :: Int
oddSquareSum' = sum . takeWhile (<10000) . filter odd $ map (^ (2 :: Int)) [1..]

-- この書き方のほうが括弧が少ないので視覚的ノイズが少ない。
-- このコードを見て「filter odd が map (^2) [1..] に適用され、それから takeWhile (<10000) がその結果に適用され、最後にその結果に sum が適用される」と読めればよい👌