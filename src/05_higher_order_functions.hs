{-# OPTIONS -Wall -Werror #-}

---_/_/_/_/_/_/_/_/_/_/_/_/---
--      　高階関数　　       --
---_/_/_/_/_/_/_/_/_/_/_/_/---

{-  Haskell の関数は、引数として関数を取ったり返り値として関数を返したりできる。
    このような関数は高階関数と呼ばれる。    -}

-------------------------------
-- カリー化関数（Curried functions）
-------------------------------

{-
　🍛　Haskell のすべての関数は、公式には引数を 1 つだけ取ることになっている。
    　しかし、これまでの章で複数の引数を取る関数を定義してきた。どうなっているのか？

　🍛　複数の引数を受け取れるかのように見えた関数は、すべて **カリー化** された関数だったのである。
    　カリー化関数は、複数の引数を取るかわりに、つねにちょうど 1 つの引数を取る関数。
    　カリー化関数が呼び出されると、その次の引数を受け取る関数を返す。この繰り返しである。
-}

--- 例. max 関数
{- 
    max 関数は、一見すると 2 つの引数をもらって大きい方を返す関数のように見える。
    例えば、 max 4 5 という式。これは関数 max を 2 つの引数 4 と 5 で呼び出している。
    最初に、max が値 4 に適用される。max が 4 に適用されると、その実際の返り値は、5 に適用するための別の関数である。
    この関数が 5 に適用されて最終的な数値が返る。
    
    結果として、次の 2 つの呼び出しは等価になる。

        max 4 5 // 5
        (max 4) 5 // 5

    max 関数の型をあらためて調べてみると以下のとおり。
        max :: Ord a => a -> a -> a
    
    これは次のようにも書ける。
        max :: Ord a => a -> (a -> a)

    矢印 -> を型シグネチャに含むものはすべて関数である。
    つまり、矢印の左にあるものを引数にとり、右側にあるものを型とする値を返す。
    a -> (a -> a) は、a 型の値を引数に取る関数であり、「a 型の値を引数に取り a 型の値を返す関数」を返すのだとわかる。
-}

{-
　💃　それで、なにがうれしいのか？
    👉 関数を本来より少ない火kしううで呼び出したときに、**部分適用** された（partially applied）関数が得られること。
    　　この「部分適用された関数」は、残りの変数を引数として取る関数。
    　　たとえば、max 4 としたとする。これは 1 引数の関数を返す。
    　　部分適用（関数を本来より少ない引数で呼び出すこと）を使うと、関数をその場で手軽に作り出して、それを他の関数に渡せる。
-}

--- 次の小さい単純な関数を見てみよう。
multThree :: Int -> Int -> Int -> Int
multThree x y z = x * y * z

{-
    multThree 3 5 9 あるいは (((multThree 3) 5) 9) を呼び出すと実際には何が起こるだろうか？
    最初に、multThree が 3 に適用される。これにより「引数を 1 つ取って関数を返す関数（ここで、これを関数 fa と呼ぶとする）」が返る。
    そうしたら、その関数 fa が 5 に適用される。これにより「引数を 1 つ取ってそれに 3 と 5 をかけた値を返す関数（これを fb とする）」が返る。
    その関数 fb が 9 に適応され、 135 が最終的な結果になる。

    関数は、なにか材料を受け取って何かを作り出す小さな向上だと考えることができる。
    この比喩を使うと、「multThree に数 3 を与えたら、数ではなくて、ちょっと小さくなった別の工場が出てきた」と言える。
    そのちょっと小さな工場は、数 5 を受け取り、また別の工場を作り出す。
    3 つ目の工場は数 9 を受け取り、最終結果である数 135 を作り出す。

    この関数の型は次のようにも書けることを思い出そう。
        multThree :: Int -> (Int -> (Int -> Int))
    -> の前にある型（あるいは型変数）は関数が受け取る値の型で、後ろにあるのは返り値の型。
    なので、この関数は Int 型の値を受け取り、(Int -> (Int -> Int)) という型を持つ関数（fa）を返す。
    同様に、この関数（fa）は Int 型の値を受け取り、 Int -> Int という型の関数（fb）を返す。
    最後に、この関数（fb）は Int 型の値を受け取り、Int 型の値を返す。
-}

-- 本来より少ない引数で関数を呼び出すことによって新しい関数を作る例を見ていこう。

multTwoWithNine :: Int -> Int -> Int
multTwoWithNine = multThree 9 -- ここ。multThree は本来 multThree 3 5 9 のように 3 引数で呼び出すもの。

result1 :: Int
result1 = multTwoWithNine 2 3

-- Int を引数に取って 100 と比較する関数を作りたいときはどうすればよいだろうか？

compareWithHundred :: Int -> Ordering
compareWithHundred x = compare 100 x
    -- 👉compare 100 は「数を引数に取り、100 と比較する関数」を返す。
-- つまり、次の定義は前の定義と等価。

compareWithHundred' :: Int -> Ordering -- 型宣言は同じまま。
compareWithHundred' = compare 100 -- compare :: Ord a => a -> (a -> Ordering) である。これを 100 に適用すると「数を引数に取り Ordering を返す関数」が得られる。


------------ セクション ----------------

{-
    中置関数に対しても、**セクション** という機能を使って部分適用することができる。
    まず、中置関数をセクションするには、片側だけに値を置いて括弧で囲むだけである。
    これで引数を 1 つ、値を置かなかった側に取る関数ができる。
-}

dividedByTen :: (Floating a) => a -> a
dividedByTen = (/ 10) -- `/` が中置関数であって、dividedByTen は普通の関数（dividedByTen 200 のように使用する）。

-- もうひとつの例。与えられた文字が大文字かどうかを調べる
isCap :: Char -> Bool
isCap = (`elem` ['A'..'Z'])

-- 💡セクションで気をつけないといけないこと。
{-
 ✋ - (負の数、マイナス）演算子と同時に使うとき。
    (-4) は、セクションの定義から考えると、数を受け取ってそれから 4 を引く関数になる。
    しかし (-4) は利便性のために、マイナス 4 を意味することになっている。
    なので、引数から 4 を引き算する関数を作りたいときには、 subtract 関数を (subtract 4) のように部分適用する。
-}

------------ 関数を表示する ----------------
{-
    今までのところ、部分適用した関数は何かしらの名前に束縛して、それから残りの引数を与えていた。
    しかし、関数そのものをターミナルに表示したことはない。
    名前をつけたり、別の関数に渡したりせずに、multiThree 4 3 を GHCi に打ち込むと何が起こるのだろうか？
        ghci > multThree 3 4
        <interactive>:62:1: error:
            • No instance for (Show (Int -> Int)) arising from a use of ‘print’
                (maybe you haven't applied a function to enough arguments?)
            • In a stmt of an interactive GHCi command: print it

    GHCi は、この式が Int -> Int の型の関数を生成したけど、それをどうやって画面に表示したらいいかわからないと言っている。
    関数は Show 型クラスのインスタンスではないので、いい感じに関数を表示する文字列が得られないのである。

    これは、たとえば 1 + 1 のような式を入力した場合とは異なる。
    この場合 GHCi は、式の結果として 2 を計算し、それから 2 に対して show を呼んで、数のテキスト表現（文字列 "2"）を得る。
-}

-------------------------------
-- 高階実演
-------------------------------

-- 関数を受け取り、それを 2 回適用する関数を書いてみよう

applyTwice :: (a -> a) -> a -> a 
applyTwice f x = f (f x)

{-
    📣 型宣言に気を付けること
    `->` は右結合なのでこれまでの例では関数の肩を宣言するときに括弧は必要なかったが、ここでの括弧は必須。
    これは、関数の最初の引数が「1 つ引数を取り、同じ型の値を返す関数（a -> a）」だということを示している。
    2 つ目の引数は何か a 型の値で、返り値も a 型である。
    a はなんの型でも（Int でも String でも他の型でも）いいが、すべての a は同じ型である必要があることに注意（`f f x` から、f の引数の型は f の返り値の型と一致する必要がある）
-}

{-
    🌀 applyTwice の使用例
        applyTwice (+3) 10 // 16
        applyTwice (++ " HAHA") "HEY" // "HEY HAHA HAHA"
        applyTwice ("HAHA " ++) "HEY" // "HAHA HAHA HEY"
        applyTwice (multThree 2 2) 9 // 144
        applyTwice (3:) [1] // [3,3,1]

    🌀　部分適用のすごさと実用性がわかる。1 引数の関数を渡す必要があるのなら、部分適用を使って 1 引数の関数を作り、それに渡せばいいのである。
        たとえば、+ は 2 つの引数を受け取るが、この例では、セクションを使った部分適用で 1 つだけ引数を与えている。
-}

---- ¶ zipWith を実装する

{-
    zipWith は関数と 2 つのリストを引数に取り、2 つのリストの各要素にその関数を適用することで、 2 つのリストを 1 つに結合するもの。
-}

{-  ❌　自分の回答。ダメ（zipWith' (+) [1, 2, 3] [10, 10, 10] とすると [11, 11, 11, 12, 12, 12, 13, 13, 13] となる（expected: [11, 12, 13]））
    zipWith' :: (a -> a -> b) -> [a] -> [a] -> [b]
    zipWith' f xs ys = [(f x y) | x <- xs, y <- ys]
-}

zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] -- 型宣言がよくわからなくなったら省略して書き、Haskell に推論してもらえばよい。
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

{-
    🍦zipWith' の使い道
    zipWith' (+) [4, 2, 5, 6] [2, 6, 2, 3] // [6,8,7.9]
    zipWith' max [6, 3, 2, 1] [7, 3, 1, 5] // [7,3,2,5]
    zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"] // ["foo fighters","bar hoppers","baz aldrin"]
    zipWith' (*) (replicate 5 2) [1..] // [2,4,6,8,10]
    zipWith' (zipWith' (*)) [[1, 2, 3], [3, 5, 6], [2, 3, 4]] [[3, 2, 2], [3, 4, 5], [5, 4, 3]] // [[3,4,6],[9,20,30],[10,12,12]]
                -- それぞれ対応する要素の積になる（[[1*3, 2*2, 3*2],[3*3, 5*4, 6*5], [2*5, 3*4, 4*3]
-}

---- ¶ flip を実装する

{-
    flip 関数は、関数を引数に取り、元の関数と似ているけれど最初の 2 つの引数が入れ替わった関数を返す。
-}
flip':: (a -> b -> c) -> b -> a -> c
flip' f x y = f y x

{-
    zip [1, 2, 3, 4, 5] "hello" // [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
    flip' zip [1, 2, 3, 4, 5] "hello" // [('h',1),('e',2),('l',3),('l',4),('o',5)]
    zipWith div [2, 2..] [10, 8, 6, 4, 2] // [0,0,0,0,1]
    zipWith (flip' div) [2,2..] [10, 8, 6, 4, 2] // [5,4,3,2,1]
-}

-------------------------------
-- 関数プログラマの道具箱
-------------------------------

---- ¶ map 関数
---- 関数とリストを受け取り、その関数をリストのすべての要素に適用して新しいリストを生成する。

map':: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = f x: map' f xs

{-
 🗾 使い方の例
    map (+3) [1, 5, 3, 1, 6] // [4,8,6,4,9]
    map (++ "!") ["BIFF", "BANG", "POW"] // ["BIFF!","BANG!","POW!"]
    map (replicate 3) [3..6] // [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
    map (map (^2)) [[1,2], [3,4,5,6], [7,8]] // [[1,4],[9,16,25,36],[49,64]]
    map fst [(1,2), (3,5), (6,3), (2,6), (2,5)] // [1,3,6,2,2]

    リスト内包表記を使っても同じことができるが、map 関数をつかうほうが読みやすくなる。
-}

---- ¶ filter 関数
----   述語とリストを受け取り、そのリストの要素のうち、述語を満たすもののみからなるリストを返す（述語とは、何が true で何が false かを言う関数、つまり真理値を返す関数）。

filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' s (x:xs)
    | s x = x : filter' s xs
    | otherwise = filter' s xs

{-
👀 filter の例 
    filter (>3) [1, 2, 3, 4, 5] // [4,5]
    filter (==3) [1, 2, 3, 4, 5] // [3]
    filter even [1..10] // [2,4,6,8,10]
    let notNull x = not (null x) in filter notNull [[1,2,3], [], [3,4,5], [2,2],[],[],[]] // [[1,2,3],[3,4,5],[2,2]]
    filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent" // "uagameasadifeent"
    filter (`elem` ['A'..'Z']) "i LAuGh at you bEcause u R all the same" // "LAGER"

    これもリスト内包表記と述語を使って同じことができる。
    どんなときにリスト内包表記を使って、どんなときに map や filter を使うかというルールはない。
    その時々で読みやすいほうを採用すること。
-}

{-
    リスト内包表記で複数の述語を指定するようなケースを filter で書くときは、filter を何度か適用するか、述語を論理関数 && でつないで指定する。
-}

result2 :: [Int]
result2 = filter (<15) (filter even [1..20]) -- [2,4,6,8,10,12,14]

-- リスト内包表記でも書ける
result2' :: [Int]
result2' = [x | x <- [1..20], x < 15, even x]

{-
    quicksort 関数
-}

-- 前の章では以下のように実装した
quicksort:: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerOrEqual = [a | a <- xs, a <= x]
        larger = [a | a <- xs, a > x]
    in quicksort smallerOrEqual ++ [x] ++ quicksort larger

-- これを filter 使えば以下のように書ける。
quicksort' :: (Ord a) => [a] -> [a]
quicksort' [] = []
quicksort' (x:xs)
    =   let smallerOrEqual = filter (<= x) xs
            larger = filter (> x) xs
        in  quicksort' smallerOrEqual ++ [x] ++ quicksort' larger

------- map と filter のさらなる例 --------

-- 👀　10 万以下の数のうち 3829 で割り切れる最大の数を探してみよう。
largestDivisible :: Int
largestDivisible = head (filter p [100000, 99999..])
    where p x = x `mod` 3829 == 0
        -- 答え：99554

{- 
    はじめに、100000 より小さいすべての数からなる降順のリストを作る。
    それから、それを述語でフィルタする。
    数のリストは呼応順にソートされているので、条件を満たす最大の数は、フィルタされたリストの先頭の要素として現れる。
    それゆえ、フィルtされたリストの head を取る。
    残りのリストが有限か無限かはどうでもいい話。
    Haskell は怠惰なので最初の条件に合う解が見つかれば評価は停止する。
-}

-- 👀 次の例. 10000　より小さいすべての奇数の平方数の和を求めよ。（「10000 より小さい奇数」の平方数の和ではなく、「10000 より小さい「奇数の平方数」」の和）
{-
    これには takeWhile という関数を使う。
    この関数は述語とリストを受け取り、リストの先頭から始めて述語の条件が満たされるかぎりリストの要素を返し続ける。
    条件に合わない要素が見つかったらリストを返すのをやめる。
    たとえば、文字列の最初の単語を以下のように取得できる。
        takeWhile (/= ' ') "elephants know how to party" // "elephants"
-}

sumOfOddSquare :: Int
sumOfOddSquare = sum (takeWhile (<10000) (filter odd (map (^ (2 :: Int)) [1..]))) -- //166650
                                                            -- ここは、{-# OPTIONS -Wall -Werror #-} のオプションつけてると単純に ^2 とするとエラーが出る。参考：https://teratail.com/questions/10377

--- 同じものをリスト内包で書くと。。
sumOfOddSquare' :: Int
sumOfOddSquare' = sum (takeWhile (<10000) [m | m <- [n^(2 :: Int) | n <- [1..]], odd m])

---- 上記のどちらの書き方でもそうだけど、takeWhile を使わずにたとえばフィルタリングするための条件（述語）として (二乗した値) < 10000 てな具合でやっちゃうと
---- n <- [1..10000] の二乗和をまずぜんぶとりあえず計算してからその全部に対して 10000 より小さいかの比較をしていくかたちになるので相当計算が重くなる


-- 👀 次の例.　コラッツ列

{-
    コラッツの数列は次のように定義される
        - 任意の自然数から開始する
        - 数が 1 ならば終了
        - 数が偶数なら、2 で割る
        - 数が奇数なら、3 倍して 1 を足す
        - 新しい値でこのアルゴリズムを繰り返す

    この定義に従うと、ある数の列ができる。この列は最初の数がなんであっても最終的には 1 に到達すると予想されている。
    たとえば 13 から始めると
        13, 40, 20, 10, 5, 16, 8, 4, 2, 1
    という列が得られる。13 から始めたコラッツ列の長さは 10 であるとわかる。

    解きたい問題はこれ：「1 から 100 までの数のうち、長さが 15 より大きいのコラッツ列の開始数になるものはいくつあるか？」
-}

-- 🌸最初のステップは数列を生成する関数を書くこと
chain :: Integer -> [Integer]
chain 1 = [1]
chain n
    | even n = n : chain (n `div` 2) -- (n / 2) だと型が Int(eger) にならないのでエラーになる
    | otherwise  = n : chain (n*3+1) -- | odd n = としてもいいけど、そうすると incomplete-patterns エラーが出てしまうので。

-- 🌸それでは実際に問題に答える関数を書こう
numLongChains :: Int
numLongChains = length (filter (> 15) (map length (map chain [1..100])))

{- 上記でOK。テキストの模範解答は以下。 -}
numLongChains' :: Int
numLongChains' = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs > 15

{-
　🍃 map 関数に複数の引数を与える
    いままで map するのに使っていた関数は、1 引数のみを取る関数だけだった。（map (*2) [0..] のような）。
    しかし、複数の引数を取る関数で map することも可能である。たとえば map (*) [1..] のようなことができる。
    この場合、関数 * は型 (Num a) => a -> a -> a を持ち、これがリストの各要素に適用される。

    すでに見たように、2 引数の関数に 1 引数だけを与えたら、1 引数を取る関数が返されるのだった。
    ゆえに、[0..] を * で map したら、1 引数関数のリストが得られる。
-}

-- 例.
listOfFuns :: (Num a, Enum a) => [a -> a]
listOfFuns = map (*) [0..]

-- たとえば、(listOfFuns !! 4) 5 とすると。。
-- 関数のリストの 4 番目（0-based）の要素を取り出すと、(4*) と等価な関数が得られる。これを 5 に適用すると (4*) 5、つまり 4*5 と等しいものになる。
-- 他にも、take 5 [f 10 | f <- listOfFuns] とすると [0, 10, 20, 30, 40] という結果になる。