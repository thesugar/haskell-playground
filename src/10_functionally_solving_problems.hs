{-# OPTIONS -Wall -Werror #-}

---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---
--   ã€€ã€€ã€€ã€€é–¢æ•°å‹å•é¡Œè§£æ±ºæ³•ã€€ã€€ã€€ã€€    --
---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---

-------------------------------
--ã€€é€†ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•é›»å“
-------------------------------
{-
    ãµã¤ã†ã€ç®—æ•°ã§ã¯ä¸­ç½®è¨˜æ³•ã§å¼ã‚’æ›¸ãã€‚10 - (4 + 3) * 2 ã¨ã„ã†å…·åˆã«ã€‚
    è¶³ã—ç®—ï¼ˆ+ï¼‰ã€æ›ã‘ç®—ï¼ˆ*ï¼‰ã€å¼•ãç®—ï¼ˆ-ï¼‰ãªã©ã¯ã€Haskell ã®ä¸­ç½®é–¢æ•°ï¼ˆ+ ã¨ã‹ `elem`ã¨ã‹ï¼‰ã¨åŒã˜ãã€ä¸­ç½®æ¼”ç®—å­ã§ã‚ã‚‹ã€‚
    äººé–“ã¯ä¸­ç½®è¨˜æ³•ã®æ•°å¼ã‚’ã„ã¨ã‚‚ç°¡å˜ã«è„³å†…ã§ parse ã§ãã‚‹ã€‚
    æ¬ ç‚¹ã¯ã€æ¼”ç®—ã®å„ªå…ˆé †ä½ã‚’æŒ‡å®šã™ã‚‹ã®ã«æ‹¬å¼§ãŒå¿…è¦ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã ã€‚

    æ•°å¼ã‚’æ›¸ãåˆ¥ã®æ–¹æ³•ã¨ã—ã¦ **é€†ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•ï¼ˆreverse polish notationï¼‰**ã€ç•¥ã—ã¦ RPN ãŒã‚ã‚‹ã€‚
    RPN ã§ã¯ã€æ¼”ç®—å­ã¯æ•°ã«æŒŸã¾ã‚Œã‚‹ã®ã§ã¯ãªãã€æ•°ã®å¾Œã«æ¥ã‚‹ã€‚
    4 + 3 ã¨æ›¸ãä»£ã‚ã‚Šã« 4 3 + ã¨æ›¸ãã‚ã‘ã§ã‚ã‚‹ã€‚
    ã§ã¯è¤‡æ•°ã®æ¼”ç®—å­ã‚’å«ã‚€æ•°å¼ã¯ã©ã®ã‚ˆã†ã«æ›¸ãã®ã ã‚ã†ï¼Ÿã€€ç­”ãˆã¯ç°¡å˜ã€‚ 4 3 + 10 * ã¨æ›¸ãã€‚ã“ã“ã§ 4 3 + ã¯ 7 ãªã®ã§ã€æ•°å¼å…¨ä½“ã¯ 7 10 * ã¨ç­‰ä¾¡ã«ãªã‚‹ã€‚
-}

--- Â¶ã€€RPN è¨˜æ³•ã®å¼ã‚’è¨ˆç®—
{-
    RPN è¨˜æ³•ã‚’è¨ˆç®—ã™ã‚‹æ–¹æ³•ã‚’æ„Ÿè¦šçš„ã«ã¤ã‹ã‚€ã«ã¯ã€æ•°ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã™ã‚‹ã€‚RPN è¨˜æ³•ã¯ã€å·¦ã‹ã‚‰å³ã«ï¼ˆï¼æ™®é€šã«ï¼‰èª­ã‚€ã€‚æ•°ã‚’èª­ã¿è¾¼ã‚“ã ã‚‰ã€ãã‚Œã‚’ã‚¹ã‚¿ãƒƒãƒ—ã®ã¦ã£ãºã‚“ã«ç©ã‚€ï¼ˆpushï¼‰ã€‚
    æ¼”ç®—å­ã‚’èª­ã¿è¾¼ã‚“ã ã‚‰ã€ã‚¹ã‚¿ãƒƒã‚¯ã®ã¦ã£ãºã‚“ã‹ã‚‰ 2 ã¤ã®æ•°ã‚’å–ã‚Šå‡ºã—ï¼ˆpopï¼‰ã€ãã® 2 ã¤ã®æ•°ã«æ¼”ç®—å­ã‚’æ–½ã—ã¦ã€æ¼”ç®—çµæœã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«ç©ã¿ç›´ã™ã€‚
    å¼ã®æœ«å°¾ã«ãŸã©ã‚Šç€ã„ãŸã‚‰ã€è¨ˆç®—çµæœã‚’ç¤ºã™æ•°ãŒ 1 ã¤ã ã‘ã‚¹ã‚¿ãƒƒã‚¯ã«æ®‹ã£ã¦ã„ã‚‹ã¯ãšã§ã‚ã‚‹ã€‚

    ä¾‹ãˆã°ã€RPN å¼ 10 4 3 + 2 * - ã‚’ã©ã†ã‚„ã£ã¦è©•ä¾¡ã™ã‚‹ã®ã‹è¦‹ã¦ã„ã“ã†ã€‚
    â†’   1. ã¾ãš 10 ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«ç©ã¿ã€ã‚¹ã‚¿ãƒƒã‚¯ã¯ 10 ãŒ 1 ã¤å…¥ã£ãŸçŠ¶æ…‹ã«ãªã‚‹ã€‚
        2. æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯ 4 ãªã®ã§ã€ã“ã‚Œã‚‚ã‚¹ã‚¿ãƒƒã‚¯ã«ç©ã‚€ã€‚ä»Šã®ã‚¹ã‚¿ãƒƒã‚¯ã¯ 10, 4 ã§ã‚ã‚‹ã€‚
        3. 3 ã«ã‚‚åŒã˜ã“ã¨ã‚’ã—ã¦ã‚¹ã‚¿ãƒƒã‚¯ã¯ 10, 4, 3 ã«ãªã‚‹ã€‚
        4. æ¼”ç®—å­ãŒå‡ºã¦ããŸã€‚+ã€‚ãã“ã§ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ 2 ã¤ã®æ•°ã‚’å–ã‚Šå‡ºã—ï¼ˆã‚¹ã‚¿ãƒƒã‚¯ã¯ 10 ã ã‘ã«ãªã‚‹ï¼‰ã€å–ã‚Šå‡ºã—ãŸ 2 ã¤ã®æ•°ã‚’åŠ ç®—ã—ã€è¨ˆç®—çµæœã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«æˆ»ã™ã€‚
        ã€€ã€€ã“ã†ã—ã¦ã‚¹ã‚¿ãƒƒã‚¯ã¯ 10, 7 ã«ãªã‚‹ã€‚
        5. æ¬¡ã«ã‚¹ã‚¿ãƒƒã‚¯ã« 2 ã‚’ç©ã¿ã€ã‚¹ã‚¿ãƒƒã‚¯ã¯ 10, 7, 2 ã«ãªã‚‹ã€‚
        6. ã¾ãŸæ¼”ç®—å­ãŒããŸã€‚7 ã¨ 2 ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å–ã‚Šå‡ºã—ã€æ›ã‘ç®—ã—ã¦ã€çµæœã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«æˆ»ã™ã€‚7 * 2 ã¯ 14 ã ã‹ã‚‰ã€ã‚¹ã‚¿ãƒƒã‚¯ã¯ 10, 14 ã«ãªã‚‹ã€‚
        7. æœ€å¾Œã« - ãŒã‚ã‚‹ã€‚10 ã¨ 14 ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å–ã‚Šå‡ºã—ã€10 ã‹ã‚‰ 14 ã‚’å¼•ã„ã¦ã€ã‚¹ã‚¿ãƒƒã‚¯ã«æˆ»ã™ã€‚
        8. ã‚¹ã‚¿ãƒƒã‚¯ã«ä¹—ã£ã¦ã„ã‚‹æ•°ã¯ -4ã€‚ä¸ãˆã‚‰ã‚ŒãŸå¼ã«ã¯ã‚‚ã†æ•°ã‚‚æ¼”ç®—å­ã‚‚æ®‹ã£ã¦ã„ãªã„ã®ã§ã€ã“ã‚ŒãŒç­”ãˆã§ã‚ã‚‹ã€‚ 

    ã“ã‚ŒãŒ RPN å¼ã‚’æ‰‹ã§è¨ˆç®—ã™ã‚‹æ–¹æ³•ã§ã‚ã‚‹ã€‚ã§ã¯ã€Haskell ã§åŒã˜ã“ã¨ã‚’ã™ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°ã„ã„ã‹ï¼Ÿ
-}

--- Â¶ RPN é–¢æ•°ã‚’æ›¸ã
{-
    "10 4 3 + 2 * -" ã®ã‚ˆã†ãª RPN å¼ã‚’æ–‡å­—åˆ—ã§å—ã‘å–ã£ã¦ã€ãã®å¼ã®çµæœã‚’è¿”ã™é–¢æ•°ã‚’æ›¸ã“ã†ã€‚
    ã“ã®é–¢æ•°ã®å‹ã¯ã©ã†ãªã‚‹ã‹ï¼Ÿã€€ã€Œæ–‡å­—åˆ—ã‚’å¼•æ•°ã«å–ã£ã¦ã€æ•°ã‚’çµæœã¨ã—ã¦è¿”ã™é–¢æ•°ã€ã§ã‚ã‚‹ã€‚
    å‰²ã‚Šç®—ã‚‚ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã„ã®ã§ã€çµæœã¯å€ç²¾åº¦æµ®å‹•å°æ•°ãŒã„ã„ã ã‚ã†ã€‚ã¨ã„ã†ã‚ã‘ã§ã€å‹ã¯ String -> Double ã¨ã™ã‚‹ã®ãŒã„ã„ã‹ãªã€‚
    ã€€ğŸ‘‰ é–¢æ•°ã®å®Ÿè£…ã«å–ã‚Šæ›ã‹ã‚‹å‰ã«ã€ã¾ãšé–¢æ•°ã‚“ãŠå‹å®£è¨€ãŒã©ã†ãªã‚‹ã‹è€ƒãˆã‚‹ã®ã¯ã¨ã¦ã‚‚å½¹ã«ç«‹ã¤ç¿’æ…£ã§ã‚ã‚‹ï¼

    ã§ã¯ã€RPN ã‚’è§£ãé–¢æ•°ã‚’ã©ã†æ›¸ã‘ã°ã„ã„ã‹è€ƒãˆã¦ã„ãã€‚æ‰‹è¨ˆç®—ã—ãŸã¨ãã¯ã€ç©ºç™½ã§åŒºåˆ‡ã‚‰ã‚ŒãŸæ•°ã‚„æ¼”ç®—å­ã®ãã‚Œãã‚Œã‚’ 1 ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦æ‰±ã£ãŸã€‚
    ã¨ã„ã†ã“ã¨ã¯ã€ "10 4 3 + 2 * -" ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‚’ã€ã¾ãšã¯ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã«åˆ†å‰²ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã¨ã‚ˆã•ãã†ã€‚
        ["10", "4", "3", "+", "2", "*", "-"]
    ãã‚Œã‹ã‚‰ã€ã“ã®ãƒªã‚¹ãƒˆã‚’å·¦ã‹ã‚‰å³ã¸ã¨èµ°æŸ»ã—ã¦ã€ãã®é–“ã‚¹ã‚¿ãƒƒã‚¯ã‚’æ›´æ–°ã—ç¶šã‘ãŸã‚“ã ã£ãŸã€‚
    ã“ã‚Œã¯ç•³ã¿è¾¼ã¿ï¼ˆãƒªã‚¹ãƒˆã‚’ä¸€è¦ç´ ã”ã¨ã«èµ°æŸ»ã—ãªãŒã‚‰ä½•ã‚‰ã‹ã®çµæœã‚’ç©ã¿ä¸Šã’ã¦ã„ãï¼ˆã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ãƒˆï¼‰ï¼‰ã«ä¼¼ã¦ã„ã‚‹ï¼

    ä»Šå›ã®å ´åˆã€ãƒªã‚¹ãƒˆã‚’å·¦ã‹ã‚‰å³ã¸èµ°æŸ»ã™ã‚‹ã®ã§ã€å·¦ç•³ã¿è¾¼ã¿ã‚’ä½¿ãŠã†ã€‚
    ã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿å€¤ã¯ã‚¹ã‚¿ãƒƒã‚¯ãªã®ã§ã€ç•³ã¿è¾¼ã¿ãŒè¿”ã™çµæœã‚‚ã‚¹ã‚¿ãƒƒã‚¯ã«ãªã‚‹ã¯ãšã§ã‚ã‚‹ã€‚
    ãŸã ã—ã€ã™ã§ã«è¦‹ãŸã‚ˆã†ã«å€¤ãŒ 1 ã¤ã—ã‹å…¥ã£ã¦ã„ãªã„ã‚¹ã‚¿ãƒƒã‚¯ã§ã‚ã‚‹ã€‚

    ã‚‚ã† 1 ã¤ã€ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã©ã®ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã‹ã‚‚è€ƒãˆã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
    ãƒªã‚¹ãƒˆã‚’ä½¿ã£ã¦ã€ãƒªã‚¹ãƒˆã®å…ˆé ­ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã®å…ˆé ­ã«å¯¾å¿œã•ã›ã‚‹ã®ãŒã„ã„ã ã‚ã†ã€‚ãƒªã‚¹ãƒˆã®å…ˆé ­ï¼ˆheadï¼‰ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã®ã¯ã€æœ«å°¾ã«è¿½åŠ ã™ã‚‹ã‚ˆã‚Šãšã£ã¨é«˜é€Ÿã ã‹ã‚‰ã ã€‚
    ä¾‹ãˆã° 10, 4, 3 ã¨ã„ã†ã‚¹ã‚¿ãƒƒã‚¯ã¯ 3:4:10:[] ã™ãªã‚ã¡ [3,4,10] ã¨ã„ã†ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚

    ã“ã‚Œã§ä½œã‚ŠãŸã„é–¢æ•°ã®å§¿ãŒãŠã¼ã‚ã’ãªãŒã‚‰è¦‹ãˆã¦ããŸã€‚ã¾ãšãã®é–¢æ•°ã¯ "10 4 3 + 2 * -" ã¨ã„ã£ãŸæ–‡å­—åˆ—ã‚’å–ã‚Šã€ãã‚Œã‚’ words ã‚’ä½¿ã£ã¦ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã«åˆ†è§£ã™ã‚‹ã€‚
    æ¬¡ã«ã€ãã®ãƒªã‚¹ãƒˆã«å·¦ç•³ã¿è¾¼ã¿ã‚’ä½¿ã£ã¦ã€å˜ä¸€ã®è¦ç´ ãŒå…¥ã£ãŸã‚¹ã‚¿ãƒƒã‚¯ï¼ˆã“ã®ä¾‹ã®å ´åˆã¯ã€[-4]ï¼‰ã«ãŸã©ã‚Šã¤ãã€‚
    ãã®å˜ä¸€è¦ç´ ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å–ã‚Šå‡ºã—ã¦ã€ãã‚ŒãŒãƒ•ã‚¡ã‚¤ãƒŠãƒ«ã‚¢ãƒ³ã‚µãƒ¼ã§ã‚ã‚‹ï¼

    ä»¥ä¸‹ãŒãã®é–¢æ•°ã®ã‚¹ã‚±ãƒƒãƒã§ã‚ã‚‹ã€‚
        solveRPN :: String -> Double
        solveRPN expression = head $ foldl foldingFunction [] (words expression)
            where foldingFunction stack item = ...

    ã“ã®é–¢æ•°ã¯ expression ã‚’å–ã£ã¦ã€ã¾ãšã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã«å¤‰ãˆã‚‹ã€‚ãã‚Œã‹ã‚‰ãã®ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã‚’é–¢æ•° foldingFunction ã§ç•³ã¿è¾¼ã‚€ã€‚
    [] ã¯ã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿ã®åˆæœŸå€¤ã§ã‚ã‚‹ã€‚ã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿ã¯ã‚¹ã‚¿ãƒƒã‚¯ãªã®ã§ã€[] ã¯ç©ºã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚
    ãã—ã¦å˜ä¸€è¦ç´ ã®å…¥ã£ãŸæœ€çµ‚çŠ¶æ…‹ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’å—ã‘å–ã£ãŸã‚‰ã€head ã‚’ä½¿ã£ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–ã‚Šå‡ºã™ã€‚

    ã•ã¦ã€ã‚ã¨ã¯ç•³ã¿è¾¼ã¿å‡¦ç†ã‚’è¡Œã†é–¢æ•°ã‚’æ›¸ãã ã‘ã§ã‚ã‚‹ã€‚
    ãã®é–¢æ•°ã¯ã€ãŸã¨ãˆã°ã‚¹ã‚¿ãƒƒã‚¯ [4,10] ã¨ã‚¢ã‚¤ãƒ†ãƒ  "3" ã‚’å—ã‘å–ã£ã¦ã€æ–°ã—ã„ã‚¹ã‚¿ãƒƒã‚¯ [3,4,10] ã‚’è¿”ã™ã€‚
    ã¾ãŸã€ã‚¹ã‚¿ãƒƒã‚¯ãŒ [4,10] ã§ã€å—ã‘å–ã£ãŸã‚¢ã‚¤ãƒ†ãƒ ãŒ "*" ãªã‚‰ã€é–¢æ•°ã¯ [40] ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚

    ã¨ã‚Šã‚ãˆãšã€ç•³ã¿è¾¼ã¿é–¢æ•°ã‚’æ›¸ãå‰ã«ã€å…¨ä½“ã®é–¢æ•°ã‚’ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã§æ›¸ãç›´ã—ã¦ãŠãã€‚

        solveRPN :: String -> Double
        solveRPN = head . foldl foldingFunction [] . words
            where foldingFunction stack item = ...

    ç•³ã¿è¾¼ã¿é–¢æ•°ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚¢ã‚¤ãƒ†ãƒ ã‚’å—ã‘å–ã£ã¦æ–°ã—ã„ã‚¹ã‚¿ãƒƒã‚¯ã‚’è¿”ã™ã‚ˆã†ã«ã™ã‚‹ã€‚
    é–¢æ•°å®šç¾©æ§‹æ–‡ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’ä½¿ã„ã€ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸Šå´ã«ã‚ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–ã‚Šå‡ºã™å‡¦ç†ã¨ "*" ã‚„ "-" ã®ã‚ˆã†ãªæ¼”ç®—å­ã‚’è­˜åˆ¥ã™ã‚‹å‡¦ç†ã‚’ä¸€æ°—ã«ã‚„ã‚ã†ã€‚

        foldingFunction (x:y:ys) "*" = (y * x):ys
        foldingFunction (x:y:ys) "+" = (y + x):ys
        foldingFunction (x:y:ys) "-" = (y - x):ys
        foldingFunction xs numberString = read numberString:xs
-}

solveRPN :: String -> Double
solveRPN = head . foldl foldingFunction [] . words
    where   foldingFunction (x:y:ys) "*" = (y*x):ys
            foldingFunction (x:y:ys) "+" = (y+x):ys
            foldingFunction (x:y:ys) "-" = (y-x):ys
            foldingFunction xs numberString = read numberString: xs

{-
    ã“ã®é–¢æ•°ã§éŠã‚“ã§ã¿ã‚ˆã†ã€‚

    *Main> solveRPN "10 4 3 + 2 * -"
    -4.0

    *Main> solveRPN "2 3.5 +"
    5.5

    *Main> solveRPN "90 34 12 33 55 56 + * - +"
    -3617.0

    *Main> solveRPN "90 34 12 33 55 66 + * - +"
    -3947.0

    *Main> solveRPN "90 34 12 33 55 66 + * - + -"
    4037.0

    *Main> solveRPN "90 3.8 -"
    86.2
-}

--- Â¶ã€€æ¼”ç®—å­ã‚’è¿½åŠ ã—ã‚ˆã†
{-
    ã“ã®è§£æ³•ã®ä½•ãŒè‰¯ã„ã‹ã¨ã„ã†ã¨ã€ä»–ã®ã„ã‚ã‚“ãªæ¼”ç®—ã‚’ç°¡å˜ã«ã‚µãƒãƒ¼ãƒˆã§ãã‚‹ã¨ã“ã‚ã§ã‚ã‚‹ã€‚
    äºŒé …æ¼”ç®—å­ã§ã‚ã‚‹å¿…è¦ã‚‚ãªã„ã€‚
    ä¾‹ãˆã°ã€æ•°ã‚’ 1 ã¤ã ã‘å–ã‚Šå‡ºã—ã¦ãã®å¯¾æ•°ã‚’ç©ã‚€ "ln" ã¨ã„ã†æ¼”ç®—ã‚‚ä½œã‚Œã‚‹ã€‚
    å¯å¤‰é•·å¼•æ•°ã‚’å–ã‚‹æ¼”ç®—å­ã ã£ã¦ä½œã‚Œã‚‹ã€‚
    ä¾‹ãˆã° "sum" ã¯ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ã™ã¹ã¦ã®æ•°ã‚’å–ã‚Šå‡ºã—ã¦ãã®ç·å’Œã‚’ç©ã‚€æ¼”ç®—ã§ã‚ã‚‹ã€‚

    RPN é›»å“é–¢æ•°ã‚’ä¿®æ­£ã—ã¦ã‚‚ã£ã¨å¤šãã®æ¼”ç®—å­ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ã—ã‚ˆã†ã€‚
-}

solveRPN' :: String -> Double
solveRPN' = head . foldl foldingFunction [] . words
    where   foldingFunction (x:y:ys) "*" = (y * x):ys
            foldingFunction (x:y:ys) "+" = (y + x):ys
            foldingFunction (x:y:ys) "-" = (y - x):ys
            foldingFunction (x:y:ys) "/" = (y / x):ys
            foldingFunction (x:y:ys) "^" = (y ** x):ys
            foldingFunction (x:xs) "ln" = log x:xs
            foldingFunction xs "sum" = [sum xs]
            foldingFunction xs numberString = read numberString: xs

{-
    *Main> solveRPN' "1 2 sum"
    3.0

    *Main> solveRPN' "2.71828 ln"
    0.999999327347282

    *Main> solveRPN' "10 10 10 10 sum 4 /"
    10.0

    *Main> solveRPN' "10 2 ^"
    100.0

    ä»»æ„ã®æµ®å‹•å°æ•°ç‚¹æ•°ã® RPN å¼ã‚’è¨ˆç®—ã§ãã¦ã€ã—ã‹ã‚‚ç”¨æ„ã«æ‹¡å¼µã§ãã‚‹é–¢æ•°ãŒãŸã£ãŸã® 10 è¡Œã§æ›¸ã‘ã‚‹ã¨ã„ã†ã®ã¯ã‹ãªã‚Šé©šç•°çš„ï¼
-}

-------------------------------
--ã€€ãƒ’ãƒ¼ã‚¹ãƒ­ãƒ¼ç©ºæ¸¯ã‹ã‚‰ãƒ­ãƒ³ãƒ‰ãƒ³ã¸
-------------------------------
{-
    æœ€çŸ­çµŒè·¯ã‚’æ¢ã™å•é¡Œ

    A -- A1 -- A2 -- A3 -- A4
          |    |      |    |
          |    |      |    |
    B -- B1 -- B2 -- B3 -- B4

    1. å¹¹ç·šé“è·¯ A ã®ãƒ’ãƒ¼ã‚¹ãƒ­ãƒ¼ç©ºæ¸¯ã‹ã‚‰ 1 ã¤ç›®ã®äº¤å·®ç‚¹ã¾ã§ã®æœ€çŸ­çµŒè·¯ã¯ä½•ã‹ã‚’æ±‚ã‚ã‚‹ã€‚é¸æŠè‚¢ã¯ã€ç›´æ¥ A ã‚’é€²ã‚€ã‹ã€B ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ä¹—ã‚Šæ›ãˆã‚‹ï¼ˆæ¸¡ã‚‹ï¼‰ã‹ã® 2 ã¤ã€‚
    2. åŒã˜æ‰‹ç¶šãã§ã€å¹¹ç·šé“è·¯ B ã®æœ€åˆã®äº¤å·®ç‚¹ã¾ã§ã®æœ€çŸ­çµŒè·¯ã‚’æ±‚ã‚ã¦è¨˜éŒ²ã™ã‚‹ã€‚
    3. å¹¹ç·šé“è·¯ A ã®ã€ã•ã‚‰ã«æ¬¡ã®äº¤å·®ç‚¹ã¾ã§ã®çµŒè·¯ã¯ã€å¹¹ç·šé“è·¯ A ã®ç›´å‰ã®äº¤å·®ç‚¹ã‹ã‚‰ã¾ã£ã™ãé€²ã‚€ã®ãŒé€Ÿã„ã‹ã€ç›´å‰ã® B ã®äº¤å·®ç‚¹ã‹ã‚‰ã¾ã£ã™ãé€²ã‚“ã§ä¹—ã‚Šæ›ãˆã‚‹ã®ãŒæ—©ã„ã‹èª¿ã¹ã¦ã€
    ã€€ã€€æ—©ã„ã»ã†ã‚’æ¡ç”¨ã™ã‚‹ã€‚é€†å´ã®äº¤å·®ç‚¹ã«ã¤ã„ã¦ã‚‚åŒã˜ã“ã¨ã‚’ã™ã‚‹ã€‚
    4. ã“ã‚Œã‚’ç›®çš„åœ°ã¾ã§ç¹°ã‚Šè¿”ã™ã€‚
    5. ç›®çš„åœ°ã¾ã§ç¹°ã‚Šè¿”ã—ãŸã‚‰ã€2 ã¤ã®çµŒè·¯ã®ã†ã¡æ—©ã„æ–¹ãŒæˆ‘ã€…ã®ã¨ã‚‹ã¹ãæœ€çŸ­çµŒè·¯ã§ã‚ã‚‹ã€‚
-}

--- Â¶ã€€é“è·¯ç¶²ã‚’ Haskell ã§è¡¨ç¾ã™ã‚‹
{-
    ã©ã†ã™ã‚Œã°ã“ã®é“è·¯ç¶²ã‚’ Haskell ã§è¡¨ç¾ã§ãã‚‹ã ã‚ã†ã‹ï¼Ÿ
    3 ã¤ã®æ‰€è¦æ™‚é–“ã‚’ 1 çµ„ã¨ã—ã¦èª¿ã¹ã‚Œã°ã‚ˆã„ã€‚
    å¹¹ç·šé“è·¯ A ã®ã‚ã‚‹ãƒ‘ãƒ¼ãƒ„ã€å¹¹ç·šé“è·¯ B ã®åŒã˜ãƒ‘ãƒ¼ãƒ„ã€ãã—ã¦ 2 ã¤ã®ãƒ‘ãƒ¼ãƒ„ã¨æ¥ç¶šã—æ©‹æ¸¡ã—ã‚’ã—ã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ„ C ã§ã‚ã‚‹ã€‚

    ã¤ã¾ã‚Šã€

    --
      |
      |
    --

    ã“ã‚Œå˜ä½ã§è€ƒãˆã‚‹ã¨ã„ã†ã“ã¨ã€‚

    ãƒ‡ãƒ¼ã‚¿å‹ã¯ã§ãã‚‹ã ã‘ã‚·ãƒ³ãƒ—ãƒ«ã«ã—ã‚ˆã†ï¼ˆã§ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªã‚‰ã„ã„ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ï¼‰ã€‚
-}

data Section = Section { getA :: Int, getB :: Int, getC :: Int}
    deriving (Show)

type RoadSystem = [Section]
    -- é“è·¯ç¶² RoadSystem ã¯é“è·¯ Section ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€ã¨ã„ã†å‹ã‚·ãƒãƒ‹ãƒ 

-- ãƒ’ãƒ¼ã‚¹ãƒ­ãƒ¼ç©ºæ¸¯ã‹ã‚‰ãƒ­ãƒ³ãƒ‰ãƒ³ã¾ã§ã®é“è·¯ç¶²ã¯æ¬¡ã®ã‚ˆã†ã«è¡¨ã›ã‚‹ã€‚
heathrowToLondon :: [Section]
heathrowToLondon = [ Section 50 10 30
                   , Section 5 90 20
                   , Section 40 2 25
                   , Section 10 8 0
                   ]


--- Â¶ã€€æœ€çŸ­çµŒè·¯é–¢æ•°ã‚’æ±‚ã‚ã‚ˆï¼
{-
    ã©ã‚“ãªé“è·¯ç¶²ã«å¯¾ã—ã¦ã‚‚æœ€çŸ­çµŒè·¯ãŒè¨ˆç®—ã§ãã‚‹é–¢æ•°ã¯ã€ã©ã‚“ãªå‹å®£è¨€ã«ã™ã‚Œã°ã‚ˆã„ã ã‚ã†ï¼Ÿ
    ãã®é–¢æ•°ã¯ã€é“è·¯ç¶²ã‚’å¼•æ•°ã¨ã—ã¦å–ã£ã¦çµŒè·¯ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚
    çµŒè·¯ã‚‚ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã—ã‚ˆã†ã€‚
    A, B, C ã‚’åˆ—æŒ™ã—ãŸã ã‘ã® Label å‹ã‚’å°å…¥ã™ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚ãã‚Œã‹ã‚‰ã€Path ã¨ã„ã†åå‰ã®å‹ã‚·ãƒãƒ‹ãƒ ã‚’ä½œã‚ã†ã€‚
-}

data Label = A | B | C deriving (Show)
type Path = [(Label, Int)]

{-
    ã¨ã„ã†ã“ã¨ã§ã€ã“ã‚Œã‹ã‚‰ä½œã‚‹é–¢æ•° optimalPath ã®å‹ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã¯ãšã€‚

        ```
        optimalPath :: RoadSystem -> Path
        ```

    heathrowToLondon ã¨ã„ã†åå‰ã®é“è·¯ç¶²ã‚’å¼•æ•°ã«ã—ã¦å‘¼ã³å‡ºã—ãŸã‚‰ã€ä»¥ä¸‹ã®ã‚ˆã†ãªçµŒè·¯ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚

        [(B,10), (C,30), (A,5), (C,20), (B,2), (B,8)] // ã“ã‚Œã®å‹ã¯ Path ã¤ã¾ã‚Š [(Label, Int)]

    é“è·¯ A ã§ã®æœ€çŸ­çµŒè·¯ã¨é“è·¯ B ã§ã®æœ€çŸ­çµŒè·¯ã‚’ä¿æŒã—ãªãŒã‚‰ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒªã‚¹ãƒˆã‚’å·¦ã‹ã‚‰å³ã¸ã¨è¾¿ã£ã¦ã„ã“ã†ã€‚
    ãƒªã‚¹ãƒˆã‚’ãŸã©ã‚ŠãªãŒã‚‰æœ€å–„ã®çµŒè·¯ã‚’ãŸã‚ã¦ã„ãã€‚ã“ã‚Œã£ã¦ãªã‚“ã ã‚ã†ï¼Ÿã€€æ­£è§£ã¯å·¦ç•³ã¿è¾¼ã¿ï¼

    æ‰‹è¨ˆç®—ã§è§£ã‚’æ±‚ã‚ãŸã¨ãã¯ã€ã‚ã‚‹ã‚¹ãƒ†ãƒƒãƒ—ã‚’ä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã—ãŸã€‚ç›´å‰ã® A ã¨ B ã¾ã§ã®æœ€é©çµŒè·¯ã€ãã‚Œã«ç¾åœ¨ã®é“è·¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚‚ã¨ã«ã€
    A ã¨ B ã®æ–°ã—ã„æœ€é©çµŒè·¯ã‚’æ±‚ã‚ã‚‹ã¨ã„ã†ã‚¹ãƒ†ãƒƒãƒ—ã§ã‚ã‚‹ã€‚é–‹å§‹æ™‚ç‚¹ã§ A ã¨ B ã«å¯¾å¿œã™ã‚‹æœ€é©çµŒè·¯ã¯ [] ã¨ [] ã§ã‚ã‚‹ã€‚
    ãã—ã¦ Section 50 10 30 ã¨ã„ã†ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’èª­ã¿è¾¼ã¿ã€A1 ã¸ã®æœ€é©çµŒè·¯ã¯ [(B,10), (C,30)] ã§ã‚ã‚Šã€B1 ã¸ã®æœ€é©çµŒè·¯ã¯ [(B,10)] ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’æ±‚ã‚ãŸã€‚
    ã“ã®æ‰‹ç¶šãã‚’é–¢æ•°è¦–ç‚¹ã§è¦‹ã‚‹ã¨ã€çµŒè·¯ã®ãƒšã‚¢ã¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¼•æ•°ã«å–ã£ã¦æ–°ã—ã„çµŒè·¯ã®ãƒšã‚¢ã‚’è¿”ã™é–¢æ•°ã«ãªã£ã¦ã„ã‚‹ã€‚
    ã¨ã„ã†ã“ã¨ã¯ã€ãã®å‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã§ã‚ã‚‹ã€‚

        ```
        roadStep :: (Path, Path) -> Section -> (Path, Path)
        ```
    ã“ã®é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ã¿ã‚ˆã†ã€‚
-}

roadStep :: (Path, Path) -> Section -> (Path, Path)
roadStep (pathA, pathB) (Section a b c) =
    let timeA = sum (map snd pathA)
        timeB = sum (map snd pathB)
        forwardTimeToA = timeA + a
        crossTimeToA = timeB + b + c
        forwardTimeToB = timeB + b
        crossTimeToB = timeA + a + c
        newPathToA = if forwardTimeToA <= crossTimeToA
                        then (A, a):pathA -- ãªãœ pathA ++ [(A,a)] ã¨ã›ãšã«è¦ç´ ã‚’å‰ã‹ã‚‰è¿½åŠ ã—ã¦ã„ã‚‹ï¼Ÿâ†’ãƒªã‚¹ãƒˆã®å…ˆé ­ã«è¿½åŠ ã™ã‚‹ã»ã†ãŒã€æœ«å°¾ã«è¿½åŠ ã™ã‚‹ã‚ˆã‚Šã‚‚ãšã£ã¨é€Ÿã„ï¼
                        else (C, c):(B, b):pathB
        newPathToB = if forwardTimeToB <= crossTimeToB
                        then (B, b):pathB
                        else (C, c):(A, a):pathA
    in (newPathToA, newPathToB)

{-
    ä¸Šã®é–¢æ•° roadStep ã«ã¤ã„ã¦ã¯ã€é–¢æ•°ã‚’èª­ã‚“ã§ã®ã¨ãŠã‚Šã ãŒã€ä¸æ˜ç‚¹ãŒã‚ã‚Œã°ãƒ†ã‚­ã‚¹ãƒˆ p222-223 ã¸ã€‚
    ğŸ’¡ãªãŠã€ã“ã® roadStep ã®å®Ÿè£…ã§ã¯ã€timeA = sum (map snd patA) ãªã©ã¨ã™ã‚‹ã¨ãã«çµŒè·¯ã®æ‰€è¦æ™‚é–“ã‚’æ¯å›è¨ˆç®—ã—ã¦ã„ã‚‹ã€‚
    ã€€ A ã¨ B ã®æœ€çŸ­çµŒè·¯ã ã‘ã§ãªãã€æœ€çŸ­ã®æ‰€è¦æ™‚é–“ã‚’å¼•æ•°ã«å–ã£ãŸã‚Šè¿”ã—ãŸã‚Šã™ã‚‹ã—ã‚ˆã†ã«ã—ã¦ãŠã‘ã°ã€ã“ã®è¨ˆç®—ã¯ä¸è¦ã€‚

    ã§ã¯ã€ã“ã®é–¢æ•°ã‚’ heathrowToLondon ã®æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦èµ°ã‚‰ã›ã¦ã¿ã‚ˆã†ã€‚
    æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãªã®ã§ã€ç›´å‰ã® A ã¨ B ã¸ã®æœ€çŸ­çµŒè·¯ã«å¯¾å¿œã™ã‚‹å¼•æ•°ã¯ç©ºãƒªã‚¹ãƒˆã®ãƒšã‚¢ã«ãªã‚‹ã€‚
-}

firstRoute :: (Path,Path)
firstRoute = roadStep ([], []) $ head heathrowToLondon -- ([(C,30),(B,10)],[(B,10)])

{-
    çµŒè·¯ã¯é€†è»¢ã—ã¦ã„ã‚‹ã®ã§ã€å³ã‹ã‚‰å·¦ã«èª­ã‚€ã€‚ã¤ã¾ã‚Šã€æ¬¡ã®äº¤å·®ç‚¹ A ã¾ã§ã®æœ€çŸ­è·é›¢ã¯ã€B ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ A ã«ä¹—ã‚Šæ›ãˆã‚‹ï¼ˆC:Cross ã™ã‚‹ï¼‰ã“ã¨ã ã¨ã‚ã‹ã‚‹ã€‚
    ä¸€æ–¹ã€æ¬¡ã® B ã¾ã§ã®æœ€çŸ­çµŒè·¯ã¯ã€å˜ã« B ã‚’ç›´é€²ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚

    çµŒè·¯ã®ãƒšã‚¢ã¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–ã£ã¦æœ€é©çµŒè·¯ã‚’è¿”ã™é–¢æ•°ãŒã§ããŸã¨ã“ã‚ã§ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒªã‚¹ãƒˆã«å·¦ç•³ã¿è¾¼ã¿ã‚’æ–½ã™ã®ã¯ç°¡å˜ã§ã‚ã‚‹ã€‚
    roadStep ã¯ã€([], []) ã¨æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¼•æ•°ã«ã—ã¦å‘¼ã°ã‚Œã€ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¾ã§ã®æœ€é©çµŒè·¯ã‚’æ±‚ã‚ã‚‹ã€‚
    æ¬¡ã«ã€ãã®æœ€é©çµŒè·¯ã¨æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¼•æ•°ã« roadStep ãŒã¾ãŸå‘¼ã°ã‚Œã¦ã€â€¦ã¨ç¶šãã€‚
    ã™ã¹ã¦ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ­©ãçµ‚ã‚ã£ãŸã‚‰ã€æœ€å¾Œã«æœ€é©çµŒè·¯ã®ãƒšã‚¢ãŒæ®‹ã‚‹ã€‚
    ãã—ã¦ã€2 ã¤ã®ã†ã¡çŸ­ã„ã»ã†ãŒç­”ãˆã§ã‚ã‚‹ã€‚ã“ã‚Œã‚’å¿µé ­ã« optimalPath ã‚’å®Ÿè£…ã—ã‚ˆã†ã€‚
-}

optimalPath :: RoadSystem -> Path
optimalPath roadSystem =
    let (bestAPath, bestBPath) = foldl roadStep ([], []) roadSystem
    in if sum (map snd bestAPath) <= sum (map snd bestBPath)
            then reverse bestAPath -- ã“ã®æ™‚ç‚¹ã§ã®çµŒè·¯ã¯é€†è»¢ã—ã¦ã„ã‚‹ï¼ˆ(A,a):pathA ã¨ã„ã†ãµã†ã«å‰ã«å‰ã«è¿½åŠ ã—ã¦ã„ã£ãŸã‹ã‚‰ï¼‰
            else reverse bestBPath

{-
    ã“ã®é–¢æ•°ã§ã¯ã€ç©ºãƒªã‚¹ãƒˆã®ãƒšã‚¢ã‚’åˆæœŸã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ã€roadSystemï¼ˆã“ã‚Œã¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒªã‚¹ãƒˆã ã£ãŸï¼‰ã‚’å·¦ç•³ã¿è¾¼ã¿ã—ã¦ã„ã‚‹ã€‚
    ãã®çµæœã¯çµŒè·¯ã®ãƒšã‚¢ã ã‹ã‚‰ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’ä½¿ã£ã¦ 2 ã¤ã®çµŒè·¯ã®æœ¬ä½“ã‚’å–ã‚Šå‡ºã™ã€‚
    ãã‚Œã‹ã‚‰ã©ã¡ã‚‰ã®æ‰€è¦æ™‚é–“ãŒçŸ­ã„ã‹ã‚’åˆ¤å®šã—ã¦è¿”ã™ã€‚
    çµŒè·¯ãƒªã‚¹ãƒˆã®åºƒå ±ã§ã¯ãªãå‰æ–¹ã¸è¿½è¨˜ã—ã¦ã„ãå®Ÿè£…ã‚’é¸ã‚“ã ã“ã¨ã‹ã‚‰ã€ã“ã®æ™‚ç‚¹ã§ã®çµŒè·¯ã¯é€†è»¢ã—ã¦ã„ã‚‹ã®ã§ã€è¿”ã™å‰ã«é€†é †ã«ã—ã¦ã„ã‚‹ã€‚
    ã§ã¯è©¦ã—ã¦ã¿ã‚ˆã†ï¼
-}

optPath :: Path
optPath = optimalPath heathrowToLondon -- [(B,10),(C,30),(A,5),(C,20),(B,2),(B,8),(C,0)]

{-
    ã“ã®çµæœãŒã¾ã•ã«æ¬²ã—ã‹ã£ãŸçµæœã§ã‚ã‚‹ï¼
-}

--- Â¶ã€€å…¥åŠ›ã‹ã‚‰é“è·¯ç¶²ã‚’å—ã‘å–ã‚‹
{-
    æœ€çŸ­çµŒè·¯ã‚’æ±‚ã‚ã‚‹é–¢æ•°ã¯ã§ããŸã€‚ã‚ã¨ã¯ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§è¡¨ç¾ã•ã‚ŒãŸé“è·¯ç¶²ã‚’æ¨™æº–å…¥åŠ›ã‹ã‚‰èª­ã¿è¾¼ã‚“ã§ RoadSystem å‹ã«å¤‰æ›ã—ã€optimalPath é–¢æ•°ã«ã‹ã‘ã¦ã€å¾—ã‚‰ã‚ŒãŸçµŒè·¯ã‚’è¡¨ç¤ºã™ã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
    ã¾ãšã€ãƒªã‚¹ãƒˆã‚’å–ã‚Šã€ã‚ã‚‹è¦ç´ æ•°ã®ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«åˆ†å‰²ã™ã‚‹é–¢æ•°ã‚’ä½œã‚ã†ã€‚åä»˜ã‘ã¦ groupsOf ã§ã‚ã‚‹ã€‚
-}

groupsOf :: Int -> [a] -> [[a]]
groupsOf 0 _ = undefined
groupsOf _ [] = []
groupsOf n xs = take n xs : groupsOf n (drop n xs) -- ã‚„ã£ã±ã‚Šã“ã‚Œã‚‚å†å¸°çš„ã€‚n å€‹ãšã¤ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«åˆ†ã‘ã‚‹ã®ã§ã€n å€‹å–ã£ãŸã‚‰ã¾ãŸã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã€ã•ã‚‰ã« n å€‹å–ã£ãŸã‚‰ã¾ãŸã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã€ã€ã¨ã‚„ã£ã¦ã„ãã€‚

-- ä¾‹
groupsOf3 :: [[Int]]
groupsOf3 = groupsOf 3 [1..10] -- [[1,2,3],[4,5,6],[7,8,9],[10]]

{-
    æº–å‚™ã¯æ•´ã£ãŸï¼
    ã„ã‚ˆã„ã‚ˆä»¥ä¸‹ãŒã€æ¨™æº–å…¥åŠ›ã‚’èª­ã¿å–ã£ã¦ RoadSystem ã‚’ä½œã‚Šã€æœ€çŸ­çµŒè·¯ã‚’å‡ºåŠ›ã™ã‚‹ main é–¢æ•°ã§ã‚ã‚‹ã€‚
-}

-- import Data.List
main :: IO ()
main = do
    contents <- getContents
    let threes = groupsOf 3 (map read $ lines contents)
        roadSystem = map (\[a,b,c] -> Section a b c) threes
        path = optimalPath roadSystem
        pathString = concat $ map (show . fst) path
        pathTime = sum $ map snd path
    putStrLn $ "The best path to take is: " ++ pathString
    putStrLn $ "Time taken: " ++ show pathTime

{-
    $ stack runhaskell src/10_functionally_solving_problems.hs < src/paths.txt
    The best path to take is: BCACBBC
    Time taken: 75

    ğŸ‘€ stack runhaskell ã£ã¦ã‚³ãƒãƒ³ãƒ‰ä»Šã¾ã§çŸ¥ã‚‰ãªã‹ã£ãŸã€‚ã€‚ï¼
-}

{-
    ğŸ† ã€€Tips
        ï¼ˆã‚‚ã£ã¨é•·ã„é“è·¯ç¶²ã‚’ç”Ÿæˆã—ã¦è©¦ã—ã¦ã¿ã‚‹ã¨ãã®ãŸã‚ãªã©ï¼‰ã‚¹ã‚¿ãƒƒã‚¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒå‡ºãŸã‚‰ foldl ã‚’ foldl' ã«å¤‰ãˆã€sum ã‚’ foldl' (+) 0 ã«å¤‰ãˆã¦ã¿ã‚ˆã†ã€‚
        ã¾ãŸã¯ã€å®Ÿè¡Œå‰ã« `ghc -O hogehoge.hs` ã¨ã„ã†å…·åˆã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã€‚
        ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã« -O ãƒ•ãƒ©ã‚°ã‚’å«ã‚ã‚‹ã¨ã€æœ€é©åŒ–ãŒåƒã„ã¦ã€foldl ã‚„ sum ã¨ã„ã£ãŸé–¢æ•°ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ã«ãããªã‚‹ã€‚
-}
