{-# OPTIONS -Wall -Werror #-}

---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---
--   　　　　関数型問題解決法　　　　    --
---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---

-------------------------------
--　逆ポーランド記法電卓
-------------------------------
{-
    ふつう、算数では中置記法で式を書く。10 - (4 + 3) * 2 という具合に。
    足し算（+）、掛け算（*）、引き算（-）などは、Haskell の中置関数（+ とか `elem`とか）と同じく、中置演算子である。
    人間は中置記法の数式をいとも簡単に脳内で parse できる。
    欠点は、演算の優先順位を指定するのに括弧が必要になるということだ。

    数式を書く別の方法として **逆ポーランド記法（reverse polish notation）**、略して RPN がある。
    RPN では、演算子は数に挟まれるのではなく、数の後に来る。
    4 + 3 と書く代わりに 4 3 + と書くわけである。
    では複数の演算子を含む数式はどのように書くのだろう？　答えは簡単。 4 3 + 10 * と書く。ここで 4 3 + は 7 なので、数式全体は 7 10 * と等価になる。
-}

--- ¶　RPN 記法の式を計算
{-
    RPN 記法を計算する方法を感覚的につかむには、数のスタックをイメージする。RPN 記法は、左から右に（＝普通に）読む。数を読み込んだら、それをスタップのてっぺんに積む（push）。
    演算子を読み込んだら、スタックのてっぺんから 2 つの数を取り出し（pop）、その 2 つの数に演算子を施して、演算結果をスタックに積み直す。
    式の末尾にたどり着いたら、計算結果を示す数が 1 つだけスタックに残っているはずである。

    例えば、RPN 式 10 4 3 + 2 * - をどうやって評価するのか見ていこう。
    →   1. まず 10 をスタックに積み、スタックは 10 が 1 つ入った状態になる。
        2. 次のアイテムは 4 なので、これもスタックに積む。今のスタックは 10, 4 である。
        3. 3 にも同じことをしてスタックは 10, 4, 3 になる。
        4. 演算子が出てきた。+。そこでスタックから 2 つの数を取り出し（スタックは 10 だけになる）、取り出した 2 つの数を加算し、計算結果をスタックに戻す。
        　　こうしてスタックは 10, 7 になる。
        5. 次にスタックに 2 を積み、スタックは 10, 7, 2 になる。
        6. また演算子がきた。7 と 2 をスタックから取り出し、掛け算して、結果をスタックに戻す。7 * 2 は 14 だから、スタックは 10, 14 になる。
        7. 最後に - がある。10 と 14 をスタックから取り出し、10 から 14 を引いて、スタックに戻す。
        8. スタックに乗っている数は -4。与えられた式にはもう数も演算子も残っていないので、これが答えである。 

    これが RPN 式を手で計算する方法である。では、Haskell で同じことをするにはどうすればいいか？
-}

--- ¶ RPN 関数を書く
{-
    "10 4 3 + 2 * -" のような RPN 式を文字列で受け取って、その式の結果を返す関数を書こう。
    この関数の型はどうなるか？　「文字列を引数に取って、数を結果として返す関数」である。
    割り算もできるようにしたいので、結果は倍精度浮動小数がいいだろう。というわけで、型は String -> Double とするのがいいかな。
    　👉 関数の実装に取り掛かる前に、まず関数んお型宣言がどうなるか考えるのはとても役に立つ習慣である！

    では、RPN を解く関数をどう書けばいいか考えていく。手計算したときは、空白で区切られた数や演算子のそれぞれを 1 つのアイテムとして扱った。
    ということは、 "10 4 3 + 2 * -" のような文字列を、まずはアイテムのリストに分割することから始めるとよさそう。
        ["10", "4", "3", "+", "2", "*", "-"]
    それから、このリストを左から右へと走査して、その間スタックを更新し続けたんだった。
    これは畳み込み（リストを一要素ごとに走査しながら何らかの結果を積み上げていく（アキュムレート））に似ている！

    今回の場合、リストを左から右へ走査するので、左畳み込みを使おう。
    アキュムレータ値はスタックなので、畳み込みが返す結果もスタックになるはずである。
    ただし、すでに見たように値が 1 つしか入っていないスタックである。

    もう 1 つ、スタックをどのように表現するかも考える必要がある。
    リストを使って、リストの先頭をスタックの先頭に対応させるのがいいだろう。リストの先頭（head）に要素を追加するのは、末尾に追加するよりずっと高速だからだ。
    例えば 10, 4, 3 というスタックは 3:4:10:[] すなわち [3,4,10] というリストとして表現することになる。

    これで作りたい関数の姿がおぼろげながら見えてきた。まずその関数は "10 4 3 + 2 * -" といった文字列を取り、それを words を使ってアイテムのリストに分解する。
    次に、そのリストに左畳み込みを使って、単一の要素が入ったスタック（この例の場合は、[-4]）にたどりつく。
    その単一要素をリストから取り出して、それがファイナルアンサーである！

    以下がその関数のスケッチである。
        solveRPN :: String -> Double
        solveRPN expression = head $ foldl foldingFunction [] (words expression)
            where foldingFunction stack item = ...

    この関数は expression を取って、まずアイテムのリストに変える。それからそのアイテムのリストを関数 foldingFunction で畳み込む。
    [] はアキュムレータの初期値である。アキュムレータはスタックなので、[] は空のスタックを表している。
    そして単一要素の入った最終状態のスタックを受け取ったら、head を使ってアイテムを取り出す。

    さて、あとは畳み込み処理を行う関数を書くだけである。
    その関数は、たとえばスタック [4,10] とアイテム "3" を受け取って、新しいスタック [3,4,10] を返す。
    また、スタックが [4,10] で、受け取ったアイテムが "*" なら、関数は [40] を返すべきである。

    とりあえず、畳み込み関数を書く前に、全体の関数をポイントフリースタイルで書き直しておく。

        solveRPN :: String -> Double
        solveRPN = head . foldl foldingFunction [] . words
            where foldingFunction stack item = ...

    畳み込み関数は、スタックとアイテムを受け取って新しいスタックを返すようにする。
    関数定義構文でパターンマッチを使い、スタックの上側にあるアイテムを取り出す処理と "*" や "-" のような演算子を識別する処理を一気にやろう。

        foldingFunction (x:y:ys) "*" = (y * x):ys
        foldingFunction (x:y:ys) "+" = (y + x):ys
        foldingFunction (x:y:ys) "-" = (y - x):ys
        foldingFunction xs numberString = read numberString:xs
-}

solveRPN :: String -> Double
solveRPN = head . foldl foldingFunction [] . words
    where   foldingFunction (x:y:ys) "*" = (y*x):ys
            foldingFunction (x:y:ys) "+" = (y+x):ys
            foldingFunction (x:y:ys) "-" = (y-x):ys
            foldingFunction xs numberString = read numberString: xs

{-
    この関数で遊んでみよう。

    *Main> solveRPN "10 4 3 + 2 * -"
    -4.0

    *Main> solveRPN "2 3.5 +"
    5.5

    *Main> solveRPN "90 34 12 33 55 56 + * - +"
    -3617.0

    *Main> solveRPN "90 34 12 33 55 66 + * - +"
    -3947.0

    *Main> solveRPN "90 34 12 33 55 66 + * - + -"
    4037.0

    *Main> solveRPN "90 3.8 -"
    86.2
-}

--- ¶　演算子を追加しよう
{-
    この解法の何が良いかというと、他のいろんな演算を簡単にサポートできるところである。
    二項演算子である必要もない。
    例えば、数を 1 つだけ取り出してその対数を積む "ln" という演算も作れる。
    可変長引数を取る演算子だって作れる。
    例えば "sum" はスタックからすべての数を取り出してその総和を積む演算である。

    RPN 電卓関数を修正してもっと多くの演算子をサポートするようにしよう。
-}

solveRPN' :: String -> Double
solveRPN' = head . foldl foldingFunction [] . words
    where   foldingFunction (x:y:ys) "*" = (y * x):ys
            foldingFunction (x:y:ys) "+" = (y + x):ys
            foldingFunction (x:y:ys) "-" = (y - x):ys
            foldingFunction (x:y:ys) "/" = (y / x):ys
            foldingFunction (x:y:ys) "^" = (y ** x):ys
            foldingFunction (x:xs) "ln" = log x:xs
            foldingFunction xs "sum" = [sum xs]
            foldingFunction xs numberString = read numberString: xs

{-
    *Main> solveRPN' "1 2 sum"
    3.0

    *Main> solveRPN' "2.71828 ln"
    0.999999327347282

    *Main> solveRPN' "10 10 10 10 sum 4 /"
    10.0

    *Main> solveRPN' "10 2 ^"
    100.0

    任意の浮動小数点数の RPN 式を計算できて、しかも用意に拡張できる関数がたったの 10 行で書けるというのはかなり驚異的！
-}