{-# OPTIONS -Wall -Werror #-}

import Data.Char
import Data.List
import Control.Applicative

---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---
--  　　 ファンクターからアプリカティブファンクターへ　　　　    --
---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---

{-
    純粋性、高階関数、型引数を取る代数的データ型（parameterized algebraic data types）、型クラスを兼ね備える Haskell では、
    他のプログラミング言語よりずっと簡単に多相性を実現できる。
    型の巨大な階層構造に気を揉む必要はない。その代わり、これらの型はどのように振る舞うか？　と考えて、適切な型クラスに関連づければよいのである。

    例えば、Int はさまざまな「もの」のように振る舞う。
    同じかどうか判定できるもの、順序が着いたもの、列挙できる（数え上げられる）もの、などなど。

    型クラスはオープンである。つまりデータ型を定義し、その型がどう振る舞うかを考えてから、その振る舞いを定義する型クラスに属させることができるのである。
    このオープンな型クラスと、関数の型宣言だけから多くのことを読み取れる Haskell の強力な型システムのおかげで、
    とても一般的で抽象的な振る舞いを定義する型クラスが作れる。

    これまでに、2 つのものが等しいかどうか判定する操作や、2 つのものを何らかの順序で比較する操作を定義する型クラスを見てきた。
    こういうと抽象的で高尚に聞こえるが、等号や比較は日常的にも使う操作で、とりわけ特別なことでもない。
    それから、第 7 章ではファンクターを紹介した。
    ファンクターは、関数を使って全体を写せるもの、という感じだった。
    これもまた型クラスを使って定義できる、便利で、それでいてかなり抽象的な性質の 1 つである。

    この章では、ファンクターをより詳しく見ていく。そして、ファンクターの少し強力でより便利なバージョンであるアプリカティブファンクターも紹介する。
-}

-------------------------------
--　帰ってきたファンクター
-------------------------------

{-
    第 7 章で学んだように、ファンクターとは関数で写せるもののことである。例えば、リスト、Maybe、木などがファンクターである。
    Haskell では、ファンクターは型クラス Functor で表現される。
    ファンクターの型クラスメソッドは 1 つだけで、それは fmap である。
    fmap の型は fmap :: (a -> b) -> f a -> f b である。
    この型の意味は「僕に『a を取って b を返す関数』と a の入った箱を渡して。そうしたら b の入った箱にして返すよ」という感じである。
    箱 f の中の要素に関数を適用してくれるのである。

    ファンクターは **文脈** を持った値だとみなすこともできる。例えば、Maybe 値は「計算が失敗したかもしれない」という文脈を、
    リストは「複数の値を同時に取るかもしれない」という文脈を持つ。
    fmap は、こういった文脈を保ったまま関数を値に適用するのである。

    型コンストラクタを Functor のインスタンスにするには、その型コンストラクタの種類（kind）は * -> * でなければならない。
    つまり、その型コンストラクタは、型変数として具体型をただ 1 つ取る必要がある。
    例えば Maybe は、Maybe Int や Maybe String のように 1 つの型変数を取って具体型を生むので、ファンクターになれる。
    これに対して、Either のような 2 つの型変数を取る型コンストラクタをファンクターにするには、部分適用をして、あと 1 つだけ型変数を引数に取る状態にしないといけない。

    というわけで、`instance Functor Either where` は **間違い** だが、`instance Functor (Either a) where` は正しいインスタンス宣言である。
    そして、fmap は Either a に働くのだと考えれば、次のような型になることがわかる。
        fmap :: (b -> c) -> Either a b -> Either a c
    fmap の前後で Either a の部分は普遍であり、Either a のただ 1 つの変数の部分が変化している。

            〜〜ここまでは第 7 章で学んだ内容〜〜
-}

--- ¶　ファンクターとしての I/O アクション
{-
    これまで実に多くの方（型コンストラクタ）が Functor のインスタンスであることを見てきた。
    []、Maybe、Either a、それから第 7 章で作った Tree などである。
    a -> b 型の関数を使って [a], Maybe a, Either a1 a, Tree a などの型をも写せるのはとても便利だった。
    今度は IO インスタンスを見てみよう。

    例えば、IO String という型は、実行すると、外の世界に出かけて行って文字列を取ってきてくれて、
    それを返してくれるような I/O アクションを表している。
    取得結果は、do 記法の中で <- 構文を使って名前に束縛できる。
    第 8 章では、I/O アクションとは小さな足の生えた箱で、外の世界に出かけて行って何か値を入れて帰ってきてくれるのだ、という比喩を使った。

    我々は IO が取ってきてくれた値を調べることができるが、調べた後はまた IO の中に戻さなくてはいけない。
    この「足の生えた箱」のたとえで、IO がファンクターの一種であることが理解できる。

    IO の Functor インスタンスがどのように定義されているか見てみよう。
    ある関数をある I/O アクションに fmap すると「元の I/O と同じことをしつつ、その結果に指定した関数を適用して返す」I/O アクションになってほしいわけである。
    以下が実装である。
        instance Functor IO where
            fmap f action = do
                result <- action
                return (f result)

    I/O アクションを関数で写した結果もまた I/O アクションなので、まずは脊髄反射的に do 構文を使う。
    この中で 2 つのアクションを貼り付けて新しい I/O アクションを作ればいいはずである。
    fmap を実装するには、まずもともとの I/O アクションを実行して結果を result と名付ける。
    次に return (f result) を行う。return とは、すでに学んだが「特に仕事を行わず、ただ何かを結果として提示する I/O アクション」を作る関数。

    do ブロックで組み立てたアクションは常に最後のアクションの結果を提示する。
    それゆえ、return を使って仕事をしないアクションを作り、f result を do ブロック全体の結果として提示させるわけである。
    以下のコードを見よ。
-}

--- runhaskell で実行するときは名前を main1 から main にすること。
main1 :: IO ()
main1 = do
    line <- getLine
    let line' = reverse line
    putStrLn $ "You said " ++ line' ++ " backwards!"
    putStrLn $ "Yes, you said " ++ line' ++ " backwards!" -- これなに（なんで 2 回同じ出力？）

{-
    ユーザーに文字列を入力してもらい、それを逆順にして表示している。
    これは fmap を使うと以下のように書ける。
-}

main2 :: IO ()
main2 = do
    line <- fmap reverse getLine
    putStrLn $ "You said " ++ line ++ " backwards!"
    putStrLn $ "Yes, you really said " ++ line ++ " backwards!" -- これなに（なんで 2 回同じ出力？）

{-
    Just "blah" を fmap reverse して Just "halb" を作るのと同じように、getLine を fmap reverse できるのである。
    getLine は IO String の型を持つ IO アクションであるから、それを fmap reverse すると、外の世界に出かけていって文字列を 1 行入力してもらって、
    その結果に reverse を適用する I/O アクションになる。
    Maybe という箱に入っている値に関数を適用できるのと同様に、IO という箱の中に入っている値に関数を適用できるわけだが、
    fmap した結果も IO なので、そいつもやはり外の世界に出かけて行って何か値を取ってくるという動作をするわけである。
    その後、reverse を適用済みの値を、<- を使って line という名前に束縛している。

    ほかにも、fmap (++ "!") getLine という I/O アクションは getLine とほぼ同じ動作をするが、入力された文字列の末尾に "!" をつける。
    仮に fmap が IO に限定されていたら、fmap の型は fmap :: (a -> b) -> IO a -> IO b になる。
    fmap は、a -> b な関数と IO a な I/O アクションを取って、「それとよく似た動作をして中身の値ん関数を適用するような I/O アクション」を返す関数である。

    もし自分のコードに、何らかの関数に渡すだけのために I/O の結果に名前をつけている（束縛している；つまり contents <- getLine として contents をそのまま他の関数に渡しているなど）
    箇所があったら、fmap を使ってみよう。そのほうがきれいに書ける。
    もしファンクターの中身を、1 つではなく複数の関数を使って写したいなら、そのための関数をトップレベルで宣言してもいいし、ラムダ式を使ってもいいが、一番いいのは関数合成である。
-}

-- import Data.Char
-- import Data.List

main3 :: IO ()
main3 = do
    line <- fmap (intersperse '-' . reverse . map toUpper) getLine -- ※ intersperse '-' "hoge" とすると結果は "h-o-g-e" になる。
    putStrLn line

{-
    使用例：
        stack runhaskell src/11_Functors_and_ApplicativeFunctors.hs
        hello there
        E-R-E-H-T- -O-L-L-E-H
-}

--- ¶　ファンクターとしての関数
{-
    Functor のインスタンスだと知らずに、何気なくずっと使ってきたものがもう 1 つある。その Functor は、`(->) r` である。
    関数の型を表す `r -> a` は、`(->) r a` と書き換えることができるのである（ちょうど 2 + 3 を (+) 2 3 と書き換えることができるように）。
    関数の型を (->) r a と表現するとき、関数 (->) には、2 つの型引数を取る型コンストラクタという新しい姿が与えられているのである。Either と同じだ。

    ただし、Functor のインスタンスにする型コンストラクタは引数が 1 つである必要がある。
    だから、(->) という形のままでは Functor にはできない。部分適用して (->) r の形にすれば大丈夫。
    セクション（第 5 章。テキスト p.64）が使えれば、型コンストラクタの部分適用 (->) r を (r ->) と書き換えたいところだが、これは文法的にまずい。

    さて、関数がファンクターであるとはどういうことなのだろうか？
    インスタンス宣言の実装を覗いてみよう。

        instance Functor ((->) r) where
            fmap f g = (\x -> f (g x))

    まず、fmap の型を思い出そう。
        fmap :: (a -> b) -> f a -> f b

    ファンクターのインスタンスは上記の f の場所に入るので、頭の中で f を (->) r に置換してみよう。
    すると、関数をファンクターのインスタンスにしたとき fmap がどのような型になるかわかる。
        fmap :: (a -> b) -> ((->) r a) -> ((->) r b)

    さらに、(->) r a と (->) r b　という表記を、普通の中置表記 r -> a と r -> b に直そう。
        fmap :: (a -> b) -> (r -> a) -> (r -> b)

    fmap を使うと、Maybe は Maybe を生み出し、リストはリストを生み出した。Functor としての関数も、関数を取って関数を生み出すはずだ。
    ならば、型 fmap :: (a -> b) -> (r -> a) -> (r -> b) が意味するものとは？

    この型は、a から b への関数と、r から a への関数を引数に取り、r から b への関数を返す、と読める。
    何か思い出さないだろうか？　そう、関数合成である。

    このインスタンス宣言はこう書いてもよいかもしれない。

        instance Functor ((->) r) where
            fmap = (.)

    こう書くと、fmap が関数ファンクターの場合には関数合成を意味することがはっきりする。
    関数ファンクターのインスタンス定義は Control.Monad.Instances から読み込めるので、試しに使ってみよう。

        *Main> :t fmap (*3) (+100)
        fmap (*3) (+100) :: Num b => b -> b
        *Main> fmap (*3) (+100) 1
        303
        *Main> (*3) `fmap` (+100) $ 1
        303
        *Main> fmap (show . (*3)) (+100) 1
        "303"

    入力の 3 行目では、fmap を中置関数として読んでいる。こうすると、fmap と . が同じだということがはっきりする。
    入力の 2 行目では (*3) で (+100) を写している。その結果は「入力を (+100) して (*3) する関数」になる。
    それをさらに 1 に作用されると、答えは 303 になる。

    他のファンクターと同様、関数ファンクターも文脈を持った値だとみなせる。
    Maybe との対比で考えてみよう。Maybe ファンクターは、「値があるかもしれない」という文脈を表し、具体化した Maybe a は
    「a 型の値があるかもしれない」という文脈だった。それに対して、関数ファンクター (->) r （あるいは r ->）は、
    「r 型の入力を適用すれば結果が返ってくる」という文脈を表し、それを具体化した (->) r a（あるいは r -> a）は、
    「r 型の入力を適用すれば a 型の結果が返ってくる」という文脈を表している。

    例えば関数 (+3) :: Int -> Int は、その関数の返り値である Int 型の値に、「結果が欲しければ Int 型に適用しろ」という文脈がついたものとみなせる。
    fmap (*3) を (+100) に使うと、(+100) の処理をした後で結果を返す前に (*3) を適用する、新しい関数が生まれる。

    fmap を関数に適用すると関数合成になるというのは、今のところあまり役に立たないが、興味を惹かれる事実である。
    これについて深く考えると、IO や (->) r のように箱というよりは計算のように振る舞うものがファンクターになれる理由がわかってくる。

    「ある関数」を使って「何らかの計算」を写すと、得られるものは「似たような計算」だが、計算結果はその「関数」で修飾されたものになっているのである。
-}

{-
    さて、fmap が従うルールの説明に移る前に、もう一度 fmap の型について考えておこう。
        fmap :: (Functor f) => (a -> b) -> f a -> f b
    第 5 章では、Haskell の関数は実はすべて 1 引数関数とみなせる、というカリー化の概念を導入した。
    a -> b -> c 型の関数は、a 型の引数を 1 つだけ取る関数で、返り値は b -> c 型の関数である。
    これがまた 1 つだけ引数を取って、c 型の値を返す。

    これを、多引数関数を認める立場から見れば、ある関数を一部の引数しか与えないで呼び出す（部分適用）と
    「残りの引数を取って最終結果を返す関数」を返す、と説明できる。
    そこで、a -> b -> c 型は a -> (b -> c) と書ける。こうするとカリー化がはっきりわかる。

    同じように、fmap :: (a -> b) -> f a -> f b の型を持つ fmap も、関数とファンクター値を取ってファンクター値を返す 2 引数関数とも思えるが、
    そうでなく、fmap :: (a -> b) -> (f a -> f b) という見方をすれば、関数を取って「元の関数に似ているけどファンクター値を取ってファンクター値を返す関数」を返す関数だと思うこともできる。
    fmap は、関数 a -> b を取って、関数 f a -> f b を返すのである。
    こういう操作を、関数の持ち上げ（lifting）という。このようなファンクターの見方について、:t コマンドを使って遊びながら覚えよう。

        *Main> :t fmap (*2)
        fmap (*2) :: (Functor f, Num b) => f b -> f b

        *Main> :t fmap (replicate 3)
        fmap (replicate 3) :: Functor f => f a -> f [a]

    式 fmap (*2) は、数が入っているファンクター f を取って、数が入っているファンクターを返す関数である。
    ファンクターは、リストでも Maybe でも Either String でもなんでもかまわない。
    また、式 fmap (replicate 3) は、「なんでもいい型 a が入っているファンクター」を取り、a のリストが入っているファンクターを返す。
    このことは、例えば fmap (++ "!") のような部分適用を作って、それを GHCi で名前に束縛してみるとよくわかる。

        *Main> shout = fmap (++"!")
        *Main> :t shout
        shout :: Functor f => f [Char] -> f [Char]
        *Main> shout ["ha", "ka", "ta", "no"] # リストはファンクター
        ["ha!","ka!","ta!","no!"]
        *Main> shout (Just "hoge") # Just（Maybe）はファンクター
        Just "hoge!"

    というわけで、fmap については 2 通りの考え方ができる。

        - fmap は関数とファンクター値を取って、その関数でファンクター値を写して返すものである。
            - fmap は「文字列の末尾にびっくりマークをつける関数」を取って、その関数で、`文字列のリスト` や `Just 文字列` を写してそれぞれ（末尾にびっくりマークをつけた）`文字列のリスト` や `Just 文字列` を返す。
        - fmap は値から値への関数を取って、それをファンクター値からファンクター値への関数に持ち上げたものを返す関数である。
            - fmap は「文字列の末尾にびっくりマークをつける関数」を取って、それを、「文字列のリストについて、各文字列の末尾にびっくりマークをつけた文字列のリストとして返す関数」に持ち上げたものとして返す（Just 文字列についても同様）。

    そして、どちらの見方も正しい。「関数でファンクター値を写す」ということと、「関数を持ち上げてからファンクター値に適用する」ことは等価でる。

    例えば、関数 fmap (replicate 3) は、その型が fmap (replicate 3) :: (Functor f) => f a -> f [a] であることからわかるように、どんなファンクターにも適用でいる。
    そして、何が起こるかはそのファンクターによって変わる。
    リストに対して fmap (replicate 3) すれば、リスト向けの fmap の実装が選ばれて、それは普通の map である。
    Maybe a に対してfmap (repliate 3) とすれば、Just の中の値に対して replicate 3 が適用される。Nothing なら Nothing である。いくつか例を示す。

        *Main> fmap (replicate 3) [1,2,3,4]
        [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
        *Main> fmap (replicate 3) (Just 10)
        Just [10,10,10]
        *Main> fmap (replicate 3) (Right "blah")
        Right ["blah","blah","blah"]
        *Main> fmap (replicate 3) Nothing
        Nothing
        *Main> fmap (replicate 3) (Left "foo")
        Left "foo"

        🗒 Right と Left に fmap を適用したときの挙動の違いは第 7 章で説明済み。
-}

-------------------------------
--　ファンクター則
-------------------------------

{-
    すべてのファンクターの性質や挙動は、ある一定の法則に従うことになっている。
    fmap f をファンクターに適用したら、それはファンクターの中身に f を適用すべきであって、それ以上のことをしてはいけないのである。
    この挙動は **ファンクター則** に記述されている。
    Functor のインスタンスは、ファンクター則の 2 つの性質（後述）を満たしている必要がある。
    残念ながら、Haskell には自動的にファンクター則を課してくれるような機能はないので、ファンクターを自作するときは、
    ファンクター則を満たしているか、自前でテストしないといけない。
    標準ライブラリにある Functor たちは、すべてファンクター則を満たしている。
-}

--- ¶ 第一法則
{-
    ファンクターの第一法則は、「id でファンクター値を写した場合、ファンクター値が変化してはいけない」というもの。
    式で書くと `fmap id = id` ということである。
    別の言い方をすれば、fmap id をファンクター値に適用した場合、それは di をファンクター値に適用したのと同じ結果になる、ということである。
    id は恒等写像、引数をそのまま返すだけの関数であった。
    id は \x -> x とも書ける。ファンクターは中身に関数が適用されるようなものであると思えば、fmap id = id という法則は、何だか自然で当たり前に思える。
    さて、いくつかのファンクターでこの第一法則を試してみよう。

        *Main> fmap id Just 3
        Just 3
        *Main> id Just 3
        Just 3
        *Main> fmap id [1,2,3]
        [1,2,3]
        *Main> fmap id Nothing
        Nothing

    例えば Maybe ファンクターに対する fmap の実装を見てみると、どうやって第一法則が満たされているかわかる。
        instance Functor Maybe where
            fmap f (Just x) = Just (f x)
            fmap f Nothing = Nothing

    さて、f に id を代入したところをイメージしてみよう。
    id で Maybe ファンクター値を写すとき、Maybe 値の中身は Just 値コンストラクタである場合と Nothing 値コンストラクタである場合がありえる。
    まず Just の場合、fmap id を Just x に適用すると Just (id x) ができる。そして id は恒等写像だから、Just (id x) は Just x である。
    というわけで Just の場合は、確かに fmap id したら元と同じ値が返ってくることがわかった。
    次に、id で Nothing を写した場合は、同じ値が返ってくることは明らかである。
    というわけで、Maybe ファンクターの fmap を実装する 2 つの等式から、Maybe ファンクターは確かにがんクター第一法則 fmap id = id を満たすことがわかった。
-}

--- ¶　第二法則
{-
    第二法則は、関数合成と写す操作との間の関係である。
    第二法則は、2 つの関数 f と g について、「f と g の合成関数でファンクター値を写したもの」と、「まず g、次に f でファンクター値を写したもの」が等しいことを要求する。
    式で書くと、fmap (f . g) = fmap f . fmap g ということ。
    別の言い方をすると、すべてのファンクター値 x に対して fmap (f . g) x = fmap f (fmap g x) が成り立つべし、というのが第二法則である。

    ある型が 2 つのファンクター則を満たすということは、適用に関する基本的な振る舞いが関数や他のファンクターと一致することが保証される、ということである。
    その型に fmap を使ったときに、関数によって写される以外の余計なことが裏で発生することはなく、あくまでも関数の素直な拡張であるファンクターとして振る舞うことがわかるのである。

    ある型がファンクターダイン法則を満たすかどうかは、その型の fmap の実装を見て、それから Maybe が第一法則を満たしているか調べたときと同じ方法を使えばわかる。
    Maybe ファンクターが第二法則を満たしているか調べてみよう。
    まず、Nothing に対して fmap (f . g) を使うと、返り値は Nothing になる（Nothing に対して何を fmap しても Nothing だから）。
    同じ理由から、fmap f (fmap g Nothing) を呼び出しても結果はやはり Nothing になる。
    では、Just の場合はどうだろう？まず fmap (f . g) (Just x) を評価してみる。これは実装から Just ((f . g) x) になり、これは Just (f (g x)) である。
    次に、fmap f (fmap g (Just x)) については、これまた実装に当てはめてみると、はじめに fmap g (Just x) の部分が評価されて Just (g x) になるから、
    fmap f (fmap g (Just x)) は fmap f (Just (g x)) になる。さらに残りを評価するとこれは Just (f (g x)) に等しいことがわかる。
-}

--- ¶　法則を破る
{-
    ここで、Functor のインスタンスなのに、ファンクター則を満たしていないような例を考えてみよう。以下のような型を用意する。
-}

data CMaybe a = CNothing | CJust Int a deriving (Show)

{-
    C は counter のつもり。Cmaybe a は、Maybe a によく似たデータ型だが、Just 部分のフィールドが 1 つではなく 2 つある。
    CJust の 1 つ目のフィールドは常に Int 型で、これが何らかのカウンタになる。
    2 つ目のフィールドの型 a は型引数で、a の型が何になるのかは CMaybe a をどんな具体型にしたいかによって決まる。
    この新しい型で遊んでみよう。

    *Main> CNothing 
    CNothing
    *Main> CJust 0 "haha"
    CJust 0 "haha"
    *Main> :t CNothing 
    CNothing :: CMaybe a
    *Main> :t CJust 0 "haha"
    CJust 0 "haha" :: CMaybe [Char]
    *Main> CJust 100 [1,2,3]
    CJust 100 [1,2,3]

    CNothing コンストラクタにはフィールドがない。CJust コンストラクタには 2 つのフィールドがあり、最初のフィールドには整数を、2 つ目のフィールドには任意の型の値を入れられる。
    では、この CMaybe を Functor のインスタンスにしてみよう。
    fmap を使うたびに 2 つ目のフィールドに関数を適用するが、その際にカウンタを増やす（つまり最初のフィールドに 1 を足す）という実装にする。
-}

instance Functor CMaybe where
    fmap _ CNothing = CNothing
    fmap f (CJust cnt x) = CJust (cnt + 1) (f x)

{-
    では、ちょっと使ってみよう。
        *Main> fmap (++"ha") (CJust 0 "ho")
        CJust 1 "hoha"
        *Main> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
        CJust 2 "hohahe"
        *Main> fmap (++"blah") CNothing
        CNothing

    さて、CMaybe はファンクター則を満たしているだろうか？
    満たしていないことを証明するには 1 つでも反例を挙げればよい。

    *Main> fmap id (CJust 0 "haha")
    CJust 1 "haha"
    *Main> id (CJust 0 "haha")
    CJust 0 "haha"

    ファンクター第一法則を満たしていない！　それゆえ、CMaybe は Functor のインスタンスを自称しているものの、ファンクターではないことになる。

    CMaybe は、Functor のインスタンスでありながらファンクター則を満たさないため、CMaybe をファンクターとして利用するコードはバグを有無可能性がある。
    ファンクターを利用するとき、複数の関数を合成してから写すのと、複数ん関数で次々に写すのとは、同じ結果を生まないといけないのである。
    しかし CMaybe の場合は、ファンクターに適用された回数を記録しているので、合成と写しの順番を入れ替えると結果が変わってしまう。　これはまずい！
    CMaybe にファンクター即を満たさせようと思ったら、fmap を使ったときに Int フィールドをいじってはいけないのである。

    ファンクター則があるおかげで、もしある型がファンクター則を両方満たすとわかれば、その型の挙動についてある種の信頼がおける。
    それによって、より抽象的で応用の利くコードが書ける。
    ある型を Functor のインスタンスにしようと思ったら、ちょっと時間を割いて、その実装がファンクター則を満たしていることを確認すること。
-}

