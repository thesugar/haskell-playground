{-# OPTIONS -Wall -Werror #-}

import Data.Char
import Data.List
import Control.Applicative

---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---
--  　　 ファンクターからアプリカティブファンクターへ　　　　    --
---_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/---

{-
    純粋性、高階関数、型引数を取る代数的データ型（parameterized algebraic data types）、型クラスを兼ね備える Haskell では、
    他のプログラミング言語よりずっと簡単に多相性を実現できる。
    型の巨大な階層構造に気を揉む必要はない。その代わり、これらの型はどのように振る舞うか？　と考えて、適切な型クラスに関連づければよいのである。

    例えば、Int はさまざまな「もの」のように振る舞う。
    同じかどうか判定できるもの、順序が着いたもの、列挙できる（数え上げられる）もの、などなど。

    型クラスはオープンである。つまりデータ型を定義し、その型がどう振る舞うかを考えてから、その振る舞いを定義する型クラスに属させることができるのである。
    このオープンな型クラスと、関数の型宣言だけから多くのことを読み取れる Haskell の強力な型システムのおかげで、
    とても一般的で抽象的な振る舞いを定義する型クラスが作れる。

    これまでに、2 つのものが等しいかどうか判定する操作や、2 つのものを何らかの順序で比較する操作を定義する型クラスを見てきた。
    こういうと抽象的で高尚に聞こえるが、等号や比較は日常的にも使う操作で、とりわけ特別なことでもない。
    それから、第 7 章ではファンクターを紹介した。
    ファンクターは、関数を使って全体を写せるもの、という感じだった。
    これもまた型クラスを使って定義できる、便利で、それでいてかなり抽象的な性質の 1 つである。

    この章では、ファンクターをより詳しく見ていく。そして、ファンクターの少し強力でより便利なバージョンであるアプリカティブファンクターも紹介する。
-}

-------------------------------
--　帰ってきたファンクター
-------------------------------

{-
    第 7 章で学んだように、ファンクターとは関数で写せるもののことである。例えば、リスト、Maybe、木などがファンクターである。
    Haskell では、ファンクターは型クラス Functor で表現される。
    ファンクターの型クラスメソッドは 1 つだけで、それは fmap である。
    fmap の型は fmap :: (a -> b) -> f a -> f b である。
    この型の意味は「僕に『a を取って b を返す関数』と a の入った箱を渡して。そうしたら b の入った箱にして返すよ」という感じである。
    箱 f の中の要素に関数を適用してくれるのである。

    ファンクターは **文脈** を持った値だとみなすこともできる。例えば、Maybe 値は「計算が失敗したかもしれない」という文脈を、
    リストは「複数の値を同時に取るかもしれない」という文脈を持つ。
    fmap は、こういった文脈を保ったまま関数を値に適用するのである。

    型コンストラクタを Functor のインスタンスにするには、その型コンストラクタの種類（kind）は * -> * でなければならない。
    つまり、その型コンストラクタは、型変数として具体型をただ 1 つ取る必要がある。
    例えば Maybe は、Maybe Int や Maybe String のように 1 つの型変数を取って具体型を生むので、ファンクターになれる。
    これに対して、Either のような 2 つの型変数を取る型コンストラクタをファンクターにするには、部分適用をして、あと 1 つだけ型変数を引数に取る状態にしないといけない。

    というわけで、`instance Functor Either where` は **間違い** だが、`instance Functor (Either a) where` は正しいインスタンス宣言である。
    そして、fmap は Either a に働くのだと考えれば、次のような型になることがわかる。
        fmap :: (b -> c) -> Either a b -> Either a c
    fmap の前後で Either a の部分は普遍であり、Either a のただ 1 つの変数の部分が変化している。

            〜〜ここまでは第 7 章で学んだ内容〜〜
-}

--- ¶　ファンクターとしての I/O アクション
{-
    これまで実に多くの方（型コンストラクタ）が Functor のインスタンスであることを見てきた。
    []、Maybe、Either a、それから第 7 章で作った Tree などである。
    a -> b 型の関数を使って [a], Maybe a, Either a1 a, Tree a などの型をも写せるのはとても便利だった。
    今度は IO インスタンスを見てみよう。

    例えば、IO String という型は、実行すると、外の世界に出かけて行って文字列を取ってきてくれて、
    それを返してくれるような I/O アクションを表している。
    取得結果は、do 記法の中で <- 構文を使って名前に束縛できる。
    第 8 章では、I/O アクションとは小さな足の生えた箱で、外の世界に出かけて行って何か値を入れて帰ってきてくれるのだ、という比喩を使った。

    我々は IO が取ってきてくれた値を調べることができるが、調べた後はまた IO の中に戻さなくてはいけない。
    この「足の生えた箱」のたとえで、IO がファンクターの一種であることが理解できる。

    IO の Functor インスタンスがどのように定義されているか見てみよう。
    ある関数をある I/O アクションに fmap すると「元の I/O と同じことをしつつ、その結果に指定した関数を適用して返す」I/O アクションになってほしいわけである。
    以下が実装である。
        instance Functor IO where
            fmap f action = do
                result <- action
                return (f result)

    I/O アクションを関数で写した結果もまた I/O アクションなので、まずは脊髄反射的に do 構文を使う。
    この中で 2 つのアクションを貼り付けて新しい I/O アクションを作ればいいはずである。
    fmap を実装するには、まずもともとの I/O アクションを実行して結果を result と名付ける。
    次に return (f result) を行う。return とは、すでに学んだが「特に仕事を行わず、ただ何かを結果として提示する I/O アクション」を作る関数。

    do ブロックで組み立てたアクションは常に最後のアクションの結果を提示する。
    それゆえ、return を使って仕事をしないアクションを作り、f result を do ブロック全体の結果として提示させるわけである。
    以下のコードを見よ。
-}

--- runhaskell で実行するときは名前を main1 から main にすること。
main1 :: IO ()
main1 = do
    line <- getLine
    let line' = reverse line
    putStrLn $ "You said " ++ line' ++ " backwards!"
    putStrLn $ "Yes, you said " ++ line' ++ " backwards!" -- これなに（なんで 2 回同じ出力？）

{-
    ユーザーに文字列を入力してもらい、それを逆順にして表示している。
    これは fmap を使うと以下のように書ける。
-}

main2 :: IO ()
main2 = do
    line <- fmap reverse getLine
    putStrLn $ "You said " ++ line ++ " backwards!"
    putStrLn $ "Yes, you really said " ++ line ++ " backwards!" -- これなに（なんで 2 回同じ出力？）

{-
    Just "blah" を fmap reverse して Just "halb" を作るのと同じように、getLine を fmap reverse できるのである。
    getLine は IO String の型を持つ IO アクションであるから、それを fmap reverse すると、外の世界に出かけていって文字列を 1 行入力してもらって、
    その結果に reverse を適用する I/O アクションになる。
    Maybe という箱に入っている値に関数を適用できるのと同様に、IO という箱の中に入っている値に関数を適用できるわけだが、
    fmap した結果も IO なので、そいつもやはり外の世界に出かけて行って何か値を取ってくるという動作をするわけである。
    その後、reverse を適用済みの値を、<- を使って line という名前に束縛している。

    ほかにも、fmap (++ "!") getLine という I/O アクションは getLine とほぼ同じ動作をするが、入力された文字列の末尾に "!" をつける。
    仮に fmap が IO に限定されていたら、fmap の型は fmap :: (a -> b) -> IO a -> IO b になる。
    fmap は、a -> b な関数と IO a な I/O アクションを取って、「それとよく似た動作をして中身の値ん関数を適用するような I/O アクション」を返す関数である。

    もし自分のコードに、何らかの関数に渡すだけのために I/O の結果に名前をつけている（束縛している；つまり contents <- getLine として contents をそのまま他の関数に渡しているなど）
    箇所があったら、fmap を使ってみよう。そのほうがきれいに書ける。
    もしファンクターの中身を、1 つではなく複数の関数を使って写したいなら、そのための関数をトップレベルで宣言してもいいし、ラムダ式を使ってもいいが、一番いいのは関数合成である。
-}

-- import Data.Char
-- import Data.List

main3 :: IO ()
main3 = do
    line <- fmap (intersperse '-' . reverse . map toUpper) getLine -- ※ intersperse '-' "hoge" とすると結果は "h-o-g-e" になる。
    putStrLn line

{-
    使用例：
        stack runhaskell src/11_Functors_and_ApplicativeFunctors.hs
        hello there
        E-R-E-H-T- -O-L-L-E-H
-}

--- ¶　ファンクターとしての関数
{-
    Functor のインスタンスだと知らずに、何気なくずっと使ってきたものがもう 1 つある。その Functor は、`(->) r` である。
    関数の型を表す `r -> a` は、`(->) r a` と書き換えることができるのである（ちょうど 2 + 3 を (+) 2 3 と書き換えることができるように）。
    関数の型を (->) r a と表現するとき、関数 (->) には、2 つの型引数を取る型コンストラクタという新しい姿が与えられているのである。Either と同じだ。

    ただし、Functor のインスタンスにする型コンストラクタは引数が 1 つである必要がある。
    だから、(->) という形のままでは Functor にはできない。部分適用して (->) r の形にすれば大丈夫。
    セクション（第 5 章。テキスト p.64）が使えれば、型コンストラクタの部分適用 (->) r を (r ->) と書き換えたいところだが、これは文法的にまずい。

    さて、関数がファンクターであるとはどういうことなのだろうか？
    インスタンス宣言の実装を覗いてみよう。

        instance Functor ((->) r) where
            fmap f g = (\x -> f (g x))

    まず、fmap の型を思い出そう。
        fmap :: (a -> b) -> f a -> f b

    ファンクターのインスタンスは上記の f の場所に入るので、頭の中で f を (->) r に置換してみよう。
    すると、関数をファンクターのインスタンスにしたとき fmap がどのような型になるかわかる。
        fmap :: (a -> b) -> ((->) r a) -> ((->) r b)

    さらに、(->) r a と (->) r b　という表記を、普通の中置表記 r -> a と r -> b に直そう。
        fmap :: (a -> b) -> (r -> a) -> (r -> b)

    fmap を使うと、Maybe は Maybe を生み出し、リストはリストを生み出した。Functor としての関数も、関数を取って関数を生み出すはずだ。
    ならば、型 fmap :: (a -> b) -> (r -> a) -> (r -> b) が意味するものとは？

    この型は、a から b への関数と、r から a への関数を引数に取り、r から b への関数を返す、と読める。
    何か思い出さないだろうか？　そう、関数合成である。

    このインスタンス宣言はこう書いてもよいかもしれない。

        instance Functor ((->) r) where
            fmap = (.)

    こう書くと、fmap が関数ファンクターの場合には関数合成を意味することがはっきりする。
    関数ファンクターのインスタンス定義は Control.Monad.Instances から読み込めるので、試しに使ってみよう。

        *Main> :t fmap (*3) (+100)
        fmap (*3) (+100) :: Num b => b -> b
        *Main> fmap (*3) (+100) 1
        303
        *Main> (*3) `fmap` (+100) $ 1
        303
        *Main> fmap (show . (*3)) (+100) 1
        "303"

    入力の 3 行目では、fmap を中置関数として読んでいる。こうすると、fmap と . が同じだということがはっきりする。
    入力の 2 行目では (*3) で (+100) を写している。その結果は「入力を (+100) して (*3) する関数」になる。
    それをさらに 1 に作用されると、答えは 303 になる。

    他のファンクターと同様、関数ファンクターも文脈を持った値だとみなせる。
    Maybe との対比で考えてみよう。Maybe ファンクターは、「値があるかもしれない」という文脈を表し、具体化した Maybe a は
    「a 型の値があるかもしれない」という文脈だった。それに対して、関数ファンクター (->) r （あるいは r ->）は、
    「r 型の入力を適用すれば結果が返ってくる」という文脈を表し、それを具体化した (->) r a（あるいは r -> a）は、
    「r 型の入力を適用すれば a 型の結果が返ってくる」という文脈を表している。

    例えば関数 (+3) :: Int -> Int は、その関数の返り値である Int 型の値に、「結果が欲しければ Int 型に適用しろ」という文脈がついたものとみなせる。
    fmap (*3) を (+100) に使うと、(+100) の処理をした後で結果を返す前に (*3) を適用する、新しい関数が生まれる。

    fmap を関数に適用すると関数合成になるというのは、今のところあまり役に立たないが、興味を惹かれる事実である。
    これについて深く考えると、IO や (->) r のように箱というよりは計算のように振る舞うものがファンクターになれる理由がわかってくる。

    「ある関数」を使って「何らかの計算」を写すと、得られるものは「似たような計算」だが、計算結果はその「関数」で修飾されたものになっているのである。
-}

{-
    さて、fmap が従うルールの説明に移る前に、もう一度 fmap の型について考えておこう。
        fmap :: (Functor f) => (a -> b) -> f a -> f b
    第 5 章では、Haskell の関数は実はすべて 1 引数関数とみなせる、というカリー化の概念を導入した。
    a -> b -> c 型の関数は、a 型の引数を 1 つだけ取る関数で、返り値は b -> c 型の関数である。
    これがまた 1 つだけ引数を取って、c 型の値を返す。

    これを、多引数関数を認める立場から見れば、ある関数を一部の引数しか与えないで呼び出す（部分適用）と
    「残りの引数を取って最終結果を返す関数」を返す、と説明できる。
    そこで、a -> b -> c 型は a -> (b -> c) と書ける。こうするとカリー化がはっきりわかる。

    同じように、fmap :: (a -> b) -> f a -> f b の型を持つ fmap も、関数とファンクター値を取ってファンクター値を返す 2 引数関数とも思えるが、
    そうでなく、fmap :: (a -> b) -> (f a -> f b) という見方をすれば、関数を取って「元の関数に似ているけどファンクター値を取ってファンクター値を返す関数」を返す関数だと思うこともできる。
    fmap は、関数 a -> b を取って、関数 f a -> f b を返すのである。
    こういう操作を、関数の持ち上げ（lifting）という。このようなファンクターの見方について、:t コマンドを使って遊びながら覚えよう。

        *Main> :t fmap (*2)
        fmap (*2) :: (Functor f, Num b) => f b -> f b

        *Main> :t fmap (replicate 3)
        fmap (replicate 3) :: Functor f => f a -> f [a]

    式 fmap (*2) は、数が入っているファンクター f を取って、数が入っているファンクターを返す関数である。
    ファンクターは、リストでも Maybe でも Either String でもなんでもかまわない。
    また、式 fmap (replicate 3) は、「なんでもいい型 a が入っているファンクター」を取り、a のリストが入っているファンクターを返す。
    このことは、例えば fmap (++ "!") のような部分適用を作って、それを GHCi で名前に束縛してみるとよくわかる。

        *Main> shout = fmap (++"!")
        *Main> :t shout
        shout :: Functor f => f [Char] -> f [Char]
        *Main> shout ["ha", "ka", "ta", "no"] # リストはファンクター
        ["ha!","ka!","ta!","no!"]
        *Main> shout (Just "hoge") # Just（Maybe）はファンクター
        Just "hoge!"

    というわけで、fmap については 2 通りの考え方ができる。

        - fmap は関数とファンクター値を取って、その関数でファンクター値を写して返すものである。
            - fmap は「文字列の末尾にびっくりマークをつける関数」を取って、その関数で、`文字列のリスト` や `Just 文字列` を写してそれぞれ（末尾にびっくりマークをつけた）`文字列のリスト` や `Just 文字列` を返す。
        - fmap は値から値への関数を取って、それをファンクター値からファンクター値への関数に持ち上げたものを返す関数である。
            - fmap は「文字列の末尾にびっくりマークをつける関数」を取って、それを、「文字列のリストについて、各文字列の末尾にびっくりマークをつけた文字列のリストとして返す関数」に持ち上げたものとして返す（Just 文字列についても同様）。

    そして、どちらの見方も正しい。「関数でファンクター値を写す」ということと、「関数を持ち上げてからファンクター値に適用する」ことは等価でる。

    例えば、関数 fmap (replicate 3) は、その型が fmap (replicate 3) :: (Functor f) => f a -> f [a] であることからわかるように、どんなファンクターにも適用でいる。
    そして、何が起こるかはそのファンクターによって変わる。
    リストに対して fmap (replicate 3) すれば、リスト向けの fmap の実装が選ばれて、それは普通の map である。
    Maybe a に対してfmap (repliate 3) とすれば、Just の中の値に対して replicate 3 が適用される。Nothing なら Nothing である。いくつか例を示す。

        *Main> fmap (replicate 3) [1,2,3,4]
        [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
        *Main> fmap (replicate 3) (Just 10)
        Just [10,10,10]
        *Main> fmap (replicate 3) (Right "blah")
        Right ["blah","blah","blah"]
        *Main> fmap (replicate 3) Nothing
        Nothing
        *Main> fmap (replicate 3) (Left "foo")
        Left "foo"

        🗒 Right と Left に fmap を適用したときの挙動の違いは第 7 章で説明済み。
-}

-------------------------------
--　ファンクター則
-------------------------------

{-
    すべてのファンクターの性質や挙動は、ある一定の法則に従うことになっている。
    fmap f をファンクターに適用したら、それはファンクターの中身に f を適用すべきであって、それ以上のことをしてはいけないのである。
    この挙動は **ファンクター則** に記述されている。
    Functor のインスタンスは、ファンクター則の 2 つの性質（後述）を満たしている必要がある。
    残念ながら、Haskell には自動的にファンクター則を課してくれるような機能はないので、ファンクターを自作するときは、
    ファンクター則を満たしているか、自前でテストしないといけない。
    標準ライブラリにある Functor たちは、すべてファンクター則を満たしている。
-}

--- ¶ 第一法則
{-
    ファンクターの第一法則は、「id でファンクター値を写した場合、ファンクター値が変化してはいけない」というもの。
    式で書くと `fmap id = id` ということである。
    別の言い方をすれば、fmap id をファンクター値に適用した場合、それは di をファンクター値に適用したのと同じ結果になる、ということである。
    id は恒等写像、引数をそのまま返すだけの関数であった。
    id は \x -> x とも書ける。ファンクターは中身に関数が適用されるようなものであると思えば、fmap id = id という法則は、何だか自然で当たり前に思える。
    さて、いくつかのファンクターでこの第一法則を試してみよう。

        *Main> fmap id Just 3
        Just 3
        *Main> id Just 3
        Just 3
        *Main> fmap id [1,2,3]
        [1,2,3]
        *Main> fmap id Nothing
        Nothing

    例えば Maybe ファンクターに対する fmap の実装を見てみると、どうやって第一法則が満たされているかわかる。
        instance Functor Maybe where
            fmap f (Just x) = Just (f x)
            fmap f Nothing = Nothing

    さて、f に id を代入したところをイメージしてみよう。
    id で Maybe ファンクター値を写すとき、Maybe 値の中身は Just 値コンストラクタである場合と Nothing 値コンストラクタである場合がありえる。
    まず Just の場合、fmap id を Just x に適用すると Just (id x) ができる。そして id は恒等写像だから、Just (id x) は Just x である。
    というわけで Just の場合は、確かに fmap id したら元と同じ値が返ってくることがわかった。
    次に、id で Nothing を写した場合は、同じ値が返ってくることは明らかである。
    というわけで、Maybe ファンクターの fmap を実装する 2 つの等式から、Maybe ファンクターは確かにがんクター第一法則 fmap id = id を満たすことがわかった。
-}

--- ¶　第二法則
{-
    第二法則は、関数合成と写す操作との間の関係である。
    第二法則は、2 つの関数 f と g について、「f と g の合成関数でファンクター値を写したもの」と、「まず g、次に f でファンクター値を写したもの」が等しいことを要求する。
    式で書くと、fmap (f . g) = fmap f . fmap g ということ。
    別の言い方をすると、すべてのファンクター値 x に対して fmap (f . g) x = fmap f (fmap g x) が成り立つべし、というのが第二法則である。

    ある型が 2 つのファンクター則を満たすということは、適用に関する基本的な振る舞いが関数や他のファンクターと一致することが保証される、ということである。
    その型に fmap を使ったときに、関数によって写される以外の余計なことが裏で発生することはなく、あくまでも関数の素直な拡張であるファンクターとして振る舞うことがわかるのである。

    ある型がファンクターダイン法則を満たすかどうかは、その型の fmap の実装を見て、それから Maybe が第一法則を満たしているか調べたときと同じ方法を使えばわかる。
    Maybe ファンクターが第二法則を満たしているか調べてみよう。
    まず、Nothing に対して fmap (f . g) を使うと、返り値は Nothing になる（Nothing に対して何を fmap しても Nothing だから）。
    同じ理由から、fmap f (fmap g Nothing) を呼び出しても結果はやはり Nothing になる。
    では、Just の場合はどうだろう？まず fmap (f . g) (Just x) を評価してみる。これは実装から Just ((f . g) x) になり、これは Just (f (g x)) である。
    次に、fmap f (fmap g (Just x)) については、これまた実装に当てはめてみると、はじめに fmap g (Just x) の部分が評価されて Just (g x) になるから、
    fmap f (fmap g (Just x)) は fmap f (Just (g x)) になる。さらに残りを評価するとこれは Just (f (g x)) に等しいことがわかる。
-}

--- ¶　法則を破る
{-
    ここで、Functor のインスタンスなのに、ファンクター則を満たしていないような例を考えてみよう。以下のような型を用意する。
-}

data CMaybe a = CNothing | CJust Int a deriving (Show)

{-
    C は counter のつもり。Cmaybe a は、Maybe a によく似たデータ型だが、Just 部分のフィールドが 1 つではなく 2 つある。
    CJust の 1 つ目のフィールドは常に Int 型で、これが何らかのカウンタになる。
    2 つ目のフィールドの型 a は型引数で、a の型が何になるのかは CMaybe a をどんな具体型にしたいかによって決まる。
    この新しい型で遊んでみよう。

    *Main> CNothing 
    CNothing
    *Main> CJust 0 "haha"
    CJust 0 "haha"
    *Main> :t CNothing 
    CNothing :: CMaybe a
    *Main> :t CJust 0 "haha"
    CJust 0 "haha" :: CMaybe [Char]
    *Main> CJust 100 [1,2,3]
    CJust 100 [1,2,3]

    CNothing コンストラクタにはフィールドがない。CJust コンストラクタには 2 つのフィールドがあり、最初のフィールドには整数を、2 つ目のフィールドには任意の型の値を入れられる。
    では、この CMaybe を Functor のインスタンスにしてみよう。
    fmap を使うたびに 2 つ目のフィールドに関数を適用するが、その際にカウンタを増やす（つまり最初のフィールドに 1 を足す）という実装にする。
-}

instance Functor CMaybe where
    fmap _ CNothing = CNothing
    fmap f (CJust cnt x) = CJust (cnt + 1) (f x)

{-
    では、ちょっと使ってみよう。
        *Main> fmap (++"ha") (CJust 0 "ho")
        CJust 1 "hoha"
        *Main> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
        CJust 2 "hohahe"
        *Main> fmap (++"blah") CNothing
        CNothing

    さて、CMaybe はファンクター則を満たしているだろうか？
    満たしていないことを証明するには 1 つでも反例を挙げればよい。

    *Main> fmap id (CJust 0 "haha")
    CJust 1 "haha"
    *Main> id (CJust 0 "haha")
    CJust 0 "haha"

    ファンクター第一法則を満たしていない！　それゆえ、CMaybe は Functor のインスタンスを自称しているものの、ファンクターではないことになる。

    CMaybe は、Functor のインスタンスでありながらファンクター則を満たさないため、CMaybe をファンクターとして利用するコードはバグを有無可能性がある。
    ファンクターを利用するとき、複数の関数を合成してから写すのと、複数ん関数で次々に写すのとは、同じ結果を生まないといけないのである。
    しかし CMaybe の場合は、ファンクターに適用された回数を記録しているので、合成と写しの順番を入れ替えると結果が変わってしまう。　これはまずい！
    CMaybe にファンクター即を満たさせようと思ったら、fmap を使ったときに Int フィールドをいじってはいけないのである。

    ファンクター則があるおかげで、もしある型がファンクター則を両方満たすとわかれば、その型の挙動についてある種の信頼がおける。
    それによって、より抽象的で応用の利くコードが書ける。
    ある型を Functor のインスタンスにしようと思ったら、ちょっと時間を割いて、その実装がファンクター則を満たしていることを確認すること。
-}
-------------------------------
--　アプリカティブファンクターを使おう
-------------------------------
{-
    この節では、ファンクターの強化版であるアプリカティブファンクターを紹介する。
    ここまではファンクター値を写すためにもっぱら 1 引数関数を使ってきた。では、2 引数関数でファンクターを写すとどうなるか？

    例えば、Just 3 に対して fmap (*) (Just 3) とすると何が起こるだろうか。
    Maybe の Functor インスタンスん実装をみると、fmap の引数の関数が Just の中身に適用されることがわかる。
    だから fmap (*) (Just 3) は Just ((*) 3) になる。これはセクション記法を使うと Just (3 *) とも書ける。
    なんと！　Just の中に関数が入ってしまった。

    *Main> :t fmap (*) (Just 3)
    fmap (*) (Just 3) :: Num a => Maybe (a -> a)

    少し、他にも似たような例を見てみよう。どれも、関数がファンクター値の中に入っている。

    *Main> :t fmap (++) (Just "hey")
    fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
    *Main> :t fmap compare (Just 'a')
    fmap compare (Just 'a') :: Maybe (Char -> Ordering)
    *Main> :t fmap compare "hogehoge"
    fmap compare "hogehoge" :: [Char -> Ordering]

    このように、「多引数」関数でファンクター値を写すと、関数が入ったファンクター値が返ってくる。
    これは何に使えるんだろうか？
    1 つの使い道は、その中身の関数を引数に取れるような型を持つ関数を fmap することである。
    なにしろファンクター値の中身は、ファンクターをうつそうとする関数にもれなく渡されるのだから。

        *Main> a = fmap (*) [1,2,3,4]
        *Main> :t a
        a :: Num a => [a -> a]
        *Main> fmap (\f -> f 9) a
        [9,18,27,36]
        *Main> fmap ($9) a
        [9,18,27,36]

    では、ファンクター値 Just (3 *) とファンクター値 Just 5 があったとして、Just (3 *) から関数を取り出して Just 5 の中身に適用したくなったとしたらどうしよう？
    実は、普通のファンクターを扱うかぎり、これは _無理_ なのである！
    普通のファンクターでできるのは、「通常の関数で」「ファンクターの中の値を」写すことだけだからである。
    \f -> f 9 を fmap したときの例では、ファンクターでもあるリスト（→リストはファンクターだから！）の中の関数（*1, *2, *3, *4）に引数（9）を渡せているように見えたかもしれないが、
    あれはあくまでも「\f -> f 9 という通常の関数でファンクター値を写したところ、たまたまその \f -> f 9 という関数は、関数（f）を引数に取って、その関数 f に 9 を引数として渡す機能を備えていた」というだけ。
    「ファンクターの中の関数（例えば Just (3 *) における 3 *）」で「別のファンクターの中の値（例えば Just 5 における 5 ）」を写すことは、fmap の提供する機能では無理。
    確かに、Just コンストラクタをパターンマッチして中の関数を取り出し、それを Just 5 に fmap する、という手はある。
    でも、それは Maybe 限定の手段になってしまう。
    もっと、どんなファンクターにも使えるような一般的で抽象的なアプローチはないものか？
-}

--- ¶　Applicative ちゃんと仲良くしてあげてね！
{-
    Applicative 型クラスに会いに行こう！　型クラス Applicative は、2 つの関数 pure と <*> を定義している。
    どちらもデフォルト実装は与えられていないので、ある型を Applicative のインスタンスにしたかったら両方の定義を与える必要がある。
    クラス定義は次のような感じ。
        *Main> :i Applicative 
        class Functor f => Applicative (f :: * -> *) where
            pure :: a -> f a
            (<*>) :: f (a -> b) -> f a -> f b

    出力の一行目（class 〜）では、Applicative クラスの定義を与えると同時に、型クラス制約を導入している。
    「ある型コンストラクタを Applicative 型クラスに属させたかったら、まずは Functor に属させるべし」という型クラス制約である。
    だから、ある型コンストラクタが Applicative 型クラスに属していたら、それは必ず Functor であるため、常に fmap が使える。

    Applicative 型クラスの定義する最初のメソッドは pure と呼ばれる。その型宣言は pure :: a -> f a である。
    この f がアプリカティブファンクターになるものである。
    pure は任意の型の引数を受け取り、それをアプリカティブ値の中に入れて（つまり f a）返す。
    「中に入れて」という言い方はファンクターのときに使った箱の比喩を踏襲したものである。
    すでに見たように、この比喩が当てはまらない場合もあるが、型宣言 a -> f a を文字通りに解釈すれば自明であろう。
    すなわち pure は、値を取って、内部にその値を結果として含むアプリカティブ値に包む。
    アプリカティブ値は「箱」というよりも「文脈」と考えた方が正確かもしれない。
    pure は、値を引数に取り、その値をなんらかのデフォルトの文脈（元の値を再現できるような最小限の純粋な文脈）に置くのである。

    <*> 関数はすごく面白い。型定義 f (a -> b) -> f a -> f b を見て何か思い出さないだろうか。
    そう、これって fmap :: (a -> b) -> f a -> f b にそっくり。
    <*> は fmap の強化版なのである。fmap が通常の関数（`a -> b`）とファンクター値（`f a`）を引数に取って、関数をファンクター値の中の値に適用してくれる（結果として `f b` が得られる）のに対して、
    <*> は関数の入っているファンクター値（`f (a -> b)`）と値の入っているファンクター値（`f a`）を引数に取って、
    1 つ目のファンクターの中身である関数を 2 つ目のファンクターの中身に適用する（結果として `f b` が得られる）のである。
-}

--- ¶ Maybe はアプリカティブファンクター
{-
    手始めに Maybe の Applicative インスタンスを見てみよう。

        instance Applicative Maybe where
            pure = Just
            Nothing <*> _ = Nothing
            (Just f) <*> something = fmap f something

    ファンクターのときと同じく、アプリカティブファンクターになる型コンストラクタ f も、具体型を 1 つだけ型引数に取ることがクラス定義からわかる。
    （class Functor f => Applicative (f :: * -> *) where　こうだったんだから、f :: * -> * というので、具体型を 1 つ引数に取ることがわかるよね）
    なので、インスタンス宣言の書き出しは instance Applicative Maybe where とする。
    ❌ instance Applicative (Maybe a) where ではダメ！

    次の行は pure の定義。pure は何かを取ってそれをアプリカティブ値に包むのだった。
    pure の定義には、ただ pure = Just とだけ書いてある。Just のような値コンストラクタは普通の関数でもあるから、これでいいのである（pure x = Just x と書いてもよい）。

    残りは <*> の定義である。
    まず、Nothing からは関数が取り出せない。なにしろ無であるから。そこで、Nothing から関数を取り出そうとした場合は結果も Nothing、ということにしよう。

    Applicative のクラス定義には Functor の型クラス制約がついていたから、<*> 関数の 2 つの引数は両方ともファンクター値であるはずである。
    もし最初の引数が Nothing でなくて Just なら、その中身の関数を取り出して 2 つ目の引数に fmap することにする。
    （こうすれば、2 つ目の引数が Nothing だった場合にも自動的に対応できる。Nothing を fmap しても Nothing だからである）。
    というわけで、Maybe ファンクターに関する <*> の挙動は、左辺が Just ならその中の値を取り出して右辺を写す、というものである。
    もし左右どちらかの引数が Nothing だったら答えも Nothing になる。

        *Main> Just (+3) <*> Just 9
        Just 12

        *Main> Just (++ "!!") <*> Just "hello"
        Just "hello!!"

        *Main> Just (++"hahaha") <*> Nothing
        Nothing

        *Main> Nothing <*> Just (++"mi")
        Nothing

        *Main> pure (+3) <*> Just 10
        Just 13

        *Main> Just (+3) <*> Just 10
        Just 13

        *Main> pure (+3) <*> pure 10
        13

        *Main> (+3) <*> Just 10
        エラー

    見てのとおり、pure (+3) と Just (+3) の効果はまったく同じ。pure を使うのは、Maybe をアプリカティブとして（<*> と組み合わせて）使う場合だけに留めておいたほうが無難だろう。
    そのほかの場合は素直に Just を使おう。

    上記の例は、アプリカティブから関数を取り出して適用するデモであるが、こういう場合はわざわざアプリカティブにくるまなくても、生の関数を fmap すれば済む。

    普通のファンクターの場合、いったん関数で写してしまったら、ファンクターの中に入ってしまった関数適用の結果をファンクターの外に取り出す一般的な方法はない。
    たとえその結果が部分適用された関数であったとしてもだ。一方、アプリカティブファンクターなら、1 つの関数で複数のファンクターを続けざまに写せるのである。
-}

--- ¶　アプリカティブ・スタイル
{-
    Applicative 型クラスでは、<*> を連続して使うことができ、1 つだけでなく複数のアプリカティブ値を組み合わせて使うことができる。
    例えば以下を見よ。
-}

hoge1 :: Maybe Int
hoge1 = pure (+) <*> Just 3 <*> Just 5 -- Just 8

hoge2 :: Maybe Int
hoge2 = pure (+) <*> Just 3 <*> Nothing -- Nothing

hoge3 :: Maybe Int
hoge3 = pure (*) <*> Nothing <*> Just 5 -- Nothing

{-
    ここでは + 関数をアプリカティブ値の中に入れ、さらに <*> を使って 2 つの引数に適用しているが、そのどちらもアプリカティブ値である。
    一体どうしてこれが可能になったのか、順を追って見ていこう。

    <*> は左結合なので、
        pure (+) <*> Just 3 <*> Just 5
    この式は
        (pure (+) <*> Just 3) <*> Just 5
    と同じ。

    まず + 関数をアプリカティブ値（今回は Maybe 値）の中に入れたいので、pure (+) を使う。これは Just (+) のことである。

    > 改めて誤解のないよう書いておくと、pure はどんなときも Just の代わり、というわけではもちろんない。
    > pure は値をデフォルトの文脈に置いてくれるもので、ここでは Maybe を扱っているから Just になっているけど、
    > リストを扱う場合では pure (+) <*> [1,2,3] <*> [100, 200, 300] というようなことができて、当然この場合 pure は Just ではないよね。 

    次に Just (+) <*> Just 3 が評価される。その結果は Just (3+) になる。ここでは部分適用が起こっている。
    + という二項演算の関数に 3 という 1 つの引数だけを与えると、「もう 1 つの引数を取ってそれに 3 を足す関数」が返ってくる。
    最後に Just (3+) <*> Just 5 が実行され、結果は Just 8 になる。

    これってすごくない？
    アプリカティブファンクターとアプリカティブ・スタイル pure f <*> x <*> y <*> ... を使えば、もともとアプリカティブなんて知らずに書かれた普通の関数にも
    アプリカティブ値の引数を与えることができる。しかsも、<*> が出てくるたびに部分適用が働くので、いくつでも引数を与えることができるのである。
        （🤔❓💭（まだあんまりうれしさがわからない。。））

    アプリカティブ・スタイルをもっと理解して便利に使うためのポイント、それは pure f <*> x は fmap f x と等しい、という事実を考慮に入れることである。
    ちなみに、これはアプリカティブ則の 1 つである。
    アプリカティブ則についてはこの章の後半で詳しく見るとして、今はこの法則にどういう効果があるかを考えよう。
    pure は値をデフォルトの文脈の中に入れる。ある関数をデフォルトの文脈の中に入れ、また取り出して別のアプリカティブファンクターの中の値に適用する、という操作は、
    単に元の関数でアプリカティブファンクターを写すのと同じことである。

        > （例えば、pure (*2) <*> Just 10 を考える。ある関数、ここでは (*2) を pure によりデフォルトの文脈の中に入れ（`pure (*2)`）、また取り出して別の
            アプリカティブファンクターの中の値に適用する（`<*> Just 10` の計算を行う）、という操作は、単に元の関数 (*2) でアプリカティブファンクターを写す（`fmap (*2) (Just 10)`）のと同じことである。
            現に、pure (*2) <*> Just 10 も fmap (*2) (Just 10) もどちらも答えは Just 20 になる）

    そこで、pure f <*> x <*> y <*> ... と書くかわりに、fmap f x <*> y <*> ... と書くことができる。
    このパターンはしょっちゅう使うので、中置演算子 <$> が用意されている。

        (<$>) :: Functor f => (a -> b) -> f a -> f b
        f <$> x = fmap f x
            --- 前もこんなことがあったけど、ここの 1 行目の f と 2 行目の f はまったく別物。1 行目の関数宣言に登場するのは型変数 f で、これには型クラス制約がついていて、
                f に入る型コンストラクタは Functor 型クラスに属している必要があると言っている。2 行目の f は関数の本体で、x を写すのに使うものである。

    <$> を使うとアプリカティブ・スタイルの素晴らしさが引き立つ。
    例えば、関数 f を 3 つのアプリカティブ値の引数に適用したければ、f <$> x <*> y <*> z と書けるのである。
    引数がアプリカティブ値でなく普通の値だったら f x y z と書くところである。

    この書き方でなぜうまくいくのか追ってみよう。例えば、値 Just "johntra" と Just "volta" を結合して 1 つの Maybe String 型の値を作りたいとする。
-}

-- まず、($) を使わず、今まで学んだとおりに書いてみると
letter :: Maybe String
letter = pure (++) <*> Just "johntra" <*> Just "volta" -- Just "johntravolta"

-- では ($) を使って書いてみると
letter' :: Maybe String
letter' = (++) <$> Just "johntra" <*> Just "volta" -- Just "johntravolta"

-- 上の例と、次を比べてみよう。
letter'' :: String
letter'' = (++) "johntra" "volta" -- "johntravolta"

{-
    普通の関数をアプリカティブファンクターの関数として使うためには、<$> と <*> を散りばめるだけである。
    すると関数は、アプリカティブ値を取ってアプリカティブ値を返すようになる。便利でしょ？
    （つまり、この記法がなかったら、Just "johntra" と Just "volta" という 2 つのアプリカティブ値を連結して Just "johntravolta" にすることが簡単にはできない。
    　（ふつうの文字列だったら簡単に連結できるのに。つまり、これが便利じゃないというなら文字列操作が `(++) "hoge" "fuga"` でできちゃうことにも価値を認めないってことですか？ということ。））

    (++) <$> Just "johntra" <*> Just "volta" の例に戻ろう。まずは　(++) :: [a] -> [a] -> [a] の型を持つ関数 (++) が Just "johntra" を写す。
    できた値は Just ("johntra" ++) と等価なもので、型は Maybe ([Char] -> [Char]) である。(++) の最初の引数が消費され、型変数 a は Char に変わった。
    さて次は Just ("johntra" ++) <*> Just "volta" の評価が発生する。

    すると Just から関数が出てきて Just "volta" を写し、最終結果 Just "johntravolta" を生み出す。
    もし、いずれかの引数が Nothing だったとしたら、答えは Nothing になる。

    ここまで Maybe の例しか出てきていないが、アプリカティブファンクターは Maybe 専用とかではまったくない！
-}

--- ¶　リスト
{-
    リスト（正確に言えばリスト型コンストラクタ []）もアプリカティブファンクターである。
    [] の Applicative インスタンス宣言は以下のとおり。
        instance Applicative [] where
            pure x = [x]
            fs <*> xs = [f x | f <- fs, x <- xs]

    pure は値を取ってデフォルトの文脈に入れるものだった。ここで言うデフォルトの文脈とは、なるべく小さな、
    それでいて引数を再現できる（「引数を再現」の意味は↓を読めばわかる）ような最小限の文脈のことである。
    さて、リストの文脈における最小のものは空リストである。しかし、空リストは値がないことを表しているのだから、
    pure の引数に渡された値を持っておくことはできない（引数を再現できない）。
    だから、pure は引数を単一要素のリストに入れて返すのである。
    これは Maybe アプリカティブファンクターのときも同じだった。
    Maybe の最小の文脈は Nothing だったが、Nothing は値がないことを表しているので、pure は Just を使って実装されていたんだった。
    以下を見れば pure の動作がわかる。

        *Main> pure "Hey" :: [String]
        ["Hey"]
        *Main> pure "Hey" :: Maybe String
        Just "Hey"

    <*> についてはどうだろう？関数 <*> の型をリストに制限すると、
        (<*>) :: [a -> b] -> [a] -> [b]
    になる。<*> はリスト内包表記で実装されている。
    二項演算子 <*> は、何らかの方法で左辺から取り出した関数を使い、右辺を写す必要がある。
    ところが、左辺のリストに入っている関数は 0 個かもしれないし、1 個かもしれないし、複数個かもしれない。
    もちろん右辺のリストにも複数の値が格納できる。そこで、両方のリストから要素を取り出すためにリスト内包表記を使っている。
    <*> は左辺のリストのそれぞれの関数を、右辺のリストのそれぞれの値に適用する。
    結果、<*> が返すリストには、左辺のリストの中の関数を右辺のリストの中の値にあらゆる可能な組み合わせで適用したものが入る。

    リストの <*> を使う例を見てみよう。
-}

moo :: [Int]
moo = [(*0), (+100), (^(2::Int))] <*> [1,2,3] -- [0,0,0,101,102,103,1,4,9]

{-
    左辺のリストは 3 つの関数を含んでおり、右辺リストは 3 つの値を含んでいる。そこで結果のリストのサイズは 9 つになるわけである。
    もし 2 引数関数のリストがあれば、その関数を 2 つのリストに適用できる。

    2 引数関数（その 2 引数関数自体も 2 つある）を 2 つのリストに適用する例を見てみよう。
-}

mii :: [Int]
mii = [(+), (*)] <*> [1,2] <*> [3,4] -- [4,5,5,6,3,4,6,8]

{-
    <*> は左結合なので、まず [(+), (*)] <*> [1,2] が処理される。
    それぞれの関数がそれぞれの値に適用されるので、[(1+), (2+), (1*), (2*)] と等価なリストができる。
    次に [(1+), (2+), (1*), (2*)] <*> [3,4] が処理されて、最終結果が出てくる。

    アプリカティブ・スタイルをリストで使うと楽しめる！
    以下は、2 つの文字列を引数に取る関数を 2 つの文字列のリストに使ったもの。
-}

kotoba :: [String]
kotoba = (++) <$> ["ha","heh","hmm"] <*> ["?","!","."] -- ["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]

{-
    リストは非決定性計算とみなすことができる。100 や "what" のような値は答えが 1 つしかない決定性計算であるのに対し、
    [1,2,3] のようなリストは「どの答えがいいか決められないので可能性のある答えをすべて提示している」とみなせる。
    この見方に立てば、(+) <$> [1,2,3] <*> [4,5,6] というコードは、2　つの非決定性計算を + で足し算して、いっそう自信のない新たな非決定性計算の結果が生じた、と解釈できる。

    アプリカティブ・スタイルをリストに使うと、リスト内包表記をうまく置き換えられることが多々ある。
    第 1 章には [2,5,10] と [8,10,11] の積として可能な値をすべて求めたいという例題があり、そのときは
        [x * y | x <- [2,5,10], y <- [8,10,11]]
    とした。これはアプリカティブ・スタイルでは以下のように書ける。
-}

prodOfList :: [Int]
prodOfList = (*) <$> [2,5,10] <*> [8,10,11] -- [16,20,22,40,50,55,80,100,110]

{-
    アプリカティブ・スタイルの記法では、2 つの非決定性計算に対して * を呼び出しているだけだ、という考え方になる。

    2 つのリストの要素を掛けあわせて作れる数のうち 50 より大きなものをすべて知りたければ、以下のように書ける。
-}

prodOver50 :: [Int]
prodOver50 = filter (> 50) $ (*) <$> [2,5,10] <*> [8,10,11] -- [55,80,100,110] // filter (> 50) を適用する部分はいたって普通。filter (>50) [1,30,60] などと同じ。

{-
    リストの場合、pure f <*> xs と fmap f xs が一致する理由は簡単。
    まず、pure f は [f] である。[f] <*> xs は、左辺のリストにあるすべての関数を右辺のリストのすべての値に適用しようとするが、
    左辺のリストの中には関数が 1 個しかないので、[f] <*> xs は map のような動作をするわけである。
-}

--- ¶ IO もアプリカティブファンクターだよ！
{-
    今まで見てきたものの中に、ほかにも Applicative なものがある。それは IO である。

    instance Applicative IO where
        pure = return
        a <*> b = do
            f <- a
            x <- b
            return (f x)

    pure というのは、繰り返しになるが、（引数を）再現できるような形で最小の文脈に値を入れるという意味である。
    だから pure が単なる return なのは納得がいく。
    return は何もしない I/O アクションを作る。ただ値を返すだけで、ターミナルに印字したりファイルを読み込んだりといった入出力操作は一切しない。
    （return から返されたものをなんらかの名前に束縛すればもちろんそれを操作できる。var <- return "hoge" とすると var は "hoge" :: String になる。
    　あとは GHCi 上でも、return "hoge" と打てば "hoge" が返ってくる。）

    もし <*> が IO に特殊化されたら、その型は
        (<*>) :: IO (a -> b) -> IO a -> IO b
    になるはずである。IO の場合の a <*> b の実装は、まず a という名の I/O アクションを実行して関数を手に入れて、その関数を f という名前に束縛する。
    次に b を実行してその結果を x という名前に束縛する。
    最後に、関数 f を x に適用し、それを結果として返している。
    実装には do 記法が使われている（do 構文にはいくつかの I/O アクションを 1 つに結合するのだった）。

    Maybe と [] に関しては、<*> 演算子は単に左辺の引数から関数を取り出しては右辺を写す操作だと解釈できた。
    IO に関する <*> 演算子は、取り出すところは同じだが、2 つの I/O アクションを 1 つに糊付けするにあたって **逐次実行** という意が新たに加わっている。
    <*> 演算子は、まず 1 つ目の I/O アクションから関数を取り出すが、結果を取り出したかったらその I/O を実行する必要があるというわけである。
    以下を見よ。
-}

myAction :: IO String
myAction = do
    a <- getLine
    b <- getLine
    return $ a ++ b

{-
    これはユーザに 2 行の入力を求め、その 2 行を結合したものを返す I/O アクションである。
    2 つの getLine I/O アクションと return を糊付けして作った。
    I/O 全体が a ++ b という値を持って欲しかったからである。このプログラムは以下のようにアプリカティブ・スタイルでも書ける。
-}

myAction' :: IO String
myAction' = (++) <$> getLine <*> getLine -- つまり pure (++) <*> getLine <*> getLine

{-
    箱の比喩で言えば、getLine とは実世界に出かけていって文字列を取ってきてくれる小さな箱だと思える。
    (++) <$> getLine <*> getLine を呼び出すと、この小さな箱を 2 つ送り出して端末から入力行を取得し、結合して返してくれる大きな箱が作られる。

    式 (++) <$> getLine <*> getLine の型は IO String である。つまりこの式は、String を返す他の I/O アクションと全く同様、ごく普通の I/O アクションなのである。
    だから、以下のような書き方もできる。
-}

mainn :: IO ()
mainn = do
    a <- (++) <$> getLine <*> getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a

--- ¶　関数もアプリカティブだよ
{-
    Applicative のインスタンスはまだある。(->) r、つまり関数がそうである。
    関数をアプリカティブとして使う機会はあまり多くないが、概念自体は面白いので、アプリカティブな関数のインスタンスがどのように実装されているか見てみよう。

        instance Applicative ((->) r) where
            pure x = (\_ -> x)
            f <*> g = \x -> f x (g x)

    ある値を、pure を使ってアプリカティブ値に包んだものは、元の値を生み出せないといけない（引数を再現できないといけない）。
    つまり、その値を再現できるような最小限のデフォルト文脈でなければならない。
    そこで、関数のアプリカティブなインスタンスの実装における pure は、値を取って「引数を無視して（関数の引数のことであって pure の引数ではない）つねにその値（pure の引数）を返す関数」を
    作るようになっている。(->) r インスタンスに特殊化した pure の型は
        pure :: a -> (r -> a)
    である。

    *Main> (pure 3) "blah!"
    3

    カリー化のおかげで関数適用は左結合になっているので、この括弧は省ける。

    *Main> pure 3 "blah!"
    3

    <*> のインスタンス実装は少々暗号じみているため、関数をアプリカティブ・スタイルで使う方法から見ていこう。

    *Main> :t (+) <$> (+3) <*> (*100)
    (+) <$> (+3) <*> (*100) :: Num a => a -> a

-}

ans :: Int
ans = (+) <$> (+3) <*> (*100) $ 5 -- 508

{-
    <*> を 2 つのアプリカティブ値に対して呼び出した結果はアプリカティブ値である。したがって、<*> を 2 つの関数（=アプリカティブ値）に使ったら関数が返ってくる。
    このコードでは何が起こっているのだろう？
    (+) <$> (+3) <*> (*100) と書くと、「引数を (+3) と (*100) に渡し、2 つの結果に対して + を使う」関数が出来上がる。
    この関数に引数 5 を与えると、まず (+3)　と (*100) が 5 に適用され、それぞれ 8 と 500 を返す。それから + が引数 8 と 500 を取って呼ばれ、508 を生み出す。
    次のコードも似たようなもの。
-}

anss :: [Double]
anss = (\x y z -> [x, y, z]) <$> (+3) <*> (*2) <*> (/2) $ 5 -- [8.0,10.0,2.5]

{-
    ここで作ったのは、3 つの関数 (+3)、（*2)、(/2) からの結果をもって関数 \x y z -> [x y z] を呼び出す関数。
    最後の引数 5 は、まず 3 つの関数にそれぞれ入り、出てきた返り値を引数にして \x y z -> [x y z] が呼び出されている。
-}

