{-# OPTIONS -Wall -Werror #-}
import Control.Monad

---_/_/_/_/_/_/_/_/_/_/_/---
-- 　  モナドがいっぱい　　　    --
---_/_/_/_/_/_/_/_/_/_/_/---

{-
    第 7 章で初めてファンクターの話をしたとき、ファンクターは関数で写せる値をあらわす　便利な概念であることを見た。
    第 11 章ではファンクターを一歩拡張してアプリカティブファンクターを導入し、ある種のデータ型は、文脈を持った値だと解釈できるようになった。
    アプリカティブファンクターを使えば、そのような文脈を保ったまま、通常の関数をそれらの値に適用できるのだった。

    この章では **モナド** を紹介する。
    モナドは強化されたアプリカティブファンクターである。
-}

-------------------------------
--　アプリカティブファンクターを強化する
-------------------------------

{-
    ファンクターを勉強し始めたとき、Functor 型クラスに属するさまざまな型は、すべて関数で写せることを見た。
    ファンクターを導入した動機は、「a -> b 型の関数と、f a というデータがあるとして、どうすれば等の関数を f a から f b への関数に変換できるだろう？」というものだった。
    Maybe a、リスト [a]、IO a などに対し、関数で写す方法を見てきた。
    a -> b 型の関数はなんと「r -> a 型の関数」を写すこともでき、その結果は「r -> b 型の関数」になることも見た。
    あるデータ型を関数で写したときの挙動を指定するには、fmap の型を見てから、
        fmap :: (Functor f) => (a -> b) -> f a -> f b
    Functor インスタンスを書き、fmap がそのデータ型を適切に処理できるようにすればよいのだった。

    それから、いくつかの疑問とともに、ファンクターを改良できる可能性が浮かび上がってきた。
    関数 a -> b が、はじめからファンクターに包まれていたらどうする？
    例えば Just (*3) があったとして、それを Just 5 に適用するには？
    その Just 5 が急に Nothing に変わったら？
    Maybe の代わりにリスト [(*2), (+4)] があったとして、それを [1,2,3] に適用sるうには？
    そもそも、そんなの動くの？　これらを解決するために、Applicative 型クラスを導入した。

        (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b

    Applicative 型クラスでは、通常の値をデータ型の中に入れる操作も可能になったのだった。
    例えば、1 を Just 1 に変えたり、[1] に変えたり、はたまた「何も副作用を起こさず 1 を返す I/O アクション」に変えたりできるのだった。
    この変換をしてくれる関数の名前は pure というんだった。
        *Main> pure 1 :: Maybe Int
        Just 1
        *Main> pure 1 :: [Int]
        [1]
        *Main> pure 1 :: IO Int
        1

    アプリカティブ値は、_変な_ 値、専門用語で言うと「文脈の付加された値」だとみなせる。
    例えば、文字 'a' はただの文字だが、Just 'a' は何らかの文脈がついている。
    Char 型の代わりに Maybe Char 型がきたとしたら、この値は文字かもしれないし文字がないことを表すのかもしれないということである。
    Applicative 型クラスは、これら文脈のついた値に、文脈を保ったまま普通の関数を適用させてくれる。例を見てみよう。

        *Main> (*) <$> Just 2 <*> Just 8
        Just 16
        *Main> (++) <$> Just "exdeath" <*> Nothing
        Nothing
        *Main> (-) <$> [3,4] <*> [1,2,3]
        [2,1,0,3,2,1]

    このようにアプリカティブ値として扱い始めると、Maybe a は失敗するかもしれない計算、[a] は複数の答えがありうる計算（非決定性計算）、IO a は副作用を伴う計算、などの意味を帯びてくるのだった。

    さて、モナドはある願いをかなえるための、アプリカティブ値の自然な拡張である。
    その願いとは「"普通の値 a (例: 'a') を取って文脈付きの値（例: Just 'a'）を返す関数" に、文脈付きの値 m a を渡したい」というもの。🧐❓
    言い換えると、a -> m b 型の関数を m a 型の値に適用したいということ。わかりやすく言うと、この関数が欲しいということである。

        (>>=) :: Monad m => m a -> (a -> m b) -> m b

    さて、「変な値 (例: Just 'a')」と、「普通の値を引数に取るけど変な値を返す関数 (例: 'a' -> Just 'a')」があったとき、どうやってその値を関数に食わせればよいだろう？
    これがモナドの一番の関心事である。
    これからは f a の代わりに m a と書くことにする。m は Monad の頭文字である。
    呼び方は変わるものの、モナドは >>= をサポートするアプリカティブファンクターにすぎない。関数 >>= はバインド（bind）と呼ばれる。
    普通の値 a と普通の関数 a -> b だったら、値を関数に食わせるのは造作もないことで、単に関数を値に適用すればよい。
    ところが、特定の文脈がつきまとう値を扱うとなると、その変な値を関数に食わせるとどうなるのか、文脈を保つにはどうするのか、ちゃんと考えないといけない。
    でも、やってみれば簡単だということがわかる！
-}

-------------------------------
--　Maybe から始めるモナド
-------------------------------

{-
    モナドが何者なのかぼんやりわかってきたところで、具体例を見ていこう。
    実は Maybe はモナドだったのである。

    Maybe a 型の値は a 型の値を表しているが、失敗する可能性という文脈付き。
    Just "dharma" という値は、文字列 "dharma" がそこに実在することを意味する。
    Nothing という値は、無を、あるいは文字列が何らかの計算の結果だとしたら、その計算が失敗したことを表している。

    ファンクターとして見た Maybe に対して関数を fmap すると、その Maybe が Just 値だった場合には、
    与えた関数が Just の中身に適用されるのだった。
    Nothing の場合は、Nothing のままだった。なぜなら関数を適用する相手がいないからである。

    *Main> fmap (++ "!") (Just "wisdom")
    Just "wisdom!"
    *Main> fmap (++ "!") Nothing
    Nothing

    アプリカティブファンクターとしての Maybe の機能も似たようなものである。
    ただし、アプリカティブファンクターになると、値だけでなく、値に適用する関数のほうにも文脈がつく。
    Maybe の Applicative インスタンスは、<*> を使って Maybe の中の関数を Maybe の中の値に適用しようとすると、
    関数と値が Just ならば結果が Just になる、そうでなければ結果は Nothing になる、というものだった。
    関数か値のどちらかが欠けていれば、無から適用結果をでっち上げるわけにはいかないから、失敗を伝播させる必要があるのだ。

        *Main> Just (+3) <*> Just 3
        Just 6

        *Main> Just reverse  <*> Nothing
        Nothing

    アプリカティブ・スタイルを使って複数の関数を Maybe 値に適用するときも、同じやり方でうまくいく。
    すべての引数が Just でなければ、結果は Nothing である！

        *Main> max <$> Just 3 <*> Just 6
        Just 6
        *Main> max <$> Just 3 <*> Nothing
        Nothing

    それではいよいよ、Maybe にとっての >>= をどう定義すればいいか考えていこう。
    >>= は、「モナド値（変な値、文脈付きの値）」と「普通の値を取る関数」を引数に取り、なんとかしてその関数をモナド値に適用してモナド値を得る。
    関数のほうは普通の値しか取れないのに、どうやってそんな芸当ができるのだろう？
    その答えを出すには、モナド値の文脈に立ち入る必要がある。

    この場合、>>= は Maybe a 型の値と a -> Maybe b 型の関数を取り、この関数をどうにかして Maybe a に適用するわけである。
    これをどうやって実現しているか探るには、Maybe がアプリカティブファンクターであるという知識が役立つ。
    さて、関数 \x -> Just (x+1) を考えよう。これは（普通の）数を取り、それに 1 を足して結果を Just に包む（ことで文脈を付ける）。
    例えば、この関数に 1 を食わせると Just 2 に評価され、100 を食わせると Just 101 に評価される。
    では、この関数に Maybe 値を食わせるにはどうしたらいいだろう？
    Maybe のアプリカティブファンクターとしての振る舞いから類推すると、この問いに答えるのは極めて簡単。
    Just 値がきたときは Just の中身を取り出し、それを関数に食わせればよい。
    Nothing 値がきたときは、関数はあるものの、それに適用すべき値がナッシングというわけだから、結果も Nothing とせざるを得ない。

    ひとまず >>= と呼ぶのはやめて applyMaybe という名前にする。
    これは「Maybe a 型の値」と「（普通の値を引数に取り、）Maybe b を返す関数」を引数に取り、どうにかしてその関数を Maybe a に適用してくれる関数である。
-}

applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
applyMaybe Nothing _ = Nothing
applyMaybe (Just x) f = f x -- f は `a -> Maybe b` 型であるため、ここは `Just f x` としないように。

-- 使ってみよう。
-- Maybe 値が左、関数が右に来るように、中置演算子表記で使ってみよう。

ans1 :: Maybe Int
ans1 = Just 3 `applyMaybe` \x -> Just (x+1) -- Just 4

ans2 :: Maybe String
ans2 = Just "smile" `applyMaybe` \x -> Just (x ++ " :) ") -- Just "smile :) "

ans3 :: Maybe Int
ans3 = Nothing `applyMaybe` \x -> Just (x+1) -- Nothing

{-
    この例では、Just 値と関数を引数に applyMaybe を呼び出したときは、単に Just の中の値に関数が適用されている。
    Nothing 値と関数を引数に呼び出すと、全体の結果が Nothing になっている。
    では、関数のほうが Nothing を返す場合はどうだろう？
-}

ans4 :: Maybe Int
ans4 = Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing -- Just 3

ans5 :: Maybe Int
ans5 = Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing -- Nothing

{-
    確かに期待通りの結果である。applyMaybe の左辺のモナド値が Nothing である場合には、全体の結果は Nothing になる。
    それから右辺の関数が Nothing を返した場合も、結果は Nothing である。
    これは Maybe をアプリカティブとして使ったときの挙動とよく似ている。
    式のどこかに Nothing があったら、答えも Nothing になるという挙動である。

    どうやら「変な値」に「普通の値を取って変な値を返す関数」を適用する方法が見えてきた。
    この例では「Maybe は失敗したかもしれない計算を表す」というイメージを心に描いて設計することで、これが実現できた。
    「で、これって何が便利なの？」という疑問が聞こえてきそう。
    実際、アプリカティブファンクターのほうがモナドよりも強力に思えるかもしれない。
    だってアプリカティブファンクターは、ごく普通の関数を文脈付きの値に適用できるようにしてくれるのだから。
    ところがどっこい、モナドも同じことができるのである。
    さらにモナドにはできてアプリカティブファンクターにはできないこともあるのである。

    Maybe モナドは少し置いておいて、まずは、モナドが属する型クラスを見ていこう。
-}

-------------------------------
--　Monad 型クラス
-------------------------------

{-
    ファンクターには Functor 型クラスがあり、アプリカティブファンクターには Applicative 型クラスがあるように、モナドにも型クラス Monad がある。

    class Applicative m => Monad (m :: * -> *) where
        return :: a -> m a

        (>>=) :: m a -> (a -> m b) -> m b
        (>>) :: m a -> m b -> m b
    
        fail :: String -> m a
        fail s = errorWithoutStackTrace s

    return 関数は Applicative 型クラスの　pure と同じもの。
    だから、名前は違っていてもすでにおなじみである。

    return の型は a -> m a である。
    return は、値を取って、その値を再現できるような最小のデフォルト文脈に入れる。
    return は、第 8 章で I/O を扱ったときすでに登場していた。そのときは、値を返すだけで何も I/O をしない、なんちゃって I/O アクションを作るために return を使ったのだった。
    Maybe の場合は、return は値を Just に入れて返す。

        *Main> return 20 >>= \x -> Just (x+1)
        Just 21

    次の関数は >>=、又の名をバインド。これは関数適用に似ているが、普通の値を取って通常の関数を適用するのではなく、
    モナド値（つまり、文脈付きの値）を取って、それに「通常の値を取るがモナド値を返す関数」を適用する（上の節では `applyMaybe` として実装した関数が >>= である）。

    それから、>> がある。これにはデフォルト実装があるのであまり詳しくは解説しない。
    Monad インスタンスを実装するときも、このデフォルト実装を上書きすることは滅多にない。

    Monad 型クラスの最後の関数は fail である。
    ユーザーがコードの中から fail を呼び出すことは決してなく、もっぱら Haskell システムが呼び出す。
    fail はモナド用の特別な構文において、パターンマッチに失敗してもプログラムを以上終了させず、失敗をモナドの文脈の中で扱えるようにするものである。
    これについては後で見るので、今はさほど気にしなくて良い。

    これで Monad 型クラスがどんなものなのかわかった。では、Maybe の Monad インスタンスの実装を見ていこう。

    instance Monad Maybe where
        return x = Just x
        Nothing >>= f = Nothing
        Just x >>= f = f x
        fail _ = Nothing

    return は pure と同じだから、目を瞑っていても書ける。
    Applicative 型クラスのときと同様、Just に包むだけ。
    関数 >>= は、さっきの applyMaybe と同じ。左辺の Maybe a を右辺の関数に食わせるとき、失敗するかもしれない計算という文脈の意味を考えれば、
    左辺に Nothing がきていれば Nothing を返す、Just がきていれば中身を取り出して f を適用する、という設計になる。

    モナド化した Maybe で遊んでみよう。
-}

foo :: Maybe String
foo = return "What" -- foo は Just "What" になる

foo' :: Maybe Int
foo' = Just 9 >>= \x -> return (x*10) -- Just 90

foo'' :: Maybe Int
foo'' = Nothing >>= \x -> return (x*10) -- Nothing

-------------------------------
--　綱渡り
-------------------------------

{-
    失敗するかもしれない計算という文脈を損なうことなく、Maybe a 型の値に a -> Maybe b 型の関数を適用する方法がわかったところで、
    >= を繰り返し使って Maybe a 値を返す複数の計算を扱う方法を見ていこう。

    バランス棒の左右に鳥が止まる問題を考える。
    左右の鳥の数の差が 3 以内（3 を含む）であれば棒はバランスするが、4 以上になると棒はバランスを崩す。
-}

-- ¶　ひたすらコーディング
{-
    バランス棒は、単に整数のペアとして表現できる。
    ペアの第一成分は左側にいる鳥の数を、第二成分は右側にいる鳥の数を表すことにする。
-}

type Birds = Int
type Pole = (Birds, Birds)

{-
    まず、Int の型シノニムを作り、Birds と名付ける。これは、そこにいる鳥の数を荒wす整数である。
    それから (Birds, Birds) の型シノニムを Pole と名付ける。
    では、鳥の数を取って、バランス棒の左側もしくは右側に鳥をとまらせる関数を作ろう。
-}

landLeft :: Birds -> Pole -> Pole
landLeft n (left, right) = (left + n, right)

landRight :: Birds -> Pole -> Pole
landRight n (left, right) = (left, right + n)

{-
    鳥を飛び立たせる処理は、負の数の鳥がとまる処理で代用する。
    Pole に鳥をとまらせる関数は Pole を返すので、landLeft と landRight は好きなだけ合成して使える。

    > landLeft 2 (landRight 1 (landLeft 1 (0, 0)))
    (3,1)

    ただ、今の場合、バランス棒を先に書いて、鳥をとまらせる関数を後に書いた方が読みやすそう。
    そこで、次のような関数 -: を定義する:
-}

(-:) :: a -> (a -> b) -> b
x -: f = f x

{-
    これで、関数を適用するのに、まず引数、次に関数を書けるようになる。

        > 100 :- (*3)
        300

    この形式を使えば、鳥を次々に止まらせる処理をさっきよりも読みやすく書ける。

        > (0,0) -: landLeft 1 -: landRight 1 -: landLeft 2
        (3,1)

    これで直感的に理解しやすくなった！
-}

-- ¶　うわ〜落ちる！
{-
    左右に止まっている鳥の数の差が 3 より大きくなったときにバランスを崩してしまうことを表現するために、landLeft 関数と landRight 関数を修正しよう。
    landLeft 関数と landRight 関数は、失敗を表現できる必要がある。
    棒がバランスを取れている場合は新しいバランス棒の状態を返すが、鳥のとまり方が偏りすぎた場合は失敗を返すようにしたい。
    失敗を表現したいとなったら、これはもう Maybe を使うしかない！
-}

landLeft' :: Birds -> Pole -> Maybe Pole
landLeft' n (left, right)
    | abs ((left + n) - right) < 4 = Just (left + n, right)
    | otherwise = Nothing

landRight' :: Birds -> Pole -> Maybe Pole
landRight' n (left, right)
    | abs (left - (right + n)) < 4 = Just (left, right + n)
    | otherwise = Nothing

{-
    使用例
        *Main> landLeft' 2 (0, 0)
        Just (2,0)
        *Main> landLeft' 10 (0,3)
        Nothing
-}

{-
    Maybe を使って失敗（棒がバランスを崩した状態である Nothing）を表現できるようになったのは素晴らしいが、鳥をとまらせる操作を合成する能力を失ってしまったのでは？
    もう、landLeft 1 (landRight 1 (0, 0)) とは欠けなくなってしまった。
    なぜなら、Pole 型の (0, 0) に landRight 1 を適用すると、Pole 型ではなく、Maybe Pole が返ってくるから。
    landLeft 1 は Pole 型を取る関数なので、Maybe Pole は受け付けてくれない。

    ・・・ということで、ここで >>= の出番！
-}

bou :: Maybe Pole
bou = landRight' 1 (0, 0) >>= landLeft' 2 -- Just (2,1)

{-
    LandLeft' 2 は Pole -> Maybe Pole 型の関数だった。landRight 1 (0,0) の結果である Maybe Pole は、
    そのままでは landLeft 2 に食わせられないので、>>= を使って、文脈を保ったまま landLeft 2 に渡す。
    >>= はまさに、Maybe を「文脈付きの値」として扱うための道具だと言えるだろう。
    現に、Nothing を landLeft 2 に渡すと、結果は Nothing になり、失敗が伝播するのがわかる。
-}

muri :: Maybe Pole
muri = Nothing >>= landLeft' 2 -- Nothing

{-
    このように、通常の値を引数に取る関数にモナド値を渡せる >>= を使うことで、「鳥がとまる」という失敗するかもしれない操作を合成できるようになった。
    鳥がとまる一連のイベントを次のように表現できる:
-}

stick :: Maybe Pole
stick = return (0,0) >>= landRight' 2 >>= landLeft' 2 >>= landRight' 2 -- Just (2,4)

{-
    まず return を使って、バランス棒の状態を Just でくるんだ。
    直接 (0,0) に landRight' 2 を適用するところ（`landRight' 2 (0, 0)`）から始めてもよかったが（それでも結果は同じ）、すべての関数に >>= を使うほうが統一感がある。
    Just (0,0) が landRight 2 に食われて Just (0,2) になる。それがまた landLeft 2 に食われて Just (2, 2) になり……、というふうに続く。

    また、たとえば、次のような例を考えよう:
-}

pole :: Maybe Pole
pole = return (0, 0) >>= landLeft' 1 >>= landRight' 4 >>= landLeft' (-1) >>= landRight' (-2) -- Nothing

{-
    上記は、Maybe を導入していない状態の関数（' 無しの landLeft, landRight）でやると、
    途中で左右の鳥の数の差が 4 以上になるにもかかわらず、なまじ最終状態における左右の鳥の数の差が 3 以内だから失敗したとみなされない。

    それを、Maybe を導入してモナド適用（>>=）を使うことで、左右の鳥の数の差が 4 以上になった瞬間に失敗（Nothing）扱いになり、
    その失敗が最終結果まで伝播してくれている。

    Maybe をアプリカティブ値として扱うだけでは、ここまでのことは不可能だっただろう。
    無理にやろうとしても、アプリカティブファンクターには、アプリカティブ値どうしをこのように深く相互作用させることはできないので、行き詰まる。
    アプリカティブにできることは、せいぜい通常の関数にアプリカティブスタイルで引数を渡すことくらいなのである。
    アプリカティブ演算子たちは、アプリカティブ値からそれぞれの文脈にしたがって結果を取り出しては通常の関数を適用し、結果をまたアプリカティブ値に入れて返してくれる。
    しかし、アプリカティブ値どうしを相互作用させることは苦手なのである。
    ところが、今回の棒の例では、各ステップは以前のステップの結果に依存している。鳥たちがやってくるたびに、直前のステップを踏まえて今回の結果が検証され、
    バランスがとれているかどうかを調べる。こうして鳥がうまくとまれたかどうかが判定されるのである。
-}

--- ¶　ロープの上のバナナ
{-
    さて、今度はバランス棒にとまっている鳥の数によらず、いきなりバランスを崩させて落っことす関数を作ってみよう。
    この関数を banana を呼ぶことにする。
-}

banana :: Pole -> Maybe Pole
banana _ = Nothing

{-
    この関数は鳥をとまらせる関数と混ぜて使える。
    banana は引数に何を渡されようと、無視して失敗を返すようにできているので、banana を呼べば必ず落っことせる。
-}

bananaed :: Maybe Pole
bananaed = return (0,0) >>= landLeft' 1 >>= banana >>= landRight' 1 -- Nothing

{-
    ところで、入力に関係なく規定のモナド値を返す関数だったら、自作せずとも >> 関数を使うという手がある。
    次が >> のデフォルト実装である:

        (>>) :: (Monad m) => m a -> m b -> m b
        m << n = m >>= \_ -> n

    普通の関数なら、引数を無視して規定の値を返すような関数の結果は、その規定値そのものである。
    ところが、モナド値を扱う場合は、モナドとしての文脈と意味を考慮する必要がある。
    Maybe 版の >> の動作は、以下のような感じ。

    *Main> Nothing >> Just 3
    Nothing
    *Main> Just 3 >> Just 4
    Just 4
    *Main> Just 3 >> Nothing
    Nothing

    一番目の例では、Maybe モナドの文脈が考慮された結果、「規定値」であるはずの Just 3 が失敗に置き換わっている。
    >> を >>= \_ -> で置き換えてみれば、何が起こっているのか簡単に理解できる。
        Nothing >> Just 3 は Nothing >>= \_ -> Just 3

    >>= で連結した処理中での banana 関数は、>> と Nothing という、失敗することが保証された組み合わせで置き換えられる。
-}

bananaed_ :: Maybe Pole
bananaed_ = return (0,0) >>= landLeft' 1 >> Nothing >>= landRight' 1 -- Nothing

{-
    ところで、Maybe を失敗の文脈付きの値として扱って、モナド適用により関数に食わせるという賢明な選択をしなかったらどうなっていたか？
    バランス棒に鳥をとまらせる一連の処理は次のようになっていたはず:
-}

routine :: Maybe Pole
routine = case landLeft' 1 (0, 0) of
    Nothing -> Nothing
    Just pole1 -> case landRight' 4 pole1 of
        Nothing -> Nothing
        Just pole2 -> case landLeft' 2 pole2 of
            Nothing -> Nothing
            Just pole3 -> landLeft' 1 pole3 -- Just (4, 4)

{-
    まずバランス棒の左側に鳥を一羽とめ、成功したか失敗したかによって場合訳をする。失敗していた場合には Nothing を返す。
    成功していた場合は、右側に鳥をとめる処理に進み、また場合分けをして……という繰り返し。
    この巨大で醜いコードを、>>= による素敵なモナド適用の連鎖で書き直すのは、Maybe モナド布教コードの定番。
    Maybe モナドを使うと、失敗するかもしれない処理が連続するコードをとても簡潔に書けるのである。

    Maybe モナドの >>= の実装は、まさにこの「値が Nothing かどうかを判定し、その知識に基づいて動作を変える」というロジックになっている。
    もし入力値が Nothing なら、>= は直ちに Nothing を返す。
    入力が Nothing でなければ、Just の中身を利用して計算を進める。

    この節では、関数の返り値を失敗処理をサポートする値に変えることで、関数がもっと便利になる例を見た。
    関数の返り値を Maybe 値にし、関数適用を >>0 に変えるだけで、ほとんど手間をかけずに失敗を処理するメカニズムを組み込むことができた。
    これも、>>= が、関数を値に適用するにあたって、値が持っている文脈を保存するようにできているおかげである。
    Maybe の場合、文脈とは「この値は計算に失敗しているかもしれない」というものだった。
    なので、Maybe 値に関数をモナド適用すると、常に失敗の可能性が考慮されたコードが自動的に出来上がるのである。
-}

-------------------------------
--　do 記法
-------------------------------
{-
    haskell にとってモナドはとても便利なので、モナド専用構文まで用意されている。
    その名は do 記法。
    do 記法は、すでに第 8 章で、複数の I/O アクションを 1 つに糊付けするときに使った。
    実は、do 記法は IO モナドだけでなくあらゆるモナドに使える。
    といっても基本は同じで、do 記法は複数のモナド値を糊付けするものである。
    モナドを使ったおなじみのこんなコードを見てみよう:
-}

bikkuri :: Maybe String
bikkuri = Just (3::Int) >>= (\x -> Just (show x ++ "!")) -- Just "3!"

{-
    このコードを実行すると、ラムダ式の中の x に 3 が入る。
    このラムダ式の中では、3 はモナド値でなく通常の値として扱えるわけである。 
    では、このラムダ式の中にもう 1 つ >>= があったらどうなるだろう？
-}

exclaimation :: Maybe String
exclaimation = Just (3::Int) >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y))) -- Just "3!"

{-
    >>= の入れ子構造である。
    外側のラムダ式の中では、Just "!" をラムダ式 \y -> Just (show x ++ y) に食わせている。このラムダ式の中では、y は "!" になる。
    また、x は、外側のラムダ式が実行されたときに 3 が入ったままである。
    これを見ていると let 構文を思い出す:
-}

bun :: String
bun = let x = 3:: Int; y = "!" in show x ++ y -- "3!"

{-
    この 2 つの例は似ているが、>>= のほうで使っている値はモナド値であるという大きな違いがある。
    失敗の文脈付きの値なのである。だから、好きな箇所を失敗で置き換えられる。
-}

nothin1 :: Maybe String
nothin1 = Nothing >>= (\x -> Just "!" >>= (\y -> Just (show (x :: String) ++ y))) -- Nothing

nothin2 :: Maybe String
nothin2 = Just (3::Int) >>= (\x -> Nothing >>= (\y -> Just (show x ++ y))) -- Nothing

nothin3 :: Maybe String
nothin3 = Just (3::Int) >>= (\_ -> Just "!" >>= (\_ -> Nothing)) -- Nothing

{-
    最初の例では Nothing を関数に渡しているので、当然 Nothing が返っている。
    次の例では、Just 3 を関数に渡して、x が 3 になっている。ところが内側のラムダ式には Nothing を渡しているから、
    そいつは Nothing を返し、そのせいで外側のラムダ式の結果も Nothing になっている。

    やはり、操作したい値がモナド値かどうかという違いはあるものの、この操作は let 式で値を変数に束縛する操作に似ている。
    この類似性をもっと明確にするために、今の式をスクリプト風に書き換えよう
-}

exclaimation' :: Maybe String
exclaimation' = Just (3 :: Int) >>= (\x ->
                Just "!"        >>= (\y ->
                Just (show x ++ y))) -- Just "3!"

{-
    面倒なラムダ式をいっぱい書かなくても済むよう、Haskell には do 記法が備わっている。
    do 記法を使えば、さっきのコードは次のように書ける:
-}

exclaimation'' :: Maybe String
exclaimation'' = do
    x <- Just (3 :: Int)
    y <- Just "!"
    Just (show x ++ y) -- Just "3!"

{-
    いちいち Maybe 値が Just か Nothing かなんて場合訳せずとも、Maybe 値から生の値が取り出せる気分になる。
    素晴らしい！　もし中身を取り出そうとする値のいずれかが Nothing だったら、do 式全体も Nothing になる。
    この do 式の中では、Maybe モナドから（存在するとおぼしき）値を取り出しつつ、値につきまとう文脈の処理は >>= に任せているのである。

    モナド値を連鎖させた式と等価なものを、ずっと簡潔に表せる記法が do 式なのである。
-}

--- ¶　do 自由自在
{-
    do 式は、let 行を除いてすべてモナド値で構成される。
    モナドの結果を調べるには <- を使う。例えば、変数を <- で Maybe String の結果に束縛すると、その変数の型は String になる。
    これは >>= を使ってモナド値をラムダ式に食わせたときとまったく同じ。

    do 式の最後のモナド値（上の例で言うと Just (show x ++ y) が相当する）だけは <- で結果を束縛できない。
    do 記法は　>>= とラムダ式を使う表記に書き直せるはずだが、最後のモナドで <- を使っても、それを受けるべきラムダ式がないからである。
    その代わり、最後のモナドの返り値は、それまでの失敗の可能性をすべて踏まえた上で、do 式で糊付けしたモナド全体の結果になる。
    exclamation' と exclamation'' を見比べればわかるだろう。
-}


--- ¶　バランス棒ふたたび
{-
    先ほどのバランス棒の動作も、もちろん do 記法で書ける。
    landLeft と landRight は鳥の数とバランス棒を引数に取り、新しい棒の状態を Just に包んで返す。
    ただし棒が滑った場合は Nothing を返す。
    各ステップは、それまでの結果に依存しているので、>>= を使って連結し、各ステップからの失敗の文脈が累積するようにするのだった。

    例えば、左に 2 羽、右に 2 羽、それから左に 1 羽の鳥が来る処理は do 記法では次のように書ける。
-}

routine' :: Maybe Pole
routine' = do
    start <- return (0,0)
    first <- landLeft' 2 start
    second <- landRight' 2 first
    landLeft' 1 second
    -- 結果が Just (3,2) となるので、バランス棒が無事バランスを保っていることがわかる。

{-
    >>= を使って書いていたときは、return (0,0) >>= landLeft' 2 >>= landRight' 2 ... というように書けたが、
    do 式を使う場合は各行がモナド値である必要があるので、直前の Pole の状態に名前をつけて landLeft' 関数や landRight' 関数に明示的に渡さないといけない。

    1 行ごとに処理が書いてある do 式が、手続き型言語のプログラムに見えるかもしれない。でも do 式では、それ以前の行の結果に依存する値の列が、
    成功または失敗の文脈とともに書いてあるにすぎない。

    バナナで棒のバランスを強制的に崩したい場合は、次のようになる:
-}

routine'' :: Maybe Pole
routine'' = do
    start <- return (0,0)
    first <- landLeft' 2 start
    _ <- Nothing
    second <- landRight' 2 first
    landLeft' 1 second
        -- 結果は Nothing になる

{-
    do 記法の中で、<- による変数への束縛をせずにモナドを使うと、結果を無視したいモナドの後に >> をつけたのと同じになる。
    モナドをつなげるけれども結果には興味がないから無視するわけである。
    同じ処理は _ <- Nothing としても書けるが、<- を省略したほうがきれい。

    （手元の環境だと、_ <- Nothing としないと
        error: [-Wunused-do-bind, -Werror=unused-do-bind]
        A do-notation statement discarded a re１lt of type
        ‘ghc-prim-0.5.3:GHC.Types.Any’
        Suppress this warning by saying ‘_ <- Nothing’
    というエラーが出た）

    いつ do を使い、いつ >>= を使うかの選択はプログラマ次第。バランス棒の例では、各モナドはもっぱら直前のモナドの結果に依存しているから、
    >>= を使った方が連続的に書けるし良いのではないか。do 記法では、どの時点のバランス棒に鳥をとまらせるのか明示的に書かないといけない。
    でも常に 1 つ前のステップの結果を使うんだから do を使うまでもないよね、という。。
-}

--- ¶　パターンマッチと失敗
{-
    do 記法でモナド値を変数名に束縛するときには、let 式や関数の引数のときと同様、パターンマッチが使える。
    これが do 式におけるパターンマッチの例である。
-}

justH :: Maybe Char
justH = do
    (x:_) <- Just "hello"
    return x -- 結果: Just 'h'。バインド演算子を使って書き換えるなら Just "hello" >>= \(x:_) -> return x  といった感じか

{-
    ここでは、パターンマッチを使って文字列 "hello" の先頭の文字を取り出し、それをモナド全体の結果としている。
    だから justH は Just 'h' と評価される。
    もしこのパターンマッチが失敗したらどうなるのだろう？
    関数定義では、あるパターンマッチが失敗したら、次のパターンを試すことになっていた。
    ある関数のすべてのパターンマッチに失敗したら、エラーが投げられ、プログラムは異常終了する。
    これに対し、let 式でパターンマッチに失敗した場合、let 式には複数のパターンマッチを次々に試す仕組みはないので、直ちにエラーになる。

    do 式の中でパターンマッチが失敗した場合、Monad 型クラスの一員である fail 関数が使われるので、異常終了という形ではなく、
    そのモナドの文脈に合った形で失敗を処理できる。
    fail のデフォルト実装は以下:

        fail :: (Monad m) => String -> m a
        fail msg = error msg

    あ、デフォルトでは、fail はプログラムを異常終了させるようだ。しかし、Maybe のような失敗を表現できる文脈を持つモナドでは、
    通常は独自に fail を実装している。Maybe の fail はこんな感じ:

        fail _ = Nothing

    エラーメッセージを無視して Nothing を作っている。
    これにより、do 記法で書かれた Maybe モナドの内部でパターンマッチに失敗したときは、do 式全体が Nothing を返す。
    プログラムが異常終了するよりも、Nothing が得られるほうが嬉しい。
    パターンマッチに失敗するような do 式を書いてみよう:
-}

wopwop :: Maybe Char
wopwop = do
    (x:_) <- Just ""
    return x
    -- 結果: Nothing

{-
    このパターンマッチは失敗するので、その効果は失敗するパターンマッチのある行全体を Nothing で置き換えたのと同じ。
    以上で見たとおり、パターンマッチが失敗しても全プログラムが巻き添えになって落ちることはなく、モナドの文脈で失敗が発生するだけで済んでいる。
-}

-------------------------------
--　リストモナド
-------------------------------
{-
    これまでのところ、Maybe は失敗の文脈の付いた値として解釈できること、>>= を使って Maybe 値を関数に食わせることで失敗処理を簡単に記述できることを見てきた。
    この節では、リストのモナドとしての側面を扱うことで、非決定性を伴うコードをきれいに読みやすく書く方法を見ていく。

    第 11 章では、アプリカティブのリストは非決定性計算を表すと言った。
    例えば、5 という値は決定的である。つまり、どう評価してもただ 1 つの決まった計算結果にしかならず、その値は吉である。
    一方、[8,9,3] のような値は複数の計算結果を含んでいるとも、複数の候補値を同時に重ね合わせたような 1 つの値であるとも解釈できる。
    リストをアプリカティブ・スタイルで使うと、非決定性を表現していることがはっきりする。

        > (*) <$> [1,2,3] <*> [10,100,1000]
        [10,100,1000,20,200,2000,30,300,3000]

    左辺リストの要素と右辺リストの要素の、すべてのありうる組み合わせの積が、答えのリストに含まれている。
    非決定性計算ではたくさんの選択肢に出くわすが、その都度すべてを試す。
    すると、最終結果はもっとたくさんの候補値を含んだ非決定的値になるわけである。

    この非決定性計算という文脈は、うまくモナドに焼き直すことができる。
    リストの Monad インスタンスは、次のように書ける:

        instance Monad [] where
            return x = [x]
            xs >>= f = concat (map f xs)
            fail _ = []

    return は pure と同じなので、リストの return がなんなのかもわかる。
    return は（pure と同様、）値を取って、その値を再現できるような最小限の文脈に入れる。
    というわけで、return は引数の値が 1 つだけ入っているようなリストを作って返すわけである。
    return は、普通の値をリストにくるんで非決定な値に混ぜたいときに便利。

    >>= は「文脈付きの値（モナディックな値）」を、「通常の値を取って文脈付きの値を返す関数」に食わせる演算だった。
    もし関数が文脈付きの値でなく通常の値を返すものだったとしたら、>>= はここまで便利ではなかっただろう。
    なぜなら、一度使うと、文脈はなくなってしまうからである。

    それでは、非決定的値を関数に食わせてみよう:
-}

lsMona :: [Int]
lsMona = [3,4,5] >>= \x -> [x,-x] -- [3,-3,4,-4,5,-5]

{-
    Maybe に >>= を使うと、失敗の可能性を考慮しながら、モナド値を関数に供給できた。
    今度はモナドが非決定性計算を処理してくれている。
    [3,4,5] は非決定的値であり、それを食わせている関数も非決定的値を返すようになっている。
    最終結果も非決定的であり、リスト [3,4,5] から 1 つの要素を選んで \x -> [x, -x] に食わせるすべての場合を尽くしている。
    関数のほうも、数を取って 2 通りの答えを返す。

    なお、計算を詳細に追ってみると、、
    リストにおける >>= の定義は、上述のとおり xs >>= f = concat (map f xs) である。
    map (\x -> [x, -x]) [3,4,5] の結果は [[3,-3], [4,-4], [5, -5]] という二重リストになるが、
    >>= の計算では、そのあとにこれが concat されて [3, -3, 4, -4, 5, -5] になる。

    非決定性計算は、失敗する可能性のある計算の上位互換になっている。
    空リスト [] は、返すべき値が何もない、ということなので、Nothing とよく似ている。
    だから、失敗は空リストで表せばいいのである。
    Maybe と同様、fail のエラーメッセージは無視される（fail の実装は `fail _ = []` だった）。
    では、失敗するリストで遊んでみよう。
-}

failLs :: [String]
failLs = [] >>= \_ -> ["bad", "mad", "rad"] -- []

failLs' :: [Int]
failLs' = [1 :: Int, 2 :: Int, 3 :: Int] >>= \_ -> [] -- []

{-
    最初の例では、ラムダ式に空リストを食わせている。リストには要素がないので、次段の関数に渡すものがない。
    だから、結果は空リストになる。これは Nothing を渡したときと同じ。
    次の例では、3 つの要素が関数に渡されるが、関数のほうが引数を無視して空集合を返している。
    とにかく関数のほうが何を与えても失敗してばかりなので、全体の結果も失敗（空リスト）となっている。

    Maybe のときと同様、>>= を使えばリストをいくつでも連結して非決定性を伝播させることができる。
-}

nondeterPropagation :: [(Int, Char)] 
nondeterPropagation = [1,2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch) -- [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
                                                          -- [(n, ch)] と書いてもいい。

{-
    [1,2] から出てきた数が n に束縛され、['a', 'b'] から出てきた文字が ch に束縛される。
    それから return (n, ch) をすると（ここは [(n,ch)] と書いても良い）、ペア (n, ch) がデフォルトの文脈に入る。
    この場合の return のルールは、「(n,ch) の情報を含んでいる、できる限り短いリストを返しなさい、非決定性をなるべく小さくしなさい」である。
    そうすれば、文脈の変化（※）も最小限になる。（※ return にくるんだことで付加される影響、変化。）
    このプログラムは、「[1,2] の各要素 n、['a', 'b'] の各要素 ch に対して、タプルを作りなさい」という意味になっている。

    一般的に言って、return は値を最小限の文脈に包むので、文脈に余計な影響（Maybe だったら失敗したり（失敗の可能性を文脈上含めるということではなく、実際に失敗したという情報を加えてしまうようなこと）、
    リストだったら場合の数が増えたり）を及ぼさず、ただなんらかの結果を提示するだけである。

    非決定性計算を組み立てたものは、場合分けの木構造とみなすことができる。
    リストが表現する可能な選択肢のそれぞれが木構造の枝分かれに対応している。

    さっきの例を do 記法で書き直すと以下のようになる:
-}

listOfTuples :: [(Int, Char)]
listOfTuples = do
    n <- [1,2]
    ch <- ['a', 'b']
    return (n, ch)
        -- [(1,'a'),(1,'b'),(2,'a'),(2,'b')]

{-
    こう書くと、n は [1,2] から、ch は ['a', 'b'] から 1 つ選んだものだというのがはっきりする。
    Maybe のときと同じで、モナド値から要素を取り出して普通の値であるかのように扱えている。
    そして、裏では >>= が文脈の面倒を見てくれている。この場合の文脈は非決定性である。
-}

-- ¶　do 記法とリスト内包表記
{- リストの do 記法と、以下を見比べてみよう。 -}

lsOfTup :: [(Int, Char)]
lsOfTup = [(n,ch) | n <- [1,2], ch <- ['a', 'b']] -- [(1,'a'),(1,'b'),(2,'a'),(2,'b')]

{-
    そう、リスト内包表記である。
    do 記法では、n は [1,2] の中の値を順に取り、その各々に対して ch は ['a', 'b'] のどれかになり、
    そして最後の行は (n,ch) をデフォルト文脈（単一要素リスト、非決定性が増えない）に入れる。
    リスト内包表記でも同じことが起こっているが、最後の (n, ch) を return で包む操作は、リスト内包表記の出力パートがやってくれるので省かれている。

    実は、リスト内包表記はリストモナドの構文糖衣にすぎないのである。
    リスト内包表記も do 記法も、内部では >>= を使った非決定性計算に変換されている。
-}

-- ¶　MonadPlus と guard 関数
{-
    さて、リスト内包表記では、出力する要素を選別（filter）することができた。
    例えば 7 の付く数だけを選んで出すには
        [x | x <- [1..50], '7' `elem` show x]
        > [7,17,27,37,47]
    というふうに数 x を show で文字に変え、それから文字 '7' が含まれているか調べる。
    この選別はどんなリストモナドに翻訳されるのだろう？　それを知るには、guard 関数と MonadPlus 型クラスを学ぶ必要がある。
    MonadPlus は、モノイドの性質を併せ持つモナドを表す型クラスである。
    以下がその定義。
        class Monad m => MonadPlus m where
            mzero :: m a
            mplus :: m a -> m a -> m a
    mzero は、Monoid 型クラスでいう mempty に対応する概念であり、mplus は mappend に対応している。
    リストはモノイドでもあるから、MonadPlus のインスタンスにできる。
        instance MonadPlus [] where
            mzero = []
            mplus = (++)

    リストに関する mzero は、候補が 1 つもない、失敗した非決定性計算を表している。
    mplus は 2 つの非決定値を 1 つの値にくっつける。guard 関数の定義は以下のようになる:
        guard :: (MonadPLus m) => Bool -> m ()
        guard True = return ()
        guard False = mzero
    guard は真理値を引数に取る。引数が True なら、guard は () を成功を表す最小限の文脈に入れる（return () する）。
    引数が False なら、guard は失敗したモナド値を作る（mzero (= []) になる）。

    💣 Control.Monad を import しないと使えないっぽい。
-}

guard1 :: Maybe ()
guard1 = guard ((5 :: Int) > (2 :: Int)) -- Just ()

guard2 :: Maybe ()
guard2 = guard ((1 :: Int) > (2 :: Int)) -- Nothing

guard3 :: [()]
guard3 = guard ((5 :: Int) > (2 :: Int)) -- [()]

guard4 :: [()]
guard4 = guard ((1 :: Int) > (2 :: Int)) -- []

{-
    面白そうではあるが、どこが便利なのだろう？
    リストモナドでは、guard を使って解の候補をふるい落とすことができる。
-}

var :: [Int]
var = [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x) -- [7,17,27,37,47]

{-
    この結果は、リスト内包表記 [x | x <- [1..50], '7' `elem` show x] と同じ！　どうして guard を使ってできたのだろう？
    まずは guard 関数を >> につなぐと何が起こるか見てみよう。
-}

hoge1 :: [String]
hoge1 = guard ((5 :: Int) > (2 :: Int)) >> return "cool" -- ["cool"]

hoge2 :: [String]
hoge2 = guard ((1 :: Int) > (2 :: Int)) >> return "cool" -- []

{-
    guard が成功すれば、空タプルの入ったモナド（リストモナドなら [()] だし、Maybe なら Just ()）が返ってくる。
    そこですかさず >> を使えば、その空タプルを無視し、何か別のものを返すことができる
    （>> は、文脈を考慮しつつ規定の値を返す。>> の左辺が Nothing や [] などの、失敗を表すものなら >> の結果も Nothing や [] などの失敗値になる）。
    ところが、その guard が失敗したら、後ろの return もつられて失敗する。空リストを >>= に食わせたら、答えは必ず空リストになるからである。
    guard は、実は「引数が False なら直ちに失敗を投げよ。True ならダミーの値 () が入っている成功を作れ」と言っているのである。
    guard がやっているのは、計算を続けてよいかどうかの判断！

    先ほどの例を do 記法で書き直すと以下のようになる:
-}

sevensOnly :: [Int]
sevensOnly = do
    x <- [1..50]
    guard ('7' `elem` show x)
        -- この部分は if ('7' `elem` show x) then return () else [] と書いたのと同じ。
        -- _ <- Nothing とすれば結果を無視することになる（routine'' 関数の説明を参照）のと同じで、do 式中に [] が出てくると、そのときの x は無視される。
    return x
        -- [7,17,27,37,47]

{-
    ※ ここでもし、最後に return を使って x を返すのを忘れたとすると、計算結果はただの空タプルのリストになってしまう。

    == この節のまとめ ==
    リスト内包表記でフィルタを使うのは guard と同値なのである。
-}

-- ¶　騎士の旅
{-
    ここで、非決定性計算を使って解くのにうってつけの問題を紹介しよう。
    チェス盤の上にナイトの駒が 1 つだけ乗っている。
    ナイトを 3 回動かして特定のマスまで移動させられるか、というのが問題である。
    チェス盤上でのナイトの位置は、単なる数のペアで表現することにしよう。
    1 つ目の数が横軸、2 つ目が縦軸である。

    ナイトの現在位置を表す型シノニムを作ろう:
-}

type KnightPos = (Int, Int)

{-
    さて、ナイトが (6,2) から出発したとする。果たしてナイトは、ちょうど 3 手で (6,1) に移動できるだろうか？
    (6,1) に行くための最善手は？　それがわかったら、条件を満たす手順をすべて求めてみよう。
    せっかく非決定性計算を自由に使えるようになったんだから、解の候補の中から 1 つだけ選ぶのではなく、全部採用してみよう。
    以下が、ナイトの現在位置を取って次に行ける位置を列挙する関数である:
-}

moveKnight :: KnightPos -> [KnightPos]
moveKnight (c, r) = do
    (c', r') <- [(c+2, r-1), (c+2, r+1), (c-2, r-1), (c-2, r+1), (c+1, r-2), (c+1, r+2), (c-1, r-2), (c-1, r+2)]
    guard (c' `elem` [1..8] && r' `elem` [1..8])
    return (c', r')

{-
    ナイトは水平に 1 マス動いたあと垂直に 2 マス、あるいは垂直に 1 マス動いたあと水平に 2 マス、という動きが 1 手でできる。
    ペア (c', r') は、動きのリストにある値を順番に取り、guard は、(c', r') が盤面の範囲内にあることを保証している。
    盤面からはみ出していたら、guard は空リストを生み出すので、(c', r') という位置は以降の計算では使われない。

    この関数はリストモナドを使わずに書くこともできる。たとえば、filter を使うなら次のように書ける:
-}

moveKnight' :: KnightPos -> [KnightPos]
moveKnight' (c, r) = filter onBoard
    [(c+2, r-1), (c+2, r+1), (c-2, r-1), (c-2, r+1), (c+1, r-2), (c+1, r+2), (c-1, r-2), (c-1, r+2)]
    where onBoard (col, row) = col `elem` [1..8] && row `elem` [1..8]

{-
    試してみよう。

        *Main> moveKnight (6,2)
        [(8,1),(8,3),(4,1),(4,3),(7,4),(5,4)]
        *Main> moveKnight (8,1)
        [(6,2),(7,3)]

    ちゃんと動いた！　ある位置を入力に取って、可能な動きのすべてを同時に行っているようなものである。
    さて、次の位置は非決定的値で得られたから、>>= を使えば、また moveKnight にぶち込める。
    以下が、初期位置を取って、3 手で行ける位置をすべて返してくれる関数である。
-}

in3 :: KnightPos -> [KnightPos]
in3 start = do
    first <- moveKnight start
    second <- moveKnight first
    moveKnight second

{-
    この関数に (6,2) を渡して返ってくるリストはかなり大きいものである。なぜなら、同じ位置に 3 手で行く経路が複数ある場合、
    その位置が複数回リストに登場するからである。
    上記のコードを do 記法を使わずに書くと、以下のようになる:
-}

in3' :: KnightPos -> [KnightPos]
in3' start = return start >>= moveKnight >>= moveKnight >>= moveKnight

{-
    最初の >>= は、start から可能な手をすべて列挙してくれる。次の >>= は、1 手目に可能な動きのそれぞれに対して、次に可能な手を列挙する。最後の >>= も同様。
    return を使って値をデフォルトの文脈に入れた上で、>>= を使ってそれを関数に食わせるという一連の記述は、単に関数を値に適用するのと等価なのだが、
    ここではスタイルを統一するために return と >>= を使ってみた。
-}

{-
    では、2 つの位置を取って、1 つ目の位置から 2 つ目の位置にちょうど 3 手で到達できるか教えてくれる関数を作ろう。
-}

canReachIn3 :: KnightPos -> KnightPos -> Bool
canReachIn3 start end = end `elem` in3 start

{-
    まず、3 手で行ける位置をすべて生成（`in3 start`）してから、目的地がその中に含まれているか調べている。
    例えば、(6,2) から (6,1) へ 3 手で行けるかどうか試すには、次のようにする。
-}

canReachTo6_1 :: Bool
canReachTo6_1 = (6,2) `canReachIn3` (6,1) -- True

{- 行けた！　では (6,2) から (7,3) では？ -}

canReachTo7_3 :: Bool
canReachTo7_3 = (6,2) `canReachIn3` (7,3) -- False

{- この場合は、3 手では到達できないとわかる。 -}

