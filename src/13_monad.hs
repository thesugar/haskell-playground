{-# OPTIONS -Wall -Werror #-}
import Control.Monad

---_/_/_/_/_/_/_/_/_/_/_/---
-- 　  モナドがいっぱい　　　    --
---_/_/_/_/_/_/_/_/_/_/_/---

{-
    第 7 章で初めてファンクターの話をしたとき、ファンクターは関数で写せる値をあらわす　便利な概念であることを見た。
    第 11 章ではファンクターを一歩拡張してアプリカティブファンクターを導入し、ある種のデータ型は、文脈を持った値だと解釈できるようになった。
    アプリカティブファンクターを使えば、そのような文脈を保ったまま、通常の関数をそれらの値に適用できるのだった。

    この章では **モナド** を紹介する。
    モナドは強化されたアプリカティブファンクターである。
-}

-------------------------------
--　アプリカティブファンクターを強化する
-------------------------------

{-
    ファンクターを勉強し始めたとき、Functor 型クラスに属するさまざまな型は、すべて関数で写せることを見た。
    ファンクターを導入した動機は、「a -> b 型の関数と、f a というデータがあるとして、どうすれば等の関数を f a から f b への関数に変換できるだろう？」というものだった。
    Maybe a、リスト [a]、IO a などに対し、関数で写す方法を見てきた。
    a -> b 型の関数はなんと「r -> a 型の関数」を写すこともでき、その結果は「r -> b 型の関数」になることも見た。
    あるデータ型を関数で写したときの挙動を指定するには、fmap の型を見てから、
        fmap :: (Functor f) => (a -> b) -> f a -> f b
    Functor インスタンスを書き、fmap がそのデータ型を適切に処理できるようにすればよいのだった。

    それから、いくつかの疑問とともに、ファンクターを改良できる可能性が浮かび上がってきた。
    関数 a -> b が、はじめからファンクターに包まれていたらどうする？
    例えば Just (*3) があったとして、それを Just 5 に適用するには？
    その Just 5 が急に Nothing に変わったら？
    Maybe の代わりにリスト [(*2), (+4)] があったとして、それを [1,2,3] に適用sるうには？
    そもそも、そんなの動くの？　これらを解決するために、Applicative 型クラスを導入した。

        (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b

    Applicative 型クラスでは、通常の値をデータ型の中に入れる操作も可能になったのだった。
    例えば、1 を Just 1 に変えたり、[1] に変えたり、はたまた「何も副作用を起こさず 1 を返す I/O アクション」に変えたりできるのだった。
    この変換をしてくれる関数の名前は pure というんだった。
        *Main> pure 1 :: Maybe Int
        Just 1
        *Main> pure 1 :: [Int]
        [1]
        *Main> pure 1 :: IO Int
        1

    アプリカティブ値は、_変な_ 値、専門用語で言うと「文脈の付加された値」だとみなせる。
    例えば、文字 'a' はただの文字だが、Just 'a' は何らかの文脈がついている。
    Char 型の代わりに Maybe Char 型がきたとしたら、この値は文字かもしれないし文字がないことを表すのかもしれないということである。
    Applicative 型クラスは、これら文脈のついた値に、文脈を保ったまま普通の関数を適用させてくれる。例を見てみよう。

        *Main> (*) <$> Just 2 <*> Just 8
        Just 16
        *Main> (++) <$> Just "exdeath" <*> Nothing
        Nothing
        *Main> (-) <$> [3,4] <*> [1,2,3]
        [2,1,0,3,2,1]

    このようにアプリカティブ値として扱い始めると、Maybe a は失敗するかもしれない計算、[a] は複数の答えがありうる計算（非決定性計算）、IO a は副作用を伴う計算、などの意味を帯びてくるのだった。

    さて、モナドはある願いをかなえるための、アプリカティブ値の自然な拡張である。
    その願いとは「"普通の値 a (例: 'a') を取って文脈付きの値（例: Just 'a'）を返す関数" に、文脈付きの値 m a を渡したい」というもの。🧐❓
    言い換えると、a -> m b 型の関数を m a 型の値に適用したいということ。わかりやすく言うと、この関数が欲しいということである。

        (>>=) :: Monad m => m a -> (a -> m b) -> m b

    さて、「変な値 (例: Just 'a')」と、「普通の値を引数に取るけど変な値を返す関数 (例: 'a' -> Just 'a')」があったとき、どうやってその値を関数に食わせればよいだろう？
    これがモナドの一番の関心事である。
    これからは f a の代わりに m a と書くことにする。m は Monad の頭文字である。
    呼び方は変わるものの、モナドは >>= をサポートするアプリカティブファンクターにすぎない。関数 >>= はバインド（bind）と呼ばれる。
    普通の値 a と普通の関数 a -> b だったら、値を関数に食わせるのは造作もないことで、単に関数を値に適用すればよい。
    ところが、特定の文脈がつきまとう値を扱うとなると、その変な値を関数に食わせるとどうなるのか、文脈を保つにはどうするのか、ちゃんと考えないといけない。
    でも、やってみれば簡単だということがわかる！
-}

-------------------------------
--　Maybe から始めるモナド
-------------------------------

{-
    モナドが何者なのかぼんやりわかってきたところで、具体例を見ていこう。
    実は Maybe はモナドだったのである。

    Maybe a 型の値は a 型の値を表しているが、失敗する可能性という文脈付き。
    Just "dharma" という値は、文字列 "dharma" がそこに実在することを意味する。
    Nothing という値は、無を、あるいは文字列が何らかの計算の結果だとしたら、その計算が失敗したことを表している。

    ファンクターとして見た Maybe に対して関数を fmap すると、その Maybe が Just 値だった場合には、
    与えた関数が Just の中身に適用されるのだった。
    Nothing の場合は、Nothing のままだった。なぜなら関数を適用する相手がいないからである。

    *Main> fmap (++ "!") (Just "wisdom")
    Just "wisdom!"
    *Main> fmap (++ "!") Nothing
    Nothing

    アプリカティブファンクターとしての Maybe の機能も似たようなものである。
    ただし、アプリカティブファンクターになると、値だけでなく、値に適用する関数のほうにも文脈がつく。
    Maybe の Applicative インスタンスは、<*> を使って Maybe の中の関数を Maybe の中の値に適用しようとすると、
    関数と値が Just ならば結果が Just になる、そうでなければ結果は Nothing になる、というものだった。
    関数か値のどちらかが欠けていれば、無から適用結果をでっち上げるわけにはいかないから、失敗を伝播させる必要があるのだ。

        *Main> Just (+3) <*> Just 3
        Just 6

        *Main> Just reverse  <*> Nothing
        Nothing

    アプリカティブ・スタイルを使って複数の関数を Maybe 値に適用するときも、同じやり方でうまくいく。
    すべての引数が Just でなければ、結果は Nothing である！

        *Main> max <$> Just 3 <*> Just 6
        Just 6
        *Main> max <$> Just 3 <*> Nothing
        Nothing

    それではいよいよ、Maybe にとっての >>= をどう定義すればいいか考えていこう。
    >>= は、「モナド値（変な値、文脈付きの値）」と「普通の値を取る関数」を引数に取り、なんとかしてその関数をモナド値に適用してモナド値を得る。
    関数のほうは普通の値しか取れないのに、どうやってそんな芸当ができるのだろう？
    その答えを出すには、モナド値の文脈に立ち入る必要がある。

    この場合、>>= は Maybe a 型の値と a -> Maybe b 型の関数を取り、この関数をどうにかして Maybe a に適用するわけである。
    これをどうやって実現しているか探るには、Maybe がアプリカティブファンクターであるという知識が役立つ。
    さて、関数 \x -> Just (x+1) を考えよう。これは（普通の）数を取り、それに 1 を足して結果を Just に包む（ことで文脈を付ける）。
    例えば、この関数に 1 を食わせると Just 2 に評価され、100 を食わせると Just 101 に評価される。
    では、この関数に Maybe 値を食わせるにはどうしたらいいだろう？
    Maybe のアプリカティブファンクターとしての振る舞いから類推すると、この問いに答えるのは極めて簡単。
    Just 値がきたときは Just の中身を取り出し、それを関数に食わせればよい。
    Nothing 値がきたときは、関数はあるものの、それに適用すべき値がナッシングというわけだから、結果も Nothing とせざるを得ない。

    ひとまず >>= と呼ぶのはやめて applyMaybe という名前にする。
    これは「Maybe a 型の値」と「（普通の値を引数に取り、）Maybe b を返す関数」を引数に取り、どうにかしてその関数を Maybe a に適用してくれる関数である。
-}

applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
applyMaybe Nothing _ = Nothing
applyMaybe (Just x) f = f x -- f は `a -> Maybe b` 型であるため、ここは `Just f x` としないように。

-- 使ってみよう。
-- Maybe 値が左、関数が右に来るように、中置演算子表記で使ってみよう。

ans1 :: Maybe Int
ans1 = Just 3 `applyMaybe` \x -> Just (x+1) -- Just 4

ans2 :: Maybe String
ans2 = Just "smile" `applyMaybe` \x -> Just (x ++ " :) ") -- Just "smile :) "

ans3 :: Maybe Int
ans3 = Nothing `applyMaybe` \x -> Just (x+1) -- Nothing

{-
    この例では、Just 値と関数を引数に applyMaybe を呼び出したときは、単に Just の中の値に関数が適用されている。
    Nothing 値と関数を引数に呼び出すと、全体の結果が Nothing になっている。
    では、関数のほうが Nothing を返す場合はどうだろう？
-}

ans4 :: Maybe Int
ans4 = Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing -- Just 3

ans5 :: Maybe Int
ans5 = Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing -- Nothing

{-
    確かに期待通りの結果である。applyMaybe の左辺のモナド値が Nothing である場合には、全体の結果は Nothing になる。
    それから右辺の関数が Nothing を返した場合も、結果は Nothing である。
    これは Maybe をアプリカティブとして使ったときの挙動とよく似ている。
    式のどこかに Nothing があったら、答えも Nothing になるという挙動である。

    どうやら「変な値」に「普通の値を取って変な値を返す関数」を適用する方法が見えてきた。
    この例では「Maybe は失敗したかもしれない計算を表す」というイメージを心に描いて設計することで、これが実現できた。
    「で、これって何が便利なの？」という疑問が聞こえてきそう。
    実際、アプリカティブファンクターのほうがモナドよりも強力に思えるかもしれない。
    だってアプリカティブファンクターは、ごく普通の関数を文脈付きの値に適用できるようにしてくれるのだから。
    ところがどっこい、モナドも同じことができるのである。
    さらにモナドにはできてアプリカティブファンクターにはできないこともあるのである。

    Maybe モナドは少し置いておいて、まずは、モナドが属する型クラスを見ていこう。
-}

-------------------------------
--　Monad 型クラス
-------------------------------

{-
    ファンクターには Functor 型クラスがあり、アプリカティブファンクターには Applicative 型クラスがあるように、モナドにも型クラス Monad がある。

    class Applicative m => Monad (m :: * -> *) where
        return :: a -> m a

        (>>=) :: m a -> (a -> m b) -> m b
        (>>) :: m a -> m b -> m b
    
        fail :: String -> m a
        fail s = errorWithoutStackTrace s

    return 関数は Applicative 型クラスの　pure と同じもの。
    だから、名前は違っていてもすでにおなじみである。

    return の型は a -> m a である。
    return は、値を取って、その値を再現できるような最小のデフォルト文脈に入れる。
    return は、第 8 章で I/O を扱ったときすでに登場していた。そのときは、値を返すだけで何も I/O をしない、なんちゃって I/O アクションを作るために return を使ったのだった。
    Maybe の場合は、return は値を Just に入れて返す。

        *Main> return 20 >>= \x -> Just (x+1)
        Just 21

    次の関数は >>=、又の名をバインド。これは関数適用に似ているが、普通の値を取って通常の関数を適用するのではなく、
    モナド値（つまり、文脈付きの値）を取って、それに「通常の値を取るがモナド値を返す関数」を適用する（上の節では `applyMaybe` として実装した関数が >>= である）。

    それから、>> がある。これにはデフォルト実装があるのであまり詳しくは解説しない。
    Monad インスタンスを実装するときも、このデフォルト実装を上書きすることは滅多にない。

    Monad 型クラスの最後の関数は fail である。
    ユーザーがコードの中から fail を呼び出すことは決してなく、もっぱら Haskell システムが呼び出す。
    fail はモナド用の特別な構文において、パターンマッチに失敗してもプログラムを以上終了させず、失敗をモナドの文脈の中で扱えるようにするものである。
    これについては後で見るので、今はさほど気にしなくて良い。

    これで Monad 型クラスがどんなものなのかわかった。では、Maybe の Monad インスタンスの実装を見ていこう。

    instance Monad Maybe where
        return x = Just x
        Nothing >>= f = Nothing
        Just x >>= f = f x
        fail _ = Nothing

    return は pure と同じだから、目を瞑っていても書ける。
    Applicative 型クラスのときと同様、Just に包むだけ。
    関数 >>= は、さっきの applyMaybe と同じ。左辺の Maybe a を右辺の関数に食わせるとき、失敗するかもしれない計算という文脈の意味を考えれば、
    左辺に Nothing がきていれば Nothing を返す、Just がきていれば中身を取り出して f を適用する、という設計になる。

    モナド化した Maybe で遊んでみよう。
-}

foo :: Maybe String
foo = return "What" -- foo は Just "What" になる

foo' :: Maybe Int
foo' = Just 9 >>= \x -> return (x*10) -- Just 90

foo'' :: Maybe Int
foo'' = Nothing >>= \x -> return (x*10) -- Nothing

-------------------------------
--　綱渡り
-------------------------------

{-
    失敗するかもしれない計算という文脈を損なうことなく、Maybe a 型の値に a -> Maybe b 型の関数を適用する方法がわかったところで、
    >= を繰り返し使って Maybe a 値を返す複数の計算を扱う方法を見ていこう。

    バランス棒の左右に鳥が止まる問題を考える。
    左右の鳥の数の差が 3 以内（3 を含む）であれば棒はバランスするが、4 以上になると棒はバランスを崩す。
-}

-- ¶　ひたすらコーディング
{-
    バランス棒は、単に整数のペアとして表現できる。
    ペアの第一成分は左側にいる鳥の数を、第二成分は右側にいる鳥の数を表すことにする。
-}

type Birds = Int
type Pole = (Birds, Birds)

{-
    まず、Int の型シノニムを作り、Birds と名付ける。これは、そこにいる鳥の数を荒wす整数である。
    それから (Birds, Birds) の型シノニムを Pole と名付ける。
    では、鳥の数を取って、バランス棒の左側もしくは右側に鳥をとまらせる関数を作ろう。
-}

landLeft :: Birds -> Pole -> Pole
landLeft n (left, right) = (left + n, right)

landRight :: Birds -> Pole -> Pole
landRight n (left, right) = (left, right + n)

{-
    鳥を飛び立たせる処理は、負の数の鳥がとまる処理で代用する。
    Pole に鳥をとまらせる関数は Pole を返すので、landLeft と landRight は好きなだけ合成して使える。

    > landLeft 2 (landRight 1 (landLeft 1 (0, 0)))
    (3,1)

    ただ、今の場合、バランス棒を先に書いて、鳥をとまらせる関数を後に書いた方が読みやすそう。
    そこで、次のような関数 -: を定義する:
-}

(-:) :: a -> (a -> b) -> b
x -: f = f x

{-
    これで、関数を適用するのに、まず引数、次に関数を書けるようになる。

        > 100 :- (*3)
        300

    この形式を使えば、鳥を次々に止まらせる処理をさっきよりも読みやすく書ける。

        > (0,0) -: landLeft 1 -: landRight 1 -: landLeft 2
        (3,1)

    これで直感的に理解しやすくなった！
-}

-- ¶　うわ〜落ちる！
{-
    左右に止まっている鳥の数の差が 3 より大きくなったときにバランスを崩してしまうことを表現するために、landLeft 関数と landRight 関数を修正しよう。
    landLeft 関数と landRight 関数は、失敗を表現できる必要がある。
    棒がバランスを取れている場合は新しいバランス棒の状態を返すが、鳥のとまり方が偏りすぎた場合は失敗を返すようにしたい。
    失敗を表現したいとなったら、これはもう Maybe を使うしかない！
-}

landLeft' :: Birds -> Pole -> Maybe Pole
landLeft' n (left, right)
    | abs ((left + n) - right) < 4 = Just (left + n, right)
    | otherwise = Nothing

landRight' :: Birds -> Pole -> Maybe Pole
landRight' n (left, right)
    | abs (left - (right + n)) < 4 = Just (left, right + n)
    | otherwise = Nothing

{-
    使用例
        *Main> landLeft' 2 (0, 0)
        Just (2,0)
        *Main> landLeft' 10 (0,3)
        Nothing
-}

{-
    Maybe を使って失敗（棒がバランスを崩した状態である Nothing）を表現できるようになったのは素晴らしいが、鳥をとまらせる操作を合成する能力を失ってしまったのでは？
    もう、landLeft 1 (landRight 1 (0, 0)) とは欠けなくなってしまった。
    なぜなら、Pole 型の (0, 0) に landRight 1 を適用すると、Pole 型ではなく、Maybe Pole が返ってくるから。
    landLeft 1 は Pole 型を取る関数なので、Maybe Pole は受け付けてくれない。

    ・・・ということで、ここで >>= の出番！
-}

bou :: Maybe Pole
bou = landRight' 1 (0, 0) >>= landLeft' 2 -- Just (2,1)

{-
    LandLeft' 2 は Pole -> Maybe Pole 型の関数だった。landRight 1 (0,0) の結果である Maybe Pole は、
    そのままでは landLeft 2 に食わせられないので、>>= を使って、文脈を保ったまま landLeft 2 に渡す。
    >>= はまさに、Maybe を「文脈付きの値」として扱うための道具だと言えるだろう。
    現に、Nothing を landLeft 2 に渡すと、結果は Nothing になり、失敗が伝播するのがわかる。
-}

muri :: Maybe Pole
muri = Nothing >>= landLeft' 2 -- Nothing

{-
    このように、通常の値を引数に取る関数にモナド値を渡せる >>= を使うことで、「鳥がとまる」という失敗するかもしれない操作を合成できるようになった。
    鳥がとまる一連のイベントを次のように表現できる:
-}

stick :: Maybe Pole
stick = return (0,0) >>= landRight' 2 >>= landLeft' 2 >>= landRight' 2 -- Just (2,4)

{-
    まず return を使って、バランス棒の状態を Just でくるんだ。
    直接 (0,0) に landRight' 2 を適用するところ（`landRight' 2 (0, 0)`）から始めてもよかったが（それでも結果は同じ）、すべての関数に >>= を使うほうが統一感がある。
    Just (0,0) が landRight 2 に食われて Just (0,2) になる。それがまた landLeft 2 に食われて Just (2, 2) になり……、というふうに続く。

    また、たとえば、次のような例を考えよう:
-}

pole :: Maybe Pole
pole = return (0, 0) >>= landLeft' 1 >>= landRight' 4 >>= landLeft' (-1) >>= landRight' (-2) -- Nothing

{-
    上記は、Maybe を導入していない状態の関数（' 無しの landLeft, landRight）でやると、
    途中で左右の鳥の数の差が 4 以上になるにもかかわらず、なまじ最終状態における左右の鳥の数の差が 3 以内だから失敗したとみなされない。

    それを、Maybe を導入してモナド適用（>>=）を使うことで、左右の鳥の数の差が 4 以上になった瞬間に失敗（Nothing）扱いになり、
    その失敗が最終結果まで伝播してくれている。

    Maybe をアプリカティブ値として扱うだけでは、ここまでのことは不可能だっただろう。
    無理にやろうとしても、アプリカティブファンクターには、アプリカティブ値どうしをこのように深く相互作用させることはできないので、行き詰まる。
    アプリカティブにできることは、せいぜい通常の関数にアプリカティブスタイルで引数を渡すことくらいなのである。
    アプリカティブ演算子たちは、アプリカティブ値からそれぞれの文脈にしたがって結果を取り出しては通常の関数を適用し、結果をまたアプリカティブ値に入れて返してくれる。
    しかし、アプリカティブ値どうしを相互作用させることは苦手なのである。
    ところが、今回の棒の例では、各ステップは以前のステップの結果に依存している。鳥たちがやってくるたびに、直前のステップを踏まえて今回の結果が検証され、
    バランスがとれているかどうかを調べる。こうして鳥がうまくとまれたかどうかが判定されるのである。
-}

--- ¶　ロープの上のバナナ
{-
    さて、今度はバランス棒にとまっている鳥の数によらず、いきなりバランスを崩させて落っことす関数を作ってみよう。
    この関数を banana を呼ぶことにする。
-}

banana :: Pole -> Maybe Pole
banana _ = Nothing

{-
    この関数は鳥をとまらせる関数と混ぜて使える。
    banana は引数に何を渡されようと、無視して失敗を返すようにできているので、banana を呼べば必ず落っことせる。
-}

bananaed :: Maybe Pole
bananaed = return (0,0) >>= landLeft' 1 >>= banana >>= landRight' 1 -- Nothing

{-
    ところで、入力に関係なく規定のモナド値を返す関数だったら、自作せずとも >> 関数を使うという手がある。
    次が >> のデフォルト実装である:

        (>>) :: (Monad m) => m a -> m b -> m b
        m << n = m >>= \_ -> n

    普通の関数なら、引数を無視して規定の値を返すような関数の結果は、その規定値そのものである。
    ところが、モナド値を扱う場合は、モナドとしての文脈と意味を考慮する必要がある。
    Maybe 版の >> の動作は、以下のような感じ。

    *Main> Nothing >> Just 3
    Nothing
    *Main> Just 3 >> Just 4
    Just 4
    *Main> Just 3 >> Nothing
    Nothing

    一番目の例では、Maybe モナドの文脈が考慮された結果、「規定値」であるはずの Just 3 が失敗に置き換わっている。
    >> を >>= \_ -> で置き換えてみれば、何が起こっているのか簡単に理解できる。
        Nothing >> Just 3 は Nothing >>= \_ -> Just 3

    >>= で連結した処理中での banana 関数は、>> と Nothing という、失敗することが保証された組み合わせで置き換えられる。
-}

bananaed_ :: Maybe Pole
bananaed_ = return (0,0) >>= landLeft' 1 >> Nothing >>= landRight' 1 -- Nothing

{-
    ところで、Maybe を失敗の文脈付きの値として扱って、モナド適用により関数に食わせるという賢明な選択をしなかったらどうなっていたか？
    バランス棒に鳥をとまらせる一連の処理は次のようになっていたはず:
-}

routine :: Maybe Pole
routine = case landLeft' 1 (0, 0) of
    Nothing -> Nothing
    Just pole1 -> case landRight' 4 pole1 of
        Nothing -> Nothing
        Just pole2 -> case landLeft' 2 pole2 of
            Nothing -> Nothing
            Just pole3 -> landLeft' 1 pole3 -- Just (4, 4)

{-
    まずバランス棒の左側に鳥を一羽とめ、成功したか失敗したかによって場合訳をする。失敗していた場合には Nothing を返す。
    成功していた場合は、右側に鳥をとめる処理に進み、また場合分けをして……という繰り返し。
    この巨大で醜いコードを、>>= による素敵なモナド適用の連鎖で書き直すのは、Maybe モナド布教コードの定番。
    Maybe モナドを使うと、失敗するかもしれない処理が連続するコードをとても簡潔に書けるのである。

    Maybe モナドの >>= の実装は、まさにこの「値が Nothing かどうかを判定し、その知識に基づいて動作を変える」というロジックになっている。
    もし入力値が Nothing なら、>= は直ちに Nothing を返す。
    入力が Nothing でなければ、Just の中身を利用して計算を進める。

    この節では、関数の返り値を失敗処理をサポートする値に変えることで、関数がもっと便利になる例を見た。
    関数の返り値を Maybe 値にし、関数適用を >>0 に変えるだけで、ほとんど手間をかけずに失敗を処理するメカニズムを組み込むことができた。
    これも、>>= が、関数を値に適用するにあたって、値が持っている文脈を保存するようにできているおかげである。
    Maybe の場合、文脈とは「この値は計算に失敗しているかもしれない」というものだった。
    なので、Maybe 値に関数をモナド適用すると、常に失敗の可能性が考慮されたコードが自動的に出来上がるのである。
-}

-------------------------------
--　do 記法
-------------------------------
{-
    haskell にとってモナドはとても便利なので、モナド専用構文まで用意されている。
    その名は do 記法。
    do 記法は、すでに第 8 章で、複数の I/O アクションを 1 つに糊付けするときに使った。
    実は、do 記法は IO モナドだけでなくあらゆるモナドに使える。
    といっても基本は同じで、do 記法は複数のモナド値を糊付けするものである。
    モナドを使ったおなじみのこんなコードを見てみよう:
-}

bikkuri :: Maybe String
bikkuri = Just (3::Int) >>= (\x -> Just (show x ++ "!")) -- Just "3!"

{-
    このコードを実行すると、ラムダ式の中の x に 3 が入る。
    このラムダ式の中では、3 はモナド値でなく通常の値として扱えるわけである。 
    では、このラムダ式の中にもう 1 つ >>= があったらどうなるだろう？
-}

exclaimation :: Maybe String
exclaimation = Just (3::Int) >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y))) -- Just "3!"

{-
    >>= の入れ子構造である。
    外側のラムダ式の中では、Just "!" をラムダ式 \y -> Just (show x ++ y) に食わせている。このラムダ式の中では、y は "!" になる。
    また、x は、外側のラムダ式が実行されたときに 3 が入ったままである。
    これを見ていると let 構文を思い出す:
-}

bun :: String
bun = let x = 3:: Int; y = "!" in show x ++ y -- "3!"

{-
    この 2 つの例は似ているが、>>= のほうで使っている値はモナド値であるという大きな違いがある。
    失敗の文脈付きの値なのである。だから、好きな箇所を失敗で置き換えられる。
-}

nothin1 :: Maybe String
nothin1 = Nothing >>= (\x -> Just "!" >>= (\y -> Just (show (x :: String) ++ y))) -- Nothing

nothin2 :: Maybe String
nothin2 = Just (3::Int) >>= (\x -> Nothing >>= (\y -> Just (show x ++ y))) -- Nothing

nothin3 :: Maybe String
nothin3 = Just (3::Int) >>= (\_ -> Just "!" >>= (\_ -> Nothing)) -- Nothing

{-
    最初の例では Nothing を関数に渡しているので、当然 Nothing が返っている。
    次の例では、Just 3 を関数に渡して、x が 3 になっている。ところが内側のラムダ式には Nothing を渡しているから、
    そいつは Nothing を返し、そのせいで外側のラムダ式の結果も Nothing になっている。

    やはり、操作したい値がモナド値かどうかという違いはあるものの、この操作は let 式で値を変数に束縛する操作に似ている。
    この類似性をもっと明確にするために、今の式をスクリプト風に書き換えよう
-}

exclaimation' :: Maybe String
exclaimation' = Just (3 :: Int) >>= (\x ->
                Just "!"        >>= (\y ->
                Just (show x ++ y))) -- Just "3!"

{-
    面倒なラムダ式をいっぱい書かなくても済むよう、Haskell には do 記法が備わっている。
    do 記法を使えば、さっきのコードは次のように書ける:
-}

exclaimation'' :: Maybe String
exclaimation'' = do
    x <- Just (3 :: Int)
    y <- Just "!"
    Just (show x ++ y) -- Just "3!"

{-
    いちいち Maybe 値が Just か Nothing かなんて場合訳せずとも、Maybe 値から生の値が取り出せる気分になる。
    素晴らしい！　もし中身を取り出そうとする値のいずれかが Nothing だったら、do 式全体も Nothing になる。
    この do 式の中では、Maybe モナドから（存在するとおぼしき）値を取り出しつつ、値につきまとう文脈の処理は >>= に任せているのである。

    モナド値を連鎖させた式と等価なものを、ずっと簡潔に表せる記法が do 式なのである。
-}

--- ¶　do 自由自在
{-
    do 式は、let 行を除いてすべてモナド値で構成される。
    モナドの結果を調べるには <- を使う。例えば、変数を <- で Maybe String の結果に束縛すると、その変数の型は String になる。
    これは >>= を使ってモナド値をラムダ式に食わせたときとまったく同じ。

    do 式の最後のモナド値（上の例で言うと Just (show x ++ y) が相当する）だけは <- で結果を束縛できない。
    do 記法は　>>= とラムダ式を使う表記に書き直せるはずだが、最後のモナドで <- を使っても、それを受けるべきラムダ式がないからである。
    その代わり、最後のモナドの返り値は、それまでの失敗の可能性をすべて踏まえた上で、do 式で糊付けしたモナド全体の結果になる。
    exclamation' と exclamation'' を見比べればわかるだろう。
-}


--- ¶　バランス棒ふたたび
{-
    先ほどのバランス棒の動作も、もちろん do 記法で書ける。
    landLeft と landRight は鳥の数とバランス棒を引数に取り、新しい棒の状態を Just に包んで返す。
    ただし棒が滑った場合は Nothing を返す。
    各ステップは、それまでの結果に依存しているので、>>= を使って連結し、各ステップからの失敗の文脈が累積するようにするのだった。

    例えば、左に 2 羽、右に 2 羽、それから左に 1 羽の鳥が来る処理は do 記法では次のように書ける。
-}

routine' :: Maybe Pole
routine' = do
    start <- return (0,0)
    first <- landLeft' 2 start
    second <- landRight' 2 first
    landLeft' 1 second
    -- 結果が Just (3,2) となるので、バランス棒が無事バランスを保っていることがわかる。

{-
    >>= を使って書いていたときは、return (0,0) >>= landLeft' 2 >>= landRight' 2 ... というように書けたが、
    do 式を使う場合は各行がモナド値である必要があるので、直前の Pole の状態に名前をつけて landLeft' 関数や landRight' 関数に明示的に渡さないといけない。

    1 行ごとに処理が書いてある do 式が、手続き型言語のプログラムに見えるかもしれない。でも do 式では、それ以前の行の結果に依存する値の列が、
    成功または失敗の文脈とともに書いてあるにすぎない。

    バナナで棒のバランスを強制的に崩したい場合は、次のようになる:
-}

routine'' :: Maybe Pole
routine'' = do
    start <- return (0,0)
    first <- landLeft' 2 start
    _ <- Nothing
    second <- landRight' 2 first
    landLeft' 1 second
        -- 結果は Nothing になる

{-
    do 記法の中で、<- による変数への束縛をせずにモナドを使うと、結果を無視したいモナドの後に >> をつけたのと同じになる。
    モナドをつなげるけれども結果には興味がないから無視するわけである。
    同じ処理は _ <- Nothing としても書けるが、<- を省略したほうがきれい。

    （手元の環境だと、_ <- Nothing としないと
        error: [-Wunused-do-bind, -Werror=unused-do-bind]
        A do-notation statement discarded a re１lt of type
        ‘ghc-prim-0.5.3:GHC.Types.Any’
        Suppress this warning by saying ‘_ <- Nothing’
    というエラーが出た）

    いつ do を使い、いつ >>= を使うかの選択はプログラマ次第。バランス棒の例では、各モナドはもっぱら直前のモナドの結果に依存しているから、
    >>= を使った方が連続的に書けるし良いのではないか。do 記法では、どの時点のバランス棒に鳥をとまらせるのか明示的に書かないといけない。
    でも常に 1 つ前のステップの結果を使うんだから do を使うまでもないよね、という。。
-}

--- ¶　パターンマッチと失敗
{-
    do 記法でモナド値を変数名に束縛するときには、let 式や関数の引数のときと同様、パターンマッチが使える。
    これが do 式におけるパターンマッチの例である。
-}

justH :: Maybe Char
justH = do
    (x:_) <- Just "hello"
    return x -- 結果: Just 'h'。バインド演算子を使って書き換えるなら Just "hello" >>= \(x:_) -> return x  といった感じか

{-
    ここでは、パターンマッチを使って文字列 "hello" の先頭の文字を取り出し、それをモナド全体の結果としている。
    だから justH は Just 'h' と評価される。
    もしこのパターンマッチが失敗したらどうなるのだろう？
    関数定義では、あるパターンマッチが失敗したら、次のパターンを試すことになっていた。
    ある関数のすべてのパターンマッチに失敗したら、エラーが投げられ、プログラムは異常終了する。
    これに対し、let 式でパターンマッチに失敗した場合、let 式には複数のパターンマッチを次々に試す仕組みはないので、直ちにエラーになる。

    do 式の中でパターンマッチが失敗した場合、Monad 型クラスの一員である fail 関数が使われるので、異常終了という形ではなく、
    そのモナドの文脈に合った形で失敗を処理できる。
    fail のデフォルト実装は以下:

        fail :: (Monad m) => String -> m a
        fail msg = error msg

    あ、デフォルトでは、fail はプログラムを異常終了させるようだ。しかし、Maybe のような失敗を表現できる文脈を持つモナドでは、
    通常は独自に fail を実装している。Maybe の fail はこんな感じ:

        fail _ = Nothing

    エラーメッセージを無視して Nothing を作っている。
    これにより、do 記法で書かれた Maybe モナドの内部でパターンマッチに失敗したときは、do 式全体が Nothing を返す。
    プログラムが異常終了するよりも、Nothing が得られるほうが嬉しい。
    パターンマッチに失敗するような do 式を書いてみよう:
-}

wopwop :: Maybe Char
wopwop = do
    (x:_) <- Just ""
    return x
    -- 結果: Nothing

{-
    このパターンマッチは失敗するので、その効果は失敗するパターンマッチのある行全体を Nothing で置き換えたのと同じ。
    以上で見たとおり、パターンマッチが失敗しても全プログラムが巻き添えになって落ちることはなく、モナドの文脈で失敗が発生するだけで済んでいる。
-}

