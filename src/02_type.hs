---_/_/_/_/_/_/_/_/_/_/_/_/---
--         型を信じろ！       --
---_/_/_/_/_/_/_/_/_/_/_/_/---

{-
式の型は GHCi を使って調べることができる。`t:` コマンドに続けて式を入力する。
    > :t 'a'
    'a' :: Char

    > :t "hoge"
    "hoge" :: [Char]

    > :t True
    True :: Bool

    > :t (True, 'a')
    (True, 'a') :: (Bool, Char)

    > :t (True, 'a', "my")
    (True, 'a', "my") :: (Bool, Char, [Char])

    > :t 4 == 5
    4 == 5 :: Bool
-}

{-
:: という記号は、「の型を持つ（has type of）」と読む。
明示的な型の名前の先頭はつねに大文字。

関数も型を持つ。自分で関数を書くとき、その関数に明示的な型宣言を会えることができる。
-}

-- 文字列中の小文字をフィルタする関数に型宣言を与えると次のようになる。
removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]

-- 関数が複数の引数を持つ場合は？ 3 つの整数を受け取ってそれらを足し合わせる関数
-- 引数と返り値の型は -> で区切り、返り値の型はつねに宣言の最後に置く。
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

---- 🍪一般的な Haskell の型

-- Int: 整数。有界（最大値と最小値がある）。
-- Integer: 整数。有界ではないため、とても大きい数を表すのに使える。Int のほうが効率的。
-- Float: 単精度浮動小数点数。
circumference :: Float -> Float
circumference r = 2 * pi * r -- circumference 4.0 = 25.132742

-- Double: 倍精度浮動小数点数。倍精度型が数を表すのに使うビット数は Float の 2 倍。より多くのリソースを使うぶん、精度が高い。
circumference' :: Double -> Double
circumference' r  = 2 * pi * r -- circumference' 4.0 = 25.132741228718345

-- Bool: 真理値型。True と False のみを持てる。
-- Char: Unicode 文字。シングルクオートで括って表す。文字のリストは文字列。
-- タプル：タプルも型だが、その定義は要素の数とそれぞれの型によって決まる。空のタプル () も型。この型はただ 1 つの値 `()` （"ユニット"）のみを持つ。


-- -○-○-○-○-○-○-○-○-○-○-○-○  ---
---    型変数（Type Variables）   ---
-- -○-○-○-○-○-○-○-○-○-○-○-○  ---

-- いろいろな型に対して動作する関数。たとえば head 関数はリストを取りその先頭の要素を返すが、リストの要素が数でも文字でもネストしたリストでもOK（あらゆる型のリストに対して動作する）。
-- :t head とすると `head :: [a] -> a` と出る。
-- a とは何か？　型の名前であれば大文字から始まるので型ではない。この a は **型変数** と呼ばれるもので、どんな型も取りうることを意味する。
-- 型変数は、型安全を保ったまま、関数を複数の型に対して動作できるようにしてくれる。
-- 他のプログラミング言語にある ジェネリクス に似ているが、Haskell の型関数はとても一般的な関数を簡単に書けるのではるかにパワフル。
-- 型変数を用いた関数は **多相的関数（polymorphic functions）** と呼ばれる。
-- head の型宣言は「任意の型のリストを引数に取り、その型の要素を一つ返す」と読むことができる。

-- 💭ペアの 1 つ目の要素を返す関数 fst の型は？
-- fst :: (a, b) -> a
--    👉fst はタプルを引数に鳥、その 1 つ目と同じ型の値を返すことが見て取れる。a と b は違う型変数だが、必ずしも違う型である必要はない。


-- -○-○-○-○-○-○-○-○-○-○-○-○-○-○-○-○  ---
---    型クラス（Typeclasses） 〜初級講座〜  ---
-- -○-○-○-○-○-○-○-○-○-○-○-○-○-○-○-○  ---

{-
📕型クラスは、なんらかの振る舞いを定義するインターフェイス。ある型クラスのインスタンスである型は、その型クラスが記述する振る舞いを実装する。
👉もっと具体的に言うと、型クラスは関数の集まりを定める。ある型クラスに属する関数のことを、その型クラスの **メソッド** と呼ぶこともある。
　 ある型を型クラスのインスタンスにしようと考えたときには、それらの関数がその型ではどういう意味を成すのかを定義する。
-}

-- | 等値性を定義する型クラスが良い例。
-- 多くの型について、その値の等値性を == 演算子を使って比較できる。この演算子の型を調べてみよう。

{-
> :t (==)
(==) :: Eq a => a -> a -> Bool

   | NOTE |
   | 💭等値性演算子（==）は実際には関数であることに注意。+、*、-、/ など、ほかのほとんどすべての演算子も同様。
   | 　関数の名前が特殊文字のみからなる場合、その関数はデフォルトで中値関数となる。その型を調べたい場合や他の関数に渡したい場合、前置関数として呼び出したい場合などは丸括弧で囲む必要がある。
-}

{-
 🔥 => というシンボルについて
 このシンボルより前にあるものは **型クラス制約** と呼ばれる。
 この例の型宣言は「等値性関数は、同じ型（型変数 a）の任意の 2 つの引数を取り、Bool を返す。引数の 2 つの値の型（型変数 a）は Eq クラスのインスタンスでなければならない」と読める。

 Eq 型クラスは、等値性をテストするためのインターフェイスを提供する。
 ある型の 2 つの値の等値性を比較することに意味があるなら、その型は Eq 型クラスのインスタンスにできる。
 Haskell のすべての標準型（I/O 型と関数を除く）は Eq のインスタンスである。

 >> ❗️NOTE❗️
 型クラスはオブジェクト指向のクラスとは同じではない。
-}

{- よく使われる型クラスを見ていこう。型の値の等値性や順序をカンタjに比較したり、手軽に文字列として表示したりできるのはこれらの型クラスのおかげである。-}

-- 🌸 Eq 型クラス
-- - 等値性をテストできる型に使われる。Eq のインスタンスが実装すべき関数は == と /= である。
-- - これは、関数の型変数に Eq クラスの制約がついていたら、その関数の定義のどこかで == か /= が使われているということ。
-- - 「型が関数を実装している」とはその関数がその特定の型に対して使われたときに、どういう振る舞いをするかを定義するということ。
-- - Eq のさまざまなインスタンスに対する == と /= の動作の例をいくつか挙げる。

eq1 = 5 == 5 -- True
eq2 = 5 /= 5 -- False
eq3 = 'a' == 'a' -- True
eq4 = "Ho Ho" == "Ho Ho" -- True
eq5 = 3.432 == 3.432 -- True

-- 🌸 Ord 型クラス
-- - Ord は、なんらかの順序を付けられる型のための型クラス。例えば、大なり演算子（>）の型を見てみると
--   (>) :: Ord a => a -> a -> Bool

{- 
 💫今まで見てきた型は、関数は除いて、すべて Ord のインスタンス。Ord は すべての標準的な大小比較関数、>、<、>=、<= をサポートする。
 　compare 関数は Ord のインスタンスの型の引数を 2 つ取り、Ordering を返す。
 　Ordering は GT, LT, EQ のいずれかの値をとる型で、それぞれ「より大きい」「より小さい」「等しい」を意味する。
 -}

ord1 = "Abrakadabra" < "Zebra" -- True
ord2 = "Abrakadabra" `compare` "Zebra" -- LT
ord3 = 5 >= 2 -- True
ord4 = 5 `compare` 3 -- GT
ord5 = 'b' > 'a' -- True
ord6 = True `compare` False -- GT

-- 🌸Show 型クラス
-- ある値は、その型が Show 型クラスのインスタンスになっていれば、文字列として表現できる。
-- 今まで見てきた型は、関数を除けば、すべて Show のインスタンス。
-- この型クラスのインスタンスに対する操作で一番よく使うのは　show で、これは指定した値を文字列として表示する関数。
-- なお、:t (show) を調べると (show) :: Show a => a -> String　となる。

sho1 = show 3 -- "3"
sho2 = show 5.334 -- "5.334"
sho3 = show True -- "True"

-- 🌸 Read 型クラス
-- Read は Show と対を成す型クラス。
-- 今まで見てきたすべての型はこの型のインスタンス。read 関数は文字列を受け取り、Read のインスタンスの型の値を返す（read :: Read a => String -> a）。

re1 = read "True" || False -- True
re2 = read "8.2" + 3.8 -- 12
re3 = read "5" - 2 -- 3
re4 = read "[1, 2, 3, 4]" ++ [3] -- [1,2,3,4,3]
re5 = read (show 10) - 2 -- 8

{-
 read "4" としてみると *** Exception: Prelude.read: no parse というふうに例外が発生する。
 ここまでの例（re1 ~ re4）で返すべき値の型を GHCi が推論できていたのは、結果の値に何かしらの手が加えられていたから。
 たとえば真理値として使われている場合には Bool を返すべきだと　GHCi は推論できる。
 しかし read "4" では Read クラスのどれかを返すことしかわからず、具体的に何を返せばいいのか GHCi にはわからない。
 read の型シグネチャを改めて見てみると
     read :: Read a => String -> a
     　💡 String は [Char] の単なる別名。
 型シグネチャから、read 関数が返す値の型は Read のインスタンスであることは読み取れるが、返された値の使い方によっては、それが具体的にどの型なのか判定できなくなってしまうことがある。
 
 この問題を解決するために、**型注釈** というものを用いる。
 型注釈は、式がとるべき型を Haskell に明示的に教えてあげる手段。式の終わりに :: を追記し、それから型を指定する。
-}

rea1 = read "5" :: Int -- 5
rea2 = read "5" :: Float -- 5.0
rea3 = (read "5" :: Float) * 4 -- 20.0
rea4 = read "[1,2,3,4]" :: [Int] -- [1,2,3,4]
rea5 = read "(3, 'a')" :: (Int, Char) -- (3, 'a')
rea6 = read (show True) :: Bool -- True

{-
  コンパイラはほとんどの式の型を自力で推論できる。しかし、read "5" の型が Int か Float かわからないように、返り値の型をうまく推論できない場合もある。
  read "5" を実際に評価することができれば、その型を知ることもできるかもしれないが、Haskell は静的型付け言語なので、コードをコンパイルする前にすべての型がわかっている必要がある。

  なお、Haskell に read が返すべき値の型が何なのかを教えてあげるのは最小限でかまわない。
  例えば read の結果をリストの中に詰め込めば、Haskell はそのリストを通じて「返り値の型はリストの他の要素の型である」と知ることができる。
  [read "True", False, True] -- [True, False, True]
  read "True" は Bool 値のリストの要素なので、read "True" も Bool でなければならないとわかる。
-}

-- 🌸 Enum 型クラス

{-
    Enum のインスタンスは、順番に並んだ型、つまり要素の値を列挙できる型である。
    Enum 型クラスの主な利点は、その値をレンジの中で使えること。また、Enum のインスタンスの型には 後者関数 succ と前者関数 pred も定義される。
    Enum クラスのインスタンスとしては、(), Bool, Char, Ordering, Int, Integer, Float, Double などがある。
-}

enum1 = ['a'..'e'] -- "abcde"
enum2 = [LT .. GT] -- [LT,EQ,GT]
enum3 = [3 .. 5] -- [3,4,5]
enum4 = succ 'B' -- 'C'

-- 🌸 Bounded 型クラス

{-
    Bounded 型クラスのインスタンスは上限と下限を持ち、それぞれ minBound と maxBound 関数で調べることができる。
-}

minb1 = minBound :: Int -- -9223372036854775808
minb2 = minBound :: Bool -- False
maxb1 = maxBound :: Char -- '\1114111'
maxb2 = maxBound :: Bool -- True
maxb3 = maxBound :: Int -- 9223372036854775807

-- 💭minBound と maxBound 関数は、 Bounded a => a という面白い型を持っている。これらは、いわば多相定数である。
-- 💭タプルのすべての構成要素が Bounded のインスタ成すなら、そのタプル自身も Bounded になることに注意。
--   > maxBound :: (Bool, Int, Char) 
--     (True,9223372036854775807,'\1114111') 

-- ちなみに、minBound :: Int のような書き方は minBound という関数（定数）について型を注釈してあげているだけ。
-- 5 :: Int とすれば 5 が返ってくるし 5 :: Float と書けば 5.0 が返ってくるのと同じ。
-- だから、たとえば [maxBound, True] と書けば [True, True] が返ってくる（リストは構成する要素がすべて同じ型だから注釈しなくても推論される）。

-- 🌸 Num 型クラス

{--
    Num は数の型クラス。このインスタンスは数のように振舞う。数の型を調べてみよう。
    
    > :t 20
    20 :: Num p => p

    あらゆる数もまた多相定数として表現されていて、Num 型クラスの任意のインスタンス（Int, Integer, Float, Double など）として振舞うことができる。
    👉上の（Bounded 型クラスの説明の）最後のところでちょっと書いた、「5 :: Int とすれば 5 が... 5:: Float と書けば 5.0 が...」の話。 
--}

twenty1 = 20 :: Int -- 20
twenty2 = 20 :: Integer -- 20
twenty3 = 20 :: Float -- 20.0
twenty4 = 20 :: Double -- 20.0

{-
 たとえば、演算子 * の型を調べると
 
 > :t (*)
 (*) :: Num a => a -> a -> a

 👉これは、* が 2 つの数を受け取って 1 つの数を返すこと、これら 3 つの数はすべて同じ型であることを示している。
 　この型クラス制約により、(5 :: Int) * (6 :: Integer) は型エラーになり、 5 ** (6:: Integer) は正しく動く。
 　5 は Int や Integer として振舞うことができるが、同時に両方にはなれない。
-}

-- 🌸 Floating 型クラス

{-
  Floating 型クラスには Float と Double が含まれる。この型クラスは浮動小数点数に使う。
  引数と返り値が Floating 型クラスのインスタンスであるような関数は、その結果を浮動小数点数で表現できないと意味のある計算ができない。
  例としては sin, cos, sqrt、** などがある。

  > :t sin
  sin :: Floating a => a -> a
-}

-- 🌸 Integral 型クラス

{-
    Integral もまた数の型クラス。Num が実数を含むすべての数を含む一方、Integral には整数（全体）_のみ_ が含まれる。
    この型クラスは Int と Integer を含む。
    数を扱う便利な関数として fromIntegral がある。この関数は次のような型を持っている。
        fromIntegral :: (Integral a, Num b) => a -> b
            📝fromIntegral の型シグネチャに複数の型クラス制約があることに注目。複数の型クラス制約を書くときは、このようにカンマで区切って括弧で囲む。

    この型シグネチャからわかるのは、fromIntegral はなんらかの整数を引数に取り、もっと一般的な数を返すということ。
    この関数は、整数と浮動小数点数を一緒に扱いたいときに役に立つ。たとえば、length 関数は次のような型宣言を持っている。

        length :: [a] -> Int // 実際に調べてみると `length :: Foldable t => t a -> Int` となるので若干違う気がするが。。

    そのため、リストの長さを取得してそれに 3.2 を加えるような式はエラーになる（Int と浮動小数点数を足し合わせ用としているため）。
    それをやりたい場合は fromIntegral を使ってこうする。
        > fromIntegral (length [1, 2, 3, 4]) + 3.2 
        7.2

    もっと単純な例にすると、（完全に動作確認のための例で、マッチポンプ的だが）
    (10 :: Int) + 3.2 とすると型が合わずにエラーとなるが、
    fromIntegral (10 :: Int) + 3.2 とすると 13.2 と計算できる。
-}

---- 型クラスに関する注意点 ----

{-

    型クラスは抽象的なインターフェイスとして定義されているので、1 つの型はいくつもの型クラスのインスタンスになることができるし、
    1 つの型クラスはいくつもの型をインスタンスとして持てる。

    たとえば、Char 型をインスタンスとする型クラスはたくさんあって、その中には　Eq と Ord クラスがあり、これは 2 つの文字は等値性比較とアルファベット順比較の両方ができるからである。

    型をある型クラスのインスタンスにするために、いったん別のインスタンスにする必要があることがある。例えば、Ord クラスのインスタンスになるには
    先に Eq クラスのインスタンスになる必要がある。
    言い換えれば、Eq クラスのインスタンスであることは　Ord クラスのインスタンスになるための必要条件である。
    2 つのものが順序づけられるということは、それらが等しいかどうかもわかるはずだ、と考えれば納得できよう。

-}